<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"dash_utils_Round10.js.html":{"id":"dash_utils_Round10.js.html","title":"Source: dash/utils/Round10.js","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Source: dash/utils/Round10.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ /** * Static methods for rounding decimals * * Modified version of the CC0-licenced example at: * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/round * * @export * @class Round10 */ export default class Round10 { /** * Decimal round. * * @param {Number} value The number. * @param {Integer} exp The exponent (the 10 logarithm of the adjustment base). * @returns {Number} The adjusted value. */ static round10(value, exp) { return _decimalAdjust('round', value, exp); } } /** * Decimal adjustment of a number. * * @param {String} type The type of adjustment. * @param {Number} value The number. * @param {Integer} exp The exponent (the 10 logarithm of the adjustment base). * @returns {Number} The adjusted value. */ function _decimalAdjust(type, value, exp) { // If the exp is undefined or zero... if (typeof exp === 'undefined' || +exp === 0) { return Math[type](value); } value = +value; exp = +exp; // If the value is not a number or the exp is not an integer... if (value === null || isNaN(value) || !(typeof exp === 'number' &amp;&amp; exp % 1 === 0)) { return NaN; } // Shift value = value.toString().split('e'); value = Math[type](+(value[0] + 'e' + (value[1] ? (+value[1] - exp) : -exp))); // Shift back value = value.toString().split('e'); return +(value[0] + 'e' + (value[1] ? (+value[1] + exp) : exp)); } × Search results Close "},"streaming_controllers_AbrController.js.html":{"id":"streaming_controllers_AbrController.js.html","title":"Source: streaming/controllers/AbrController.js","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Source: streaming/controllers/AbrController.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ import ABRRulesCollection from '../rules/abr/ABRRulesCollection'; import Constants from '../constants/Constants'; import MetricsConstants from '../constants/MetricsConstants'; import BitrateInfo from '../vo/BitrateInfo'; import FragmentModel from '../models/FragmentModel'; import EventBus from '../../core/EventBus'; import Events from '../../core/events/Events'; import FactoryMaker from '../../core/FactoryMaker'; import RulesContext from '../rules/RulesContext'; import SwitchRequest from '../rules/SwitchRequest'; import SwitchRequestHistory from '../rules/SwitchRequestHistory'; import DroppedFramesHistory from '../rules/DroppedFramesHistory'; import ThroughputHistory from '../rules/ThroughputHistory'; import {HTTPRequest} from '../vo/metrics/HTTPRequest'; import Debug from '../../core/Debug'; const ABANDON_LOAD = 'abandonload'; const ALLOW_LOAD = 'allowload'; const DEFAULT_VIDEO_BITRATE = 1000; const DEFAULT_AUDIO_BITRATE = 100; const QUALITY_DEFAULT = 0; function AbrController() { const context = this.context; const debug = Debug(context).getInstance(); const eventBus = EventBus(context).getInstance(); let instance, logger, abrRulesCollection, streamController, autoSwitchBitrate, topQualities, qualityDict, bitrateDict, ratioDict, streamProcessorDict, abandonmentStateDict, abandonmentTimeout, limitBitrateByPortal, usePixelRatioInLimitBitrateByPortal, windowResizeEventCalled, elementWidth, elementHeight, manifestModel, dashManifestModel, adapter, videoModel, mediaPlayerModel, domStorage, playbackIndex, switchHistoryDict, droppedFramesHistory, throughputHistory, isUsingBufferOccupancyABRDict, metricsModel, dashMetrics, useDeadTimeLatency; function setup() { logger = debug.getLogger(instance); resetInitialSettings(); } function registerStreamType(type, streamProcessor) { switchHistoryDict[type] = SwitchRequestHistory(context).create(); streamProcessorDict[type] = streamProcessor; abandonmentStateDict[type] = abandonmentStateDict[type] || {}; abandonmentStateDict[type].state = ALLOW_LOAD; isUsingBufferOccupancyABRDict[type] = false; eventBus.on(Events.LOADING_PROGRESS, onFragmentLoadProgress, this); if (type == Constants.VIDEO) { eventBus.on(Events.QUALITY_CHANGE_RENDERED, onQualityChangeRendered, this); droppedFramesHistory = DroppedFramesHistory(context).create(); setElementSize(); } eventBus.on(Events.METRIC_ADDED, onMetricAdded, this); throughputHistory = ThroughputHistory(context).create({ mediaPlayerModel: mediaPlayerModel }); } function unRegisterStreamType(type) { delete streamProcessorDict[type]; } function createAbrRulesCollection() { abrRulesCollection = ABRRulesCollection(context).create({ metricsModel: metricsModel, dashMetrics: dashMetrics, mediaPlayerModel: mediaPlayerModel, adapter: adapter }); abrRulesCollection.initialize(); } function resetInitialSettings() { autoSwitchBitrate = {video: true, audio: true}; topQualities = {}; qualityDict = {}; bitrateDict = {}; ratioDict = {}; abandonmentStateDict = {}; streamProcessorDict = {}; switchHistoryDict = {}; isUsingBufferOccupancyABRDict = {}; limitBitrateByPortal = false; useDeadTimeLatency = true; usePixelRatioInLimitBitrateByPortal = false; if (windowResizeEventCalled === undefined) { windowResizeEventCalled = false; } playbackIndex = undefined; droppedFramesHistory = undefined; throughputHistory = undefined; clearTimeout(abandonmentTimeout); abandonmentTimeout = null; } function reset() { resetInitialSettings(); eventBus.off(Events.LOADING_PROGRESS, onFragmentLoadProgress, this); eventBus.off(Events.QUALITY_CHANGE_RENDERED, onQualityChangeRendered, this); eventBus.off(Events.METRIC_ADDED, onMetricAdded, this); if (abrRulesCollection) { abrRulesCollection.reset(); } } function setConfig(config) { if (!config) return; if (config.streamController) { streamController = config.streamController; } if (config.domStorage) { domStorage = config.domStorage; } if (config.mediaPlayerModel) { mediaPlayerModel = config.mediaPlayerModel; } if (config.metricsModel) { metricsModel = config.metricsModel; } if (config.dashMetrics) { dashMetrics = config.dashMetrics; } if (config.dashManifestModel) { dashManifestModel = config.dashManifestModel; } if (config.adapter) { adapter = config.adapter; } if (config.manifestModel) { manifestModel = config.manifestModel; } if (config.videoModel) { videoModel = config.videoModel; } } function onQualityChangeRendered(e) { if (e.mediaType === Constants.VIDEO) { playbackIndex = e.oldQuality; droppedFramesHistory.push(playbackIndex, videoModel.getPlaybackQuality()); } } function onMetricAdded(e) { if (e.metric === MetricsConstants.HTTP_REQUEST &amp;&amp; e.value &amp;&amp; e.value.type === HTTPRequest.MEDIA_SEGMENT_TYPE &amp;&amp; (e.mediaType === Constants.AUDIO || e.mediaType === Constants.VIDEO)) { throughputHistory.push(e.mediaType, e.value, useDeadTimeLatency); } if (e.metric === MetricsConstants.BUFFER_LEVEL &amp;&amp; (e.mediaType === Constants.AUDIO || e.mediaType === Constants.VIDEO)) { updateIsUsingBufferOccupancyABR(e.mediaType, 0.001 * e.value.level); } } function getTopQualityIndexFor(type, id) { let idx; topQualities[id] = topQualities[id] || {}; if (!topQualities[id].hasOwnProperty(type)) { topQualities[id][type] = 0; } idx = checkMaxBitrate(topQualities[id][type], type); idx = checkMaxRepresentationRatio(idx, type, topQualities[id][type]); idx = checkPortalSize(idx, type); return idx; } /** * Gets top BitrateInfo for the player * @param {string} type - 'video' or 'audio' are the type options. * @returns {BitrateInfo | null} */ function getTopBitrateInfoFor(type) { if (type &amp;&amp; streamProcessorDict &amp;&amp; streamProcessorDict[type]) { const streamInfo = streamProcessorDict[type].getStreamInfo(); if (streamInfo.id) { const idx = getTopQualityIndexFor(type, streamInfo.id); const bitrates = getBitrateList(streamProcessorDict[type].getMediaInfo()); return bitrates[idx] ? bitrates[idx] : null; } } return null; } /** * @param {string} type * @returns {number} A value of the initial bitrate, kbps * @memberof AbrController# */ function getInitialBitrateFor(type) { const savedBitrate = domStorage.getSavedBitrateSettings(type); if (!bitrateDict.hasOwnProperty(type)) { if (ratioDict.hasOwnProperty(type)) { const manifest = manifestModel.getValue(); const representation = dashManifestModel.getAdaptationForType(manifest, 0, type).Representation; if (Array.isArray(representation)) { const repIdx = Math.max(Math.round(representation.length * ratioDict[type]) - 1, 0); bitrateDict[type] = representation[repIdx].bandwidth; } else { bitrateDict[type] = 0; } } else if (!isNaN(savedBitrate)) { bitrateDict[type] = savedBitrate; } else { bitrateDict[type] = (type === Constants.VIDEO) ? DEFAULT_VIDEO_BITRATE : DEFAULT_AUDIO_BITRATE; } } return bitrateDict[type]; } /** * @param {string} type * @param {number} value A value of the initial bitrate, kbps * @memberof AbrController# */ function setInitialBitrateFor(type, value) { bitrateDict[type] = value; } function getInitialRepresentationRatioFor(type) { if (!ratioDict.hasOwnProperty(type)) { return null; } return ratioDict[type]; } function setInitialRepresentationRatioFor(type, value) { ratioDict[type] = value; } function getMaxAllowedBitrateFor(type) { if (bitrateDict.hasOwnProperty('max') &amp;&amp; bitrateDict.max.hasOwnProperty(type)) { return bitrateDict.max[type]; } return NaN; } function getMinAllowedBitrateFor(type) { if (bitrateDict.hasOwnProperty('min') &amp;&amp; bitrateDict.min.hasOwnProperty(type)) { return bitrateDict.min[type]; } return NaN; } //TODO change bitrateDict structure to hold one object for video and audio with initial and max values internal. // This means you need to update all the logic around initial bitrate DOMStorage, RebController etc... function setMaxAllowedBitrateFor(type, value) { bitrateDict.max = bitrateDict.max || {}; bitrateDict.max[type] = value; } function setMinAllowedBitrateFor(type, value) { bitrateDict.min = bitrateDict.min || {}; bitrateDict.min[type] = value; } function getMaxAllowedIndexFor(type) { const maxBitrate = getMaxAllowedBitrateFor(type); if (maxBitrate) { return getQualityForBitrate(streamProcessorDict[type].getMediaInfo(), maxBitrate); } else { return undefined; } } function getMinAllowedIndexFor(type) { const minBitrate = getMinAllowedBitrateFor(type); if (minBitrate) { const bitrateList = getBitrateList(streamProcessorDict[type].getMediaInfo()); // This returns the quality index &lt;= for the given bitrate let minIdx = getQualityForBitrate(streamProcessorDict[type].getMediaInfo(), minBitrate); if (bitrateList[minIdx] &amp;&amp; minIdx &lt; bitrateList.length - 1 &amp;&amp; bitrateList[minIdx].bitrate &lt; minBitrate * 1000) { minIdx++; // Go to the next bitrate } return minIdx; } else { return undefined; } } function getMaxAllowedRepresentationRatioFor(type) { if (ratioDict.hasOwnProperty('max') &amp;&amp; ratioDict.max.hasOwnProperty(type)) { return ratioDict.max[type]; } return 1; } function setMaxAllowedRepresentationRatioFor(type, value) { ratioDict.max = ratioDict.max || {}; ratioDict.max[type] = value; } function getAutoSwitchBitrateFor(type) { return autoSwitchBitrate[type]; } function setAutoSwitchBitrateFor(type, value) { autoSwitchBitrate[type] = value; } function getLimitBitrateByPortal() { return limitBitrateByPortal; } function setLimitBitrateByPortal(value) { limitBitrateByPortal = value; } function getUsePixelRatioInLimitBitrateByPortal() { return usePixelRatioInLimitBitrateByPortal; } function setUsePixelRatioInLimitBitrateByPortal(value) { usePixelRatioInLimitBitrateByPortal = value; } function getUseDeadTimeLatency() { return useDeadTimeLatency; } function setUseDeadTimeLatency(value) { useDeadTimeLatency = value; } function checkPlaybackQuality(type) { if (type &amp;&amp; streamProcessorDict &amp;&amp; streamProcessorDict[type]) { const streamInfo = streamProcessorDict[type].getStreamInfo(); const streamId = streamInfo ? streamInfo.id : null; const oldQuality = getQualityFor(type); const rulesContext = RulesContext(context).create({ abrController: instance, streamProcessor: streamProcessorDict[type], currentValue: oldQuality, switchHistory: switchHistoryDict[type], droppedFramesHistory: droppedFramesHistory, useBufferOccupancyABR: useBufferOccupancyABR(type) }); if (droppedFramesHistory) { const playbackQuality = videoModel.getPlaybackQuality(); if (playbackQuality) { droppedFramesHistory.push(playbackIndex, playbackQuality); } } if (getAutoSwitchBitrateFor(type)) { const minIdx = getMinAllowedIndexFor(type); const topQualityIdx = getTopQualityIndexFor(type, streamId); const switchRequest = abrRulesCollection.getMaxQuality(rulesContext); let newQuality = switchRequest.quality; if (minIdx !== undefined &amp;&amp; newQuality &lt; minIdx) { newQuality = minIdx; } if (newQuality &gt; topQualityIdx) { newQuality = topQualityIdx; } switchHistoryDict[type].push({oldValue: oldQuality, newValue: newQuality}); if (newQuality &gt; SwitchRequest.NO_CHANGE &amp;&amp; newQuality != oldQuality) { if (abandonmentStateDict[type].state === ALLOW_LOAD || newQuality &gt; oldQuality) { changeQuality(type, oldQuality, newQuality, topQualityIdx, switchRequest.reason); } } else if (debug.getLogToBrowserConsole()) { const bufferLevel = dashMetrics.getCurrentBufferLevel(metricsModel.getReadOnlyMetricsFor(type)); logger.debug('AbrController (' + type + ') stay on ' + oldQuality + '/' + topQualityIdx + ' (buffer: ' + bufferLevel + ')'); } } } } function setPlaybackQuality(type, streamInfo, newQuality, reason) { const id = streamInfo.id; const oldQuality = getQualityFor(type); const isInt = newQuality !== null &amp;&amp; !isNaN(newQuality) &amp;&amp; (newQuality % 1 === 0); if (!isInt) throw new Error('argument is not an integer'); const topQualityIdx = getTopQualityIndexFor(type, id); if (newQuality !== oldQuality &amp;&amp; newQuality &gt;= 0 &amp;&amp; newQuality &lt;= topQualityIdx) { changeQuality(type, oldQuality, newQuality, topQualityIdx, reason); } } function changeQuality(type, oldQuality, newQuality, topQualityIdx, reason) { if (type &amp;&amp; streamProcessorDict[type]) { const streamInfo = streamProcessorDict[type].getStreamInfo(); const id = streamInfo ? streamInfo.id : null; if (debug.getLogToBrowserConsole()) { const bufferLevel = dashMetrics.getCurrentBufferLevel(metricsModel.getReadOnlyMetricsFor(type)); logger.info('AbrController (' + type + ') switch from ' + oldQuality + ' to ' + newQuality + '/' + topQualityIdx + ' (buffer: ' + bufferLevel + ') ' + (reason ? JSON.stringify(reason) : '.')); } setQualityFor(type, id, newQuality); eventBus.trigger(Events.QUALITY_CHANGE_REQUESTED, {mediaType: type, streamInfo: streamInfo, oldQuality: oldQuality, newQuality: newQuality, reason: reason}); } } function setAbandonmentStateFor(type, state) { abandonmentStateDict[type].state = state; } function getAbandonmentStateFor(type) { return abandonmentStateDict[type] ? abandonmentStateDict[type].state : null; } /** * @param {MediaInfo} mediaInfo * @param {number} bitrate A bitrate value, kbps * @param {number} latency Expected latency of connection, ms * @returns {number} A quality index &lt;= for the given bitrate * @memberof AbrController# */ function getQualityForBitrate(mediaInfo, bitrate, latency) { if (useDeadTimeLatency &amp;&amp; latency &amp;&amp; streamProcessorDict[mediaInfo.type].getCurrentRepresentationInfo() &amp;&amp; streamProcessorDict[mediaInfo.type].getCurrentRepresentationInfo().fragmentDuration) { latency = latency / 1000; const fragmentDuration = streamProcessorDict[mediaInfo.type].getCurrentRepresentationInfo().fragmentDuration; if (latency &gt; fragmentDuration) { return 0; } else { const deadTimeRatio = latency / fragmentDuration; bitrate = bitrate * (1 - deadTimeRatio); } } const bitrateList = getBitrateList(mediaInfo); if (!bitrateList || bitrateList.length === 0) { return QUALITY_DEFAULT; } for (let i = bitrateList.length - 1; i &gt;= 0; i--) { const bitrateInfo = bitrateList[i]; if (bitrate * 1000 &gt;= bitrateInfo.bitrate) { return i; } } return 0; } /** * @param {MediaInfo} mediaInfo * @returns {Array|null} A list of {@link BitrateInfo} objects * @memberof AbrController# */ function getBitrateList(mediaInfo) { if (!mediaInfo || !mediaInfo.bitrateList) return null; const bitrateList = mediaInfo.bitrateList; const type = mediaInfo.type; const infoList = []; let bitrateInfo; for (let i = 0, ln = bitrateList.length; i &lt; ln; i++) { bitrateInfo = new BitrateInfo(); bitrateInfo.mediaType = type; bitrateInfo.qualityIndex = i; bitrateInfo.bitrate = bitrateList[i].bandwidth; bitrateInfo.width = bitrateList[i].width; bitrateInfo.height = bitrateList[i].height; bitrateInfo.scanType = bitrateList[i].scanType; infoList.push(bitrateInfo); } return infoList; } function updateIsUsingBufferOccupancyABR(mediaType, bufferLevel) { const strategy = mediaPlayerModel.getABRStrategy(); if (strategy === Constants.ABR_STRATEGY_BOLA) { isUsingBufferOccupancyABRDict[mediaType] = true; return; } else if (strategy === Constants.ABR_STRATEGY_THROUGHPUT) { isUsingBufferOccupancyABRDict[mediaType] = false; return; } // else ABR_STRATEGY_DYNAMIC const stableBufferTime = mediaPlayerModel.getStableBufferTime(); const switchOnThreshold = stableBufferTime; const switchOffThreshold = 0.5 * stableBufferTime; const useBufferABR = isUsingBufferOccupancyABRDict[mediaType]; const newUseBufferABR = bufferLevel &gt; (useBufferABR ? switchOffThreshold : switchOnThreshold); // use hysteresis to avoid oscillating rules isUsingBufferOccupancyABRDict[mediaType] = newUseBufferABR; if (newUseBufferABR !== useBufferABR) { if (newUseBufferABR) { logger.info('AbrController (' + mediaType + ') switching from throughput to buffer occupancy ABR rule (buffer: ' + bufferLevel.toFixed(3) + ').'); } else { logger.info('AbrController (' + mediaType + ') switching from buffer occupancy to throughput ABR rule (buffer: ' + bufferLevel.toFixed(3) + ').'); } } } function useBufferOccupancyABR(mediaType) { return isUsingBufferOccupancyABRDict[mediaType]; } function getThroughputHistory() { return throughputHistory; } function updateTopQualityIndex(mediaInfo) { const type = mediaInfo.type; const streamId = mediaInfo.streamInfo.id; const max = mediaInfo.representationCount - 1; setTopQualityIndex(type, streamId, max); return max; } function isPlayingAtTopQuality(streamInfo) { const streamId = streamInfo.id; const audioQuality = getQualityFor(Constants.AUDIO); const videoQuality = getQualityFor(Constants.VIDEO); const isAtTop = (audioQuality === getTopQualityIndexFor(Constants.AUDIO, streamId)) &amp;&amp; (videoQuality === getTopQualityIndexFor(Constants.VIDEO, streamId)); return isAtTop; } function getQualityFor(type) { if (type &amp;&amp; streamProcessorDict[type]) { const streamInfo = streamProcessorDict[type].getStreamInfo(); const id = streamInfo ? streamInfo.id : null; let quality; if (id) { qualityDict[id] = qualityDict[id] || {}; if (!qualityDict[id].hasOwnProperty(type)) { qualityDict[id][type] = QUALITY_DEFAULT; } quality = qualityDict[id][type]; return quality; } } return QUALITY_DEFAULT; } function setQualityFor(type, id, value) { qualityDict[id] = qualityDict[id] || {}; qualityDict[id][type] = value; } function setTopQualityIndex(type, id, value) { topQualities[id] = topQualities[id] || {}; topQualities[id][type] = value; } function checkMaxBitrate(idx, type) { let newIdx = idx; if (!streamProcessorDict[type]) { return newIdx; } const minIdx = getMinAllowedIndexFor(type); if (minIdx !== undefined) { newIdx = Math.max (idx , minIdx); } const maxIdx = getMaxAllowedIndexFor(type); if (maxIdx !== undefined) { newIdx = Math.min (newIdx , maxIdx); } return newIdx; } function checkMaxRepresentationRatio(idx, type, maxIdx) { const maxRepresentationRatio = getMaxAllowedRepresentationRatioFor(type); if (isNaN(maxRepresentationRatio) || maxRepresentationRatio &gt;= 1 || maxRepresentationRatio &lt; 0) { return idx; } return Math.min(idx , Math.round(maxIdx * maxRepresentationRatio) ); } function setWindowResizeEventCalled(value) { windowResizeEventCalled = value; } function setElementSize() { if (videoModel) { const hasPixelRatio = usePixelRatioInLimitBitrateByPortal &amp;&amp; window.hasOwnProperty('devicePixelRatio'); const pixelRatio = hasPixelRatio ? window.devicePixelRatio : 1; elementWidth = videoModel.getClientWidth() * pixelRatio; elementHeight = videoModel.getClientHeight() * pixelRatio; } } function checkPortalSize(idx, type) { if (type !== Constants.VIDEO || !limitBitrateByPortal || !streamProcessorDict[type]) { return idx; } if (!windowResizeEventCalled) { setElementSize(); } const manifest = manifestModel.getValue(); const representation = dashManifestModel.getAdaptationForType(manifest, 0, type).Representation; let newIdx = idx; if (elementWidth &gt; 0 &amp;&amp; elementHeight &gt; 0) { while ( newIdx &gt; 0 &amp;&amp; representation[newIdx] &amp;&amp; elementWidth &lt; representation[newIdx].width &amp;&amp; elementWidth - representation[newIdx - 1].width &lt; representation[newIdx].width - elementWidth ) { newIdx = newIdx - 1; } if (representation.length - 2 &gt;= newIdx &amp;&amp; representation[newIdx].width === representation[newIdx + 1].width) { newIdx = Math.min(idx, newIdx + 1); } } return newIdx; } function onFragmentLoadProgress(e) { const type = e.request.mediaType; if (getAutoSwitchBitrateFor(type)) { const streamProcessor = streamProcessorDict[type]; if (!streamProcessor) return;// There may be a fragment load in progress when we switch periods and recreated some controllers. const rulesContext = RulesContext(context).create({ abrController: instance, streamProcessor: streamProcessor, currentRequest: e.request, useBufferOccupancyABR: useBufferOccupancyABR(type) }); const switchRequest = abrRulesCollection.shouldAbandonFragment(rulesContext); if (switchRequest.quality &gt; SwitchRequest.NO_CHANGE) { const fragmentModel = streamProcessor.getFragmentModel(); const request = fragmentModel.getRequests({state: FragmentModel.FRAGMENT_MODEL_LOADING, index: e.request.index})[0]; if (request) { //TODO Check if we should abort or if better to finish download. check bytesLoaded/Total fragmentModel.abortRequests(); setAbandonmentStateFor(type, ABANDON_LOAD); switchHistoryDict[type].reset(); switchHistoryDict[type].push({oldValue: getQualityFor(type, streamController.getActiveStreamInfo()), newValue: switchRequest.quality, confidence: 1, reason: switchRequest.reason}); setPlaybackQuality(type, streamController.getActiveStreamInfo(), switchRequest.quality, switchRequest.reason); clearTimeout(abandonmentTimeout); abandonmentTimeout = setTimeout( () =&gt; {setAbandonmentStateFor(type, ALLOW_LOAD); abandonmentTimeout = null;}, mediaPlayerModel.getAbandonLoadTimeout() ); } } } } instance = { isPlayingAtTopQuality: isPlayingAtTopQuality, updateTopQualityIndex: updateTopQualityIndex, getThroughputHistory: getThroughputHistory, getBitrateList: getBitrateList, getQualityForBitrate: getQualityForBitrate, getMaxAllowedBitrateFor: getMaxAllowedBitrateFor, getTopBitrateInfoFor: getTopBitrateInfoFor, getMinAllowedBitrateFor: getMinAllowedBitrateFor, setMaxAllowedBitrateFor: setMaxAllowedBitrateFor, setMinAllowedBitrateFor: setMinAllowedBitrateFor, getMaxAllowedIndexFor: getMaxAllowedIndexFor, getMinAllowedIndexFor: getMinAllowedIndexFor, getMaxAllowedRepresentationRatioFor: getMaxAllowedRepresentationRatioFor, setMaxAllowedRepresentationRatioFor: setMaxAllowedRepresentationRatioFor, getInitialBitrateFor: getInitialBitrateFor, setInitialBitrateFor: setInitialBitrateFor, getInitialRepresentationRatioFor: getInitialRepresentationRatioFor, setInitialRepresentationRatioFor: setInitialRepresentationRatioFor, setAutoSwitchBitrateFor: setAutoSwitchBitrateFor, getAutoSwitchBitrateFor: getAutoSwitchBitrateFor, getUseDeadTimeLatency: getUseDeadTimeLatency, setUseDeadTimeLatency: setUseDeadTimeLatency, setLimitBitrateByPortal: setLimitBitrateByPortal, getLimitBitrateByPortal: getLimitBitrateByPortal, getUsePixelRatioInLimitBitrateByPortal: getUsePixelRatioInLimitBitrateByPortal, setUsePixelRatioInLimitBitrateByPortal: setUsePixelRatioInLimitBitrateByPortal, getQualityFor: getQualityFor, getAbandonmentStateFor: getAbandonmentStateFor, setPlaybackQuality: setPlaybackQuality, checkPlaybackQuality: checkPlaybackQuality, getTopQualityIndexFor: getTopQualityIndexFor, setElementSize: setElementSize, setWindowResizeEventCalled: setWindowResizeEventCalled, createAbrRulesCollection: createAbrRulesCollection, registerStreamType: registerStreamType, unRegisterStreamType: unRegisterStreamType, setConfig: setConfig, reset: reset }; setup(); return instance; } AbrController.__dashjs_factory_name = 'AbrController'; const factory = FactoryMaker.getSingletonFactory(AbrController); factory.ABANDON_LOAD = ABANDON_LOAD; factory.QUALITY_DEFAULT = QUALITY_DEFAULT; FactoryMaker.updateSingletonFactory(AbrController.__dashjs_factory_name, factory); export default factory; × Search results Close "},"dash_parser_matchers_BaseMatcher.js.html":{"id":"dash_parser_matchers_BaseMatcher.js.html","title":"Source: dash/parser/matchers/BaseMatcher.js","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Source: dash/parser/matchers/BaseMatcher.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ /** * @classdesc a base type for matching and converting types in manifest to * something more useful */ class BaseMatcher { constructor(test, converter) { this._test = test; this._converter = converter; } get test() { return this._test; } get converter() { return this._converter; } } export default BaseMatcher; × Search results Close "},"streaming_utils_BoxParser.js.html":{"id":"streaming_utils_BoxParser.js.html","title":"Source: streaming/utils/BoxParser.js","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Source: streaming/utils/BoxParser.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ import IsoFile from './IsoFile'; import FactoryMaker from '../../core/FactoryMaker'; import ISOBoxer from 'codem-isoboxer'; import IsoBoxSearchInfo from '../vo/IsoBoxSearchInfo'; function BoxParser(/*config*/) { let instance; let context = this.context; /** * @param {ArrayBuffer} data * @returns {IsoFile|null} * @memberof BoxParser# */ function parse(data) { if (!data) return null; if (data.fileStart === undefined) { data.fileStart = 0; } let parsedFile = ISOBoxer.parseBuffer(data); let dashIsoFile = IsoFile(context).create(); dashIsoFile.setData(parsedFile); return dashIsoFile; } /** * From the list of type boxes to look for, returns the latest one that is fully completed (header + payload). This * method only looks into the list of top boxes and doesn't analyze nested boxes. * @param {string[]} types * @param {ArrayBuffer|uint8Array} buffer * @param {number} offset * @returns {IsoBoxSearchInfo} * @memberof BoxParser# */ function findLastTopIsoBoxCompleted(types, buffer, offset) { if (offset === undefined) { offset = 0; } // 8 = size (uint32) + type (4 characters) if (!buffer || offset + 8 &gt;= buffer.byteLength) { return new IsoBoxSearchInfo(0, false); } const data = (buffer instanceof ArrayBuffer) ? new Uint8Array(buffer) : buffer; let boxInfo; let lastCompletedOffset = 0; while (offset &lt; data.byteLength) { const boxSize = parseUint32(data, offset); const boxType = parseIsoBoxType(data, offset + 4); if (boxSize === 0) { break; } if (offset + boxSize &lt;= data.byteLength) { if (types.indexOf(boxType) &gt;= 0) { boxInfo = new IsoBoxSearchInfo(offset, true, boxSize); } else { lastCompletedOffset = offset + boxSize; } } offset += boxSize; } if (!boxInfo) { return new IsoBoxSearchInfo(lastCompletedOffset, false); } return boxInfo; } function parseUint32(data, offset) { return data[offset + 3] &gt;&gt;&gt; 0 | (data[offset + 2] &lt;&lt; 8) &gt;&gt;&gt; 0 | (data[offset + 1] &lt;&lt; 16) &gt;&gt;&gt; 0 | (data[offset] &lt;&lt; 24) &gt;&gt;&gt; 0; } function parseIsoBoxType(data, offset) { return String.fromCharCode(data[offset++]) + String.fromCharCode(data[offset++]) + String.fromCharCode(data[offset++]) + String.fromCharCode(data[offset]); } instance = { parse: parse, findLastTopIsoBoxCompleted: findLastTopIsoBoxCompleted }; return instance; } BoxParser.__dashjs_factory_name = 'BoxParser'; export default FactoryMaker.getSingletonFactory(BoxParser); × Search results Close "},"streaming_text_NotFragmentedTextBufferController.js.html":{"id":"streaming_text_NotFragmentedTextBufferController.js.html","title":"Source: streaming/text/NotFragmentedTextBufferController.js","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Source: streaming/text/NotFragmentedTextBufferController.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ import Constants from '../constants/Constants'; import EventBus from '../../core/EventBus'; import Events from '../../core/events/Events'; import FactoryMaker from '../../core/FactoryMaker'; import InitCache from '../utils/InitCache'; import SourceBufferSink from '../SourceBufferSink'; import TextController from '../../streaming/text/TextController'; const BUFFER_CONTROLLER_TYPE = 'NotFragmentedTextBufferController'; function NotFragmentedTextBufferController(config) { config = config || {}; let context = this.context; let eventBus = EventBus(context).getInstance(); const textController = TextController(context).getInstance(); let errHandler = config.errHandler; let type = config.type; let mimeType = config.mimeType; let streamProcessor = config.streamProcessor; let instance, isBufferingCompleted, initialized, mediaSource, buffer, representationController, initCache; function setup() { initialized = false; mediaSource = null; representationController = null; isBufferingCompleted = false; eventBus.on(Events.DATA_UPDATE_COMPLETED, onDataUpdateCompleted, instance); eventBus.on(Events.INIT_FRAGMENT_LOADED, onInitFragmentLoaded, instance); } function getBufferControllerType() { return BUFFER_CONTROLLER_TYPE; } function initialize(source) { setMediaSource(source); representationController = streamProcessor.getRepresentationController(); initCache = InitCache(context).getInstance(); } /** * @param {MediaInfo }mediaInfo * @memberof BufferController# */ function createBuffer(mediaInfo) { try { buffer = SourceBufferSink(context).create(mediaSource, mediaInfo); if (!initialized) { const textBuffer = buffer.getBuffer(); if (textBuffer.hasOwnProperty(Constants.INITIALIZE)) { textBuffer.initialize(mimeType, streamProcessor); } initialized = true; } } catch (e) { if ((mediaInfo.isText) || (mediaInfo.codec.indexOf('codecs=&quot;stpp') !== -1) || (mediaInfo.codec.indexOf('codecs=&quot;wvtt') !== -1)) { try { buffer = textController.getTextSourceBuffer(); } catch (e) { errHandler.mediaSourceError('Error creating ' + type + ' source buffer.'); } } else { errHandler.mediaSourceError('Error creating ' + type + ' source buffer.'); } } } function getType() { return type; } function getBuffer() { return buffer; } function setMediaSource(value) { mediaSource = value; } function getMediaSource() { return mediaSource; } function getStreamProcessor() { return streamProcessor; } function getIsPruningInProgress() { return false; } function dischargePreBuffer() { } function setSeekStartTime() { //Unused - TODO Remove need for stub function } function getBufferLevel() { return 0; } function getIsBufferingCompleted() { return isBufferingCompleted; } function reset(errored) { eventBus.off(Events.DATA_UPDATE_COMPLETED, onDataUpdateCompleted, instance); eventBus.off(Events.INIT_FRAGMENT_LOADED, onInitFragmentLoaded, instance); if (!errored &amp;&amp; buffer) { buffer.abort(); buffer.reset(); buffer = null; } } function onDataUpdateCompleted(e) { if (e.sender.getStreamProcessor() !== streamProcessor) { return; } const chunk = initCache.extract(streamProcessor.getStreamInfo().id, e.sender.getCurrentRepresentation().id); if (!chunk) { eventBus.trigger(Events.TIMED_TEXT_REQUESTED, { index: 0, sender: e.sender }); //TODO make index dynamic if referring to MP? } } function onInitFragmentLoaded(e) { if (e.fragmentModel !== streamProcessor.getFragmentModel() || (!e.chunk.bytes)) { return; } initCache.save(e.chunk); buffer.append(e.chunk); eventBus.trigger(Events.STREAM_COMPLETED, { request: e.request, fragmentModel: e.fragmentModel }); } function switchInitData(streamId, representationId) { const chunk = initCache.extract(streamId, representationId); if (!chunk) { eventBus.trigger(Events.TIMED_TEXT_REQUESTED, { index: 0, sender: instance }); } } function getRangeAt() { return null; } function updateTimestampOffset(MSETimeOffset) { if (buffer.timestampOffset !== MSETimeOffset &amp;&amp; !isNaN(MSETimeOffset)) { buffer.timestampOffset = MSETimeOffset; } } instance = { getBufferControllerType: getBufferControllerType, initialize: initialize, createBuffer: createBuffer, getType: getType, getStreamProcessor: getStreamProcessor, setSeekStartTime: setSeekStartTime, getBuffer: getBuffer, getBufferLevel: getBufferLevel, setMediaSource: setMediaSource, getMediaSource: getMediaSource, getIsBufferingCompleted: getIsBufferingCompleted, getIsPruningInProgress: getIsPruningInProgress, dischargePreBuffer: dischargePreBuffer, switchInitData: switchInitData, getRangeAt: getRangeAt, reset: reset, updateTimestampOffset: updateTimestampOffset }; setup(); return instance; } NotFragmentedTextBufferController.__dashjs_factory_name = BUFFER_CONTROLLER_TYPE; export default FactoryMaker.getClassFactory(NotFragmentedTextBufferController); × Search results Close "},"streaming_text_TextBufferController.js.html":{"id":"streaming_text_TextBufferController.js.html","title":"Source: streaming/text/TextBufferController.js","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Source: streaming/text/TextBufferController.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ import Constants from '../constants/Constants'; import FactoryMaker from '../../core/FactoryMaker'; import BufferController from './../controllers/BufferController'; import NotFragmentedTextBufferController from './NotFragmentedTextBufferController'; function TextBufferController(config) { config = config || {}; let context = this.context; let _BufferControllerImpl; let instance; function setup() { // according to text type, we create corresponding buffer controller if (config.type === Constants.FRAGMENTED_TEXT) { // in this case, internal buffer ocntroller is a classical BufferController object _BufferControllerImpl = BufferController(context).create({ type: config.type, metricsModel: config.metricsModel, mediaPlayerModel: config.mediaPlayerModel, manifestModel: config.manifestModel, errHandler: config.errHandler, streamController: config.streamController, mediaController: config.mediaController, adapter: config.adapter, textController: config.textController, abrController: config.abrController, playbackController: config.playbackController, streamProcessor: config.streamProcessor }); } else { // in this case, internal buffer controller is a not fragmented text controller object _BufferControllerImpl = NotFragmentedTextBufferController(context).create({ type: config.type, mimeType: config.mimeType, errHandler: config.errHandler, streamProcessor: config.streamProcessor }); } } function getBufferControllerType() { return _BufferControllerImpl.getBufferControllerType(); } function initialize(source, StreamProcessor) { return _BufferControllerImpl.initialize(source, StreamProcessor); } /** * @param {MediaInfo }mediaInfo * @returns {Object} SourceBuffer object * @memberof BufferController# */ function createBuffer(mediaInfo) { return _BufferControllerImpl.createBuffer(mediaInfo); } function getType() { return _BufferControllerImpl.getType(); } function getBuffer() { return _BufferControllerImpl.getBuffer(); } function setBuffer(value) { _BufferControllerImpl.setBuffer(value); } function getMediaSource() { return _BufferControllerImpl.getMediaSource(); } function setMediaSource(value) { _BufferControllerImpl.setMediaSource(value); } function getStreamProcessor() { _BufferControllerImpl.getStreamProcessor(); } function setSeekStartTime(value) { _BufferControllerImpl.setSeekStartTime(value); } function getBufferLevel() { return _BufferControllerImpl.getBufferLevel(); } function reset(errored) { _BufferControllerImpl.reset(errored); } function getIsBufferingCompleted() { return _BufferControllerImpl.getIsBufferingCompleted(); } function switchInitData(streamId, representationId) { _BufferControllerImpl.switchInitData(streamId, representationId); } function getIsPruningInProgress() { return _BufferControllerImpl.getIsPruningInProgress(); } function dischargePreBuffer() { return _BufferControllerImpl.dischargePreBuffer(); } function getRangeAt(time) { return _BufferControllerImpl.getRangeAt(time); } function updateTimestampOffset(MSETimeOffset) { const buffer = getBuffer(); if (buffer.timestampOffset !== MSETimeOffset &amp;&amp; !isNaN(MSETimeOffset)) { buffer.timestampOffset = MSETimeOffset; } } instance = { getBufferControllerType: getBufferControllerType, initialize: initialize, createBuffer: createBuffer, getType: getType, getStreamProcessor: getStreamProcessor, setSeekStartTime: setSeekStartTime, getBuffer: getBuffer, setBuffer: setBuffer, getBufferLevel: getBufferLevel, setMediaSource: setMediaSource, getMediaSource: getMediaSource, getIsBufferingCompleted: getIsBufferingCompleted, getIsPruningInProgress: getIsPruningInProgress, dischargePreBuffer: dischargePreBuffer, switchInitData: switchInitData, getRangeAt: getRangeAt, reset: reset, updateTimestampOffset: updateTimestampOffset }; setup(); return instance; } TextBufferController.__dashjs_factory_name = 'TextBufferController'; export default FactoryMaker.getClassFactory(TextBufferController); × Search results Close "},"streaming_vo_metrics_BufferLevel.js.html":{"id":"streaming_vo_metrics_BufferLevel.js.html","title":"Source: streaming/vo/metrics/BufferLevel.js","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Source: streaming/vo/metrics/BufferLevel.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ /** * @class */ class BufferLevel { /** * @description This Object holds reference to the current buffer level and the time it was recorded. */ constructor() { /** * Real-Time | Time of the measurement of the buffer level. * @public */ this.t = null; /** * Level of the buffer in milliseconds. Indicates the playout duration for which * media data of all active media components is available starting from the * current playout time. * @public */ this.level = null; } } export default BufferLevel; × Search results Close "},"streaming_vo_metrics_BufferState.js.html":{"id":"streaming_vo_metrics_BufferState.js.html","title":"Source: streaming/vo/metrics/BufferState.js","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Source: streaming/vo/metrics/BufferState.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ import BufferController from '../../controllers/BufferController'; /** * @class */ class BufferState { /** * @description This Object holds reference to the current buffer state of the video element. */ constructor() { /** * The Buffer Level Target determined by the BufferLevelRule. * @public */ this.target = null; /** * Current buffer state. Will be BufferController.BUFFER_EMPTY or BufferController.BUFFER_LOADED. * @public */ this.state = BufferController.BUFFER_EMPTY; } } export default BufferState; × Search results Close "},"streaming_utils_Capabilities.js.html":{"id":"streaming_utils_Capabilities.js.html","title":"Source: streaming/utils/Capabilities.js","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Source: streaming/utils/Capabilities.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ import FactoryMaker from '../../core/FactoryMaker'; function Capabilities() { let instance, encryptedMediaSupported; function setup() { encryptedMediaSupported = false; } function supportsMediaSource() { let hasWebKit = ('WebKitMediaSource' in window); let hasMediaSource = ('MediaSource' in window); return (hasWebKit || hasMediaSource); } /** * Returns whether Encrypted Media Extensions are supported on this * user agent * * @return {boolean} true if EME is supported, false otherwise */ function supportsEncryptedMedia() { return encryptedMediaSupported; } function setEncryptedMediaSupported(value) { encryptedMediaSupported = value; } function supportsCodec(codec) { if ('MediaSource' in window &amp;&amp; MediaSource.isTypeSupported(codec)) { return true; } if ('WebKitMediaSource' in window &amp;&amp; WebKitMediaSource.isTypeSupported(codec)) { return true; } return false; } instance = { supportsMediaSource: supportsMediaSource, supportsEncryptedMedia: supportsEncryptedMedia, supportsCodec: supportsCodec, setEncryptedMediaSupported: setEncryptedMediaSupported }; setup(); return instance; } Capabilities.__dashjs_factory_name = 'Capabilities'; export default FactoryMaker.getSingletonFactory(Capabilities); × Search results Close "},"streaming_protection_vo_ClearKeyKeySet.js.html":{"id":"streaming_protection_vo_ClearKeyKeySet.js.html","title":"Source: streaming/protection/vo/ClearKeyKeySet.js","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Source: streaming/protection/vo/ClearKeyKeySet.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ /** * @classdesc A collection of ClearKey encryption keys with an (optional) associated * type * @ignore */ class ClearKeyKeySet { /** * @param {Array.&lt;KeyPair&gt;} keyPairs * @param {string} type the type of keys in this set. One of either 'persistent' * or 'temporary'. Can also be null or undefined. * @class * @ignore */ constructor(keyPairs, type) { if (type &amp;&amp; type !== 'persistent' &amp;&amp; type !== 'temporary') throw new Error('Invalid ClearKey key set type! Must be one of \\'persistent\\' or \\'temporary\\''); this.keyPairs = keyPairs; this.type = type; } /** * Convert this key set to its JSON Web Key (JWK) representation * * @return {ArrayBuffer} JWK object UTF-8 encoded as ArrayBuffer */ toJWK() { let i; let numKeys = this.keyPairs.length; let jwk = {keys: []}; for (i = 0; i &lt; numKeys; i++) { let key = { kty: 'oct', alg: 'A128KW', kid: this.keyPairs[i].keyID, k: this.keyPairs[i].key }; jwk.keys.push(key); } if (this.type) { jwk.type = this.type; } let jwkString = JSON.stringify(jwk); const len = jwkString.length; // Convert JSON string to ArrayBuffer let buf = new ArrayBuffer(len); let bView = new Uint8Array(buf); for (i = 0; i &lt; len; i++) bView[i] = jwkString.charCodeAt(i); return buf; } } export default ClearKeyKeySet; × Search results Close "},"streaming_protection_CommonEncryption.js.html":{"id":"streaming_protection_CommonEncryption.js.html","title":"Source: streaming/protection/CommonEncryption.js","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Source: streaming/protection/CommonEncryption.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ class CommonEncryption { /** * Find and return the ContentProtection element in the given array * that indicates support for MPEG Common Encryption * * @param {Array} cpArray array of content protection elements * @returns {Object|null} the Common Encryption content protection element or * null if one was not found */ static findCencContentProtection(cpArray) { let retVal = null; for (let i = 0; i &lt; cpArray.length; ++i) { let cp = cpArray[i]; if (cp.schemeIdUri.toLowerCase() === 'urn:mpeg:dash:mp4protection:2011' &amp;&amp; cp.value.toLowerCase() === 'cenc') retVal = cp; } return retVal; } /** * Returns just the data portion of a single PSSH * * @param {ArrayBuffer} pssh - the PSSH * @return {ArrayBuffer} data portion of the PSSH */ static getPSSHData(pssh) { let offset = 8; // Box size and type fields let view = new DataView(pssh); // Read version let version = view.getUint8(offset); offset += 20; // Version (1), flags (3), system ID (16) if (version &gt; 0) { offset += 4 + (16 * view.getUint32(offset)); // Key ID count (4) and All key IDs (16*count) } offset += 4; // Data size return pssh.slice(offset); } /** * Returns the PSSH associated with the given key system from the concatenated * list of PSSH boxes in the given initData * * @param {KeySystem} keySystem the desired * key system * @param {ArrayBuffer} initData 'cenc' initialization data. Concatenated list of PSSH. * @returns {ArrayBuffer|null} The PSSH box data corresponding to the given key system, null if not found * or null if a valid association could not be found. */ static getPSSHForKeySystem(keySystem, initData) { let psshList = CommonEncryption.parsePSSHList(initData); if (psshList.hasOwnProperty(keySystem.uuid.toLowerCase())) { return psshList[keySystem.uuid.toLowerCase()]; } return null; } /** * Parse a standard common encryption PSSH which contains a simple * base64-encoding of the init data * * @param {Object} cpData the ContentProtection element * @param {BASE64} BASE64 reference * @returns {ArrayBuffer|null} the init data or null if not found */ static parseInitDataFromContentProtection(cpData, BASE64) { if ('pssh' in cpData) { return BASE64.decodeArray(cpData.pssh.__text).buffer; } return null; } /** * Parses list of PSSH boxes into keysystem-specific PSSH data * * @param {ArrayBuffer} data - the concatenated list of PSSH boxes as provided by * CDM as initialization data when CommonEncryption content is detected * @returns {Object|Array} an object that has a property named according to each of * the detected key system UUIDs (e.g. 00000000-0000-0000-0000-0000000000) * and a ArrayBuffer (the entire PSSH box) as the property value */ static parsePSSHList(data) { if (data === null) return []; let dv = new DataView(data.buffer || data); // data.buffer first for Uint8Array support let done = false; let pssh = {}; // TODO: Need to check every data read for end of buffer let byteCursor = 0; while (!done) { let size, nextBox, version, systemID, psshDataSize; let boxStart = byteCursor; if (byteCursor &gt;= dv.buffer.byteLength) break; /* Box size */ size = dv.getUint32(byteCursor); nextBox = byteCursor + size; byteCursor += 4; /* Verify PSSH */ if (dv.getUint32(byteCursor) !== 0x70737368) { byteCursor = nextBox; continue; } byteCursor += 4; /* Version must be 0 or 1 */ version = dv.getUint8(byteCursor); if (version !== 0 &amp;&amp; version !== 1) { byteCursor = nextBox; continue; } byteCursor++; byteCursor += 3; /* skip flags */ // 16-byte UUID/SystemID systemID = ''; let i, val; for (i = 0; i &lt; 4; i++) { val = dv.getUint8(byteCursor + i).toString(16); systemID += (val.length === 1) ? '0' + val : val; } byteCursor += 4; systemID += '-'; for (i = 0; i &lt; 2; i++) { val = dv.getUint8(byteCursor + i).toString(16); systemID += (val.length === 1) ? '0' + val : val; } byteCursor += 2; systemID += '-'; for (i = 0; i &lt; 2; i++) { val = dv.getUint8(byteCursor + i).toString(16); systemID += (val.length === 1) ? '0' + val : val; } byteCursor += 2; systemID += '-'; for (i = 0; i &lt; 2; i++) { val = dv.getUint8(byteCursor + i).toString(16); systemID += (val.length === 1) ? '0' + val : val; } byteCursor += 2; systemID += '-'; for (i = 0; i &lt; 6; i++) { val = dv.getUint8(byteCursor + i).toString(16); systemID += (val.length === 1) ? '0' + val : val; } byteCursor += 6; systemID = systemID.toLowerCase(); /* PSSH Data Size */ psshDataSize = dv.getUint32(byteCursor); byteCursor += 4; /* PSSH Data */ pssh[systemID] = dv.buffer.slice(boxStart, nextBox); byteCursor = nextBox; } return pssh; } } export default CommonEncryption; × Search results Close "},"dash_parser_maps_CommonProperty.js.html":{"id":"dash_parser_maps_CommonProperty.js.html","title":"Source: dash/parser/maps/CommonProperty.js","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Source: dash/parser/maps/CommonProperty.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ /** * @classdesc a property belonging to a MapNode */ class CommonProperty { constructor(name) { const getDefaultMergeForName = (n) =&gt; n &amp;&amp; n.length &amp;&amp; n.charAt(0) === n.charAt(0).toUpperCase(); this._name = name; this._merge = getDefaultMergeForName(name); } get name() { return this._name; } get merge() { return this._merge; } } export default CommonProperty; × Search results Close "},"streaming_vo_metrics_DroppedFrames.js.html":{"id":"streaming_vo_metrics_DroppedFrames.js.html","title":"Source: streaming/vo/metrics/DroppedFrames.js","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Source: streaming/vo/metrics/DroppedFrames.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ /** * @class */ class DroppedFrames { /** * @description This Object holds reference to DroppedFrames count and the time it was recorded. */ constructor() { /** * Real-Time | Time of the measurement of the dropped frames. * @public */ this.time = null; /** * Number of dropped frames * @public */ this.droppedFrames = null; } } export default DroppedFrames; × Search results Close "},"streaming_vo_metrics_DVRInfo.js.html":{"id":"streaming_vo_metrics_DVRInfo.js.html","title":"Source: streaming/vo/metrics/DVRInfo.js","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Source: streaming/vo/metrics/DVRInfo.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ /** * @class */ class DVRInfo { /** * @description This Object holds reference to DVR availability window information. */ constructor() { /** * The current time of the video element when this was created. * @public */ this.time = null; /** * The current Segment Availability Range as an object with start and end properties. * It's delta defined by the timeShiftBufferDepth MPD attribute. * @public */ this.range = null; /** * Reference to the internal ManifestInfo.js VO. * @public */ this.manifestInfo = null; } } export default DVRInfo; × Search results Close "},"streaming_utils_EBMLParser.js.html":{"id":"streaming_utils_EBMLParser.js.html","title":"Source: streaming/utils/EBMLParser.js","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Source: streaming/utils/EBMLParser.js import FactoryMaker from '../../core/FactoryMaker'; /** * Creates an instance of an EBMLParser class which implements a large subset * of the functionality required to parse Matroska EBML * * @param {Object} config object with data member which is the buffer to parse */ function EBMLParser(config) { config = config || {}; let instance; let data = new DataView(config.data); let pos = 0; function getPos() { return pos; } function setPos(value) { pos = value; } /** * Consumes an EBML tag from the data stream. * * @param {Object} tag to parse, A tag is an object with at least a {number} tag and * {boolean} required flag. * @param {boolean} test whether or not the function should throw if a required * tag is not found * @return {boolean} whether or not the tag was found * @throws will throw an exception if a required tag is not found and test * param is false or undefined, or if the stream is malformed. * @memberof EBMLParser */ function consumeTag(tag, test) { let found = true; let bytesConsumed = 0; let p1, p2; if (test === undefined) { test = false; } if (tag.tag &gt; 0xFFFFFF) { if (data.getUint32(pos) !== tag.tag) { found = false; } bytesConsumed = 4; } else if (tag.tag &gt; 0xFFFF) { // 3 bytes p1 = data.getUint16(pos); p2 = data.getUint8(pos + 2); // shift p1 over a byte and add p2 if (p1 * 256 + p2 !== tag.tag) { found = false; } bytesConsumed = 3; } else if (tag.tag &gt; 0xFF) { if (data.getUint16(pos) !== tag.tag) { found = false; } bytesConsumed = 2; } else { if (data.getUint8(pos) !== tag.tag) { found = false; } bytesConsumed = 1; } if (!found &amp;&amp; tag.required &amp;&amp; !test) { throw new Error('required tag not found'); } if (found) { pos += bytesConsumed; } return found; } /** * Consumes an EBML tag from the data stream. If the tag is found then this * function will also remove the size field which follows the tag from the * data stream. * * @param {Object} tag to parse, A tag is an object with at least a {number} tag and * {boolean} required flag. * @param {boolean} test whether or not the function should throw if a required * tag is not found * @return {boolean} whether or not the tag was found * @throws will throw an exception if a required tag is not found and test * param is false or undefined, or if the stream is malformedata. * @memberof EBMLParser */ function consumeTagAndSize(tag, test) { let found = consumeTag(tag, test); if (found) { getMatroskaCodedNum(); } return found; } /** * Consumes an EBML tag from the data stream. If the tag is found then this * function will also remove the size field which follows the tag from the * data stream. It will use the value of the size field to parse a binary * field, using a parser defined in the tag itself * * @param {Object} tag to parse, A tag is an object with at least a {number} tag, * {boolean} required flag, and a parse function which takes a size parameter * @return {boolean} whether or not the tag was found * @throws will throw an exception if a required tag is not found, * or if the stream is malformed * @memberof EBMLParser */ function parseTag(tag) { let size; consumeTag(tag); size = getMatroskaCodedNum(); return instance[tag.parse](size); } /** * Consumes an EBML tag from the data stream. If the tag is found then this * function will also remove the size field which follows the tag from the * data stream. It will use the value of the size field to skip over the * entire section of EBML encapsulated by the tag. * * @param {Object} tag to parse, A tag is an object with at least a {number} tag, and * {boolean} required flag * @param {boolean} test a flag to indicate if an exception should be thrown * if a required tag is not found * @return {boolean} whether or not the tag was found * @throws will throw an exception if a required tag is not found and test is * false or undefined or if the stream is malformed * @memberof EBMLParser */ function skipOverElement(tag, test) { let found = consumeTag(tag, test); let headerSize; if (found) { headerSize = getMatroskaCodedNum(); pos += headerSize; } return found; } /** * Returns and consumes a number encoded according to the Matroska EBML * specification from the bitstream. * * @param {boolean} retainMSB whether or not to retain the Most Significant Bit (the * first 1). this is usually true when reading Tag IDs. * @return {number} the decoded number * @throws will throw an exception if the bit stream is malformed or there is * not enough data * @memberof EBMLParser */ function getMatroskaCodedNum(retainMSB) { let bytesUsed = 1; let mask = 0x80; let maxBytes = 8; let extraBytes = -1; let num = 0; let ch = data.getUint8(pos); let i = 0; for (i = 0; i &lt; maxBytes; i += 1) { if ((ch &amp; mask) === mask) { num = (retainMSB === undefined) ? ch &amp; ~mask : ch; extraBytes = i; break; } mask &gt;&gt;= 1; } for (i = 0; i &lt; extraBytes; i += 1, bytesUsed += 1) { num = (num &lt;&lt; 8) | (0xff &amp; data.getUint8(pos + bytesUsed)); } pos += bytesUsed; return num; } /** * Returns and consumes a float from the bitstream. * * @param {number} size 4 or 8 byte floats are supported * @return {number} the decoded number * @throws will throw an exception if the bit stream is malformed or there is * not enough data * @memberof EBMLParser */ function getMatroskaFloat(size) { let outFloat; switch (size) { case 4: outFloat = data.getFloat32(pos); pos += 4; break; case 8: outFloat = data.getFloat64(pos); pos += 8; break; } return outFloat; } /** * Consumes and returns an unsigned int from the bitstream. * * @param {number} size 1 to 8 bytes * @return {number} the decoded number * @throws will throw an exception if the bit stream is malformed or there is * not enough data * @memberof EBMLParser */ function getMatroskaUint(size) { let val = 0; for (let i = 0; i &lt; size; i += 1) { val &lt;&lt;= 8; val |= data.getUint8(pos + i) &amp; 0xff; } pos += size; return val; } /** * Tests whether there is more data in the bitstream for parsing * * @return {boolean} whether there is more data to parse * @memberof EBMLParser */ function moreData() { return pos &lt; data.byteLength; } instance = { getPos: getPos, setPos: setPos, consumeTag: consumeTag, consumeTagAndSize: consumeTagAndSize, parseTag: parseTag, skipOverElement: skipOverElement, getMatroskaCodedNum: getMatroskaCodedNum, getMatroskaFloat: getMatroskaFloat, getMatroskaUint: getMatroskaUint, moreData: moreData }; return instance; } EBMLParser.__dashjs_factory_name = 'EBMLParser'; export default FactoryMaker.getClassFactory(EBMLParser); × Search results Close "},"streaming_controllers_EventController.js.html":{"id":"streaming_controllers_EventController.js.html","title":"Source: streaming/controllers/EventController.js","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Source: streaming/controllers/EventController.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ import FactoryMaker from '../../core/FactoryMaker'; import Debug from '../../core/Debug'; import EventBus from '../../core/EventBus'; import Events from '../../core/events/Events'; function EventController() { const MPD_RELOAD_SCHEME = 'urn:mpeg:dash:event:2012'; const MPD_RELOAD_VALUE = 1; const context = this.context; const eventBus = EventBus(context).getInstance(); let instance, logger, inlineEvents, // Holds all Inline Events not triggered yet inbandEvents, // Holds all Inband Events not triggered yet activeEvents, // Holds all Events currently running eventInterval, // variable holding the setInterval refreshDelay, // refreshTime for the setInterval presentationTimeThreshold, manifestModel, manifestUpdater, playbackController, isStarted; function setup() { logger = Debug(context).getInstance().getLogger(instance); resetInitialSettings(); } function resetInitialSettings() { isStarted = false; inlineEvents = {}; inbandEvents = {}; activeEvents = {}; eventInterval = null; refreshDelay = 100; presentationTimeThreshold = refreshDelay / 1000; } function checkSetConfigCall() { if (!manifestModel || !manifestUpdater || !playbackController) { throw new Error('setConfig function has to be called previously'); } } function stop() { if (eventInterval !== null &amp;&amp; isStarted) { clearInterval(eventInterval); eventInterval = null; isStarted = false; } } function start() { checkSetConfigCall(); logger.debug('Start Event Controller'); if (!isStarted &amp;&amp; !isNaN(refreshDelay)) { isStarted = true; eventInterval = setInterval(onEventTimer, refreshDelay); } } /** * Add events to the eventList. Events that are not in the mpd anymore but not triggered yet will still be deleted * @param {Array.&lt;Object&gt;} values */ function addInlineEvents(values) { checkSetConfigCall(); inlineEvents = {}; if (values) { for (var i = 0; i &lt; values.length; i++) { var event = values[i]; inlineEvents[event.id] = event; logger.debug('Add inline event with id ' + event.id); } } logger.debug('Added ' + values.length + ' inline events'); } /** * i.e. processing of any one event message box with the same id is sufficient * @param {Array.&lt;Object&gt;} values */ function addInbandEvents(values) { checkSetConfigCall(); for (var i = 0; i &lt; values.length; i++) { var event = values[i]; if (!(event.id in inbandEvents)) { if (event.eventStream.schemeIdUri === MPD_RELOAD_SCHEME &amp;&amp; inbandEvents[event.id] === undefined) { handleManifestReloadEvent(event); } inbandEvents[event.id] = event; logger.debug('Add inband event with id ' + event.id); } else { logger.debug('Repeated event with id ' + event.id); } } } function handleManifestReloadEvent(event) { if (event.eventStream.value == MPD_RELOAD_VALUE) { const timescale = event.eventStream.timescale || 1; const validUntil = event.presentationTime / timescale; let newDuration; if (event.presentationTime == 0xFFFFFFFF) {//0xFF... means remaining duration unknown newDuration = NaN; } else { newDuration = (event.presentationTime + event.duration) / timescale; } logger.info('Manifest validity changed: Valid until: ' + validUntil + '; remaining duration: ' + newDuration); eventBus.trigger(Events.MANIFEST_VALIDITY_CHANGED, { id: event.id, validUntil: validUntil, newDuration: newDuration, newManifestValidAfter: NaN //event.message_data - this is an arraybuffer with a timestring in it, but not used yet }); } } /** * Remove events which are over from the list */ function removeEvents() { if (activeEvents) { var currentVideoTime = playbackController.getTime(); var eventIds = Object.keys(activeEvents); for (var i = 0; i &lt; eventIds.length; i++) { var eventId = eventIds[i]; var curr = activeEvents[eventId]; if (curr !== null &amp;&amp; (curr.duration + curr.presentationTime) / curr.eventStream.timescale &lt; currentVideoTime) { logger.debug('Remove Event ' + eventId + ' at time ' + currentVideoTime); curr = null; delete activeEvents[eventId]; } } } } /** * Iterate through the eventList and trigger/remove the events */ function onEventTimer() { triggerEvents(inbandEvents); triggerEvents(inlineEvents); removeEvents(); } function refreshManifest() { checkSetConfigCall(); manifestUpdater.refreshManifest(); } function triggerEvents(events) { var currentVideoTime = playbackController.getTime(); var presentationTime; /* == Trigger events that are ready == */ if (events) { var eventIds = Object.keys(events); for (var i = 0; i &lt; eventIds.length; i++) { var eventId = eventIds[i]; var curr = events[eventId]; if (curr !== undefined) { presentationTime = curr.presentationTime / curr.eventStream.timescale; if (presentationTime === 0 || (presentationTime &lt;= currentVideoTime &amp;&amp; presentationTime + presentationTimeThreshold &gt; currentVideoTime)) { logger.debug('Start Event ' + eventId + ' at ' + currentVideoTime); if (curr.duration &gt; 0) { activeEvents[eventId] = curr; } if (curr.eventStream.schemeIdUri == MPD_RELOAD_SCHEME &amp;&amp; curr.eventStream.value == MPD_RELOAD_VALUE) { if (curr.duration !== 0 || curr.presentationTimeDelta !== 0) { //If both are set to zero, it indicates the media is over at this point. Don't reload the manifest. refreshManifest(); } } else { eventBus.trigger(curr.eventStream.schemeIdUri, {event: curr}); } delete events[eventId]; } } } } } function setConfig(config) { if (!config) return; if (config.manifestModel) { manifestModel = config.manifestModel; } if (config.manifestUpdater) { manifestUpdater = config.manifestUpdater; } if (config.playbackController) { playbackController = config.playbackController; } } function reset() { stop(); resetInitialSettings(); } instance = { addInlineEvents: addInlineEvents, addInbandEvents: addInbandEvents, stop: stop, start: start, setConfig: setConfig, reset: reset }; setup(); return instance; } EventController.__dashjs_factory_name = 'EventController'; export default FactoryMaker.getClassFactory(EventController); × Search results Close "},"streaming_models_FragmentModel.js.html":{"id":"streaming_models_FragmentModel.js.html","title":"Source: streaming/models/FragmentModel.js","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Source: streaming/models/FragmentModel.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ import EventBus from '../../core/EventBus'; import Events from '../../core/events/Events'; import FactoryMaker from '../../core/FactoryMaker'; import FragmentRequest from '../vo/FragmentRequest'; import Debug from '../../core/Debug'; const FRAGMENT_MODEL_LOADING = 'loading'; const FRAGMENT_MODEL_EXECUTED = 'executed'; const FRAGMENT_MODEL_CANCELED = 'canceled'; const FRAGMENT_MODEL_FAILED = 'failed'; function FragmentModel(config) { config = config || {}; const context = this.context; const eventBus = EventBus(context).getInstance(); const metricsModel = config.metricsModel; const fragmentLoader = config.fragmentLoader; let instance, logger, streamProcessor, executedRequests, loadingRequests; function setup() { logger = Debug(context).getInstance().getLogger(instance); resetInitialSettings(); eventBus.on(Events.LOADING_COMPLETED, onLoadingCompleted, instance); eventBus.on(Events.LOADING_DATA_PROGRESS, onLoadingInProgress, instance); eventBus.on(Events.LOADING_ABANDONED, onLoadingAborted, instance); } function setStreamProcessor(value) { streamProcessor = value; } function getStreamProcessor() { return streamProcessor; } function isFragmentLoaded(request) { const isEqualComplete = function (req1, req2) { return ((req1.action === FragmentRequest.ACTION_COMPLETE) &amp;&amp; (req1.action === req2.action)); }; const isEqualMedia = function (req1, req2) { return !isNaN(req1.index) &amp;&amp; (req1.startTime === req2.startTime) &amp;&amp; (req1.adaptationIndex === req2.adaptationIndex) &amp;&amp; (req1.type === req2.type); }; const isEqualInit = function (req1, req2) { return isNaN(req1.index) &amp;&amp; isNaN(req2.index) &amp;&amp; (req1.quality === req2.quality); }; const check = function (requests) { let isLoaded = false; requests.some(req =&gt; { if (isEqualMedia(request, req) || isEqualInit(request, req) || isEqualComplete(request, req)) { isLoaded = true; return isLoaded; } }); return isLoaded; }; if (!request) { return false; } return check(executedRequests); } function isFragmentLoadedOrPending(request) { let isLoaded = false; let i = 0; let req; // First, check if the fragment has already been loaded isLoaded = isFragmentLoaded(request); // Then, check if the fragment is about to be loeaded if (!isLoaded) { for (i = 0; i &lt; loadingRequests.length; i++) { req = loadingRequests[i]; if ((request.url === req.url) &amp;&amp; (request.startTime === req.startTime)) { isLoaded = true; } } } return isLoaded; } /** * * Gets an array of {@link FragmentRequest} objects * * @param {Object} filter The object with properties by which the method filters the requests to be returned. * the only mandatory property is state, which must be a value from * other properties should match the properties of {@link FragmentRequest}. E.g.: * getRequests({state: FragmentModel.FRAGMENT_MODEL_EXECUTED, quality: 0}) - returns * all the requests from executedRequests array where requests.quality = filter.quality * * @returns {Array} * @memberof FragmentModel# */ function getRequests(filter) { const states = filter ? filter.state instanceof Array ? filter.state : [filter.state] : []; let filteredRequests = []; states.forEach(state =&gt; { const requests = getRequestsForState(state); filteredRequests = filteredRequests.concat(filterRequests(requests, filter)); }); return filteredRequests; } function getRequestThreshold(req) { return isNaN(req.duration) ? 0.25 : req.duration / 8; } function removeExecutedRequestsBeforeTime(time) { executedRequests = executedRequests.filter(req =&gt; { const threshold = getRequestThreshold(req); return isNaN(req.startTime) || (time !== undefined ? req.startTime &gt;= time - threshold : false); }); } function removeExecutedRequestsAfterTime(time) { executedRequests = executedRequests.filter(req =&gt; { return isNaN(req.startTime) || (time !== undefined ? req.startTime &lt;= time : false); }); } function removeExecutedRequestsInTimeRange(start, end) { if (end &lt;= start + 0.5) { return; } executedRequests = executedRequests.filter(req =&gt; { const threshold = getRequestThreshold(req); return (isNaN(req.startTime) || req.startTime &gt;= (end - threshold)) || (isNaN(req.duration) || (req.startTime + req.duration) &lt;= (start + threshold)); }); } // Remove requests that are not &quot;represented&quot; by any of buffered ranges function syncExecutedRequestsWithBufferedRange(bufferedRanges, streamDuration) { if (!bufferedRanges || bufferedRanges.length === 0) { removeExecutedRequestsBeforeTime(); return; } let start = 0; for (let i = 0, ln = bufferedRanges.length; i &lt; ln; i++) { removeExecutedRequestsInTimeRange(start, bufferedRanges.start(i)); start = bufferedRanges.end(i); } if (streamDuration &gt; 0) { removeExecutedRequestsInTimeRange(start, streamDuration); } } function abortRequests() { fragmentLoader.abort(); loadingRequests = []; } function executeRequest(request) { switch (request.action) { case FragmentRequest.ACTION_COMPLETE: executedRequests.push(request); addSchedulingInfoMetrics(request, FRAGMENT_MODEL_EXECUTED); logger.debug('executeRequest trigger STREAM_COMPLETED'); eventBus.trigger(Events.STREAM_COMPLETED, { request: request, fragmentModel: this }); break; case FragmentRequest.ACTION_DOWNLOAD: addSchedulingInfoMetrics(request, FRAGMENT_MODEL_LOADING); loadingRequests.push(request); loadCurrentFragment(request); break; default: logger.warn('Unknown request action.'); } } function loadCurrentFragment(request) { eventBus.trigger(Events.FRAGMENT_LOADING_STARTED, { sender: instance, request: request }); fragmentLoader.load(request); } function getRequestForTime(arr, time, threshold) { // loop through the executed requests and pick the one for which the playback interval matches the given time const lastIdx = arr.length - 1; for (let i = lastIdx; i &gt;= 0; i--) { const req = arr[i]; const start = req.startTime; const end = start + req.duration; threshold = !isNaN(threshold) ? threshold : getRequestThreshold(req); if ((!isNaN(start) &amp;&amp; !isNaN(end) &amp;&amp; ((time + threshold) &gt;= start) &amp;&amp; ((time - threshold) &lt; end)) || (isNaN(start) &amp;&amp; isNaN(time))) { return req; } } return null; } function filterRequests(arr, filter) { // for time use a specific filtration function if (filter.hasOwnProperty('time')) { return [getRequestForTime(arr, filter.time, filter.threshold)]; } return arr.filter(request =&gt; { for (const prop in filter) { if (prop === 'state') continue; if (filter.hasOwnProperty(prop) &amp;&amp; request[prop] != filter[prop]) return false; } return true; }); } function getRequestsForState(state) { let requests; switch (state) { case FRAGMENT_MODEL_LOADING: requests = loadingRequests; break; case FRAGMENT_MODEL_EXECUTED: requests = executedRequests; break; default: requests = []; } return requests; } function addSchedulingInfoMetrics(request, state) { metricsModel.addSchedulingInfo( request.mediaType, new Date(), request.type, request.startTime, request.availabilityStartTime, request.duration, request.quality, request.range, state); metricsModel.addRequestsQueue(request.mediaType, loadingRequests, executedRequests); } function onLoadingCompleted(e) { if (e.sender !== fragmentLoader) return; loadingRequests.splice(loadingRequests.indexOf(e.request), 1); if (e.response &amp;&amp; !e.error) { executedRequests.push(e.request); } addSchedulingInfoMetrics(e.request, e.error ? FRAGMENT_MODEL_FAILED : FRAGMENT_MODEL_EXECUTED); eventBus.trigger(Events.FRAGMENT_LOADING_COMPLETED, { request: e.request, response: e.response, error: e.error, sender: this }); } function onLoadingInProgress(e) { if (e.sender !== fragmentLoader) return; eventBus.trigger(Events.FRAGMENT_LOADING_PROGRESS, { request: e.request, response: e.response, error: e.error, sender: this }); } function onLoadingAborted(e) { if (e.sender !== fragmentLoader) return; eventBus.trigger(Events.FRAGMENT_LOADING_ABANDONED, { streamProcessor: this.getStreamProcessor(), request: e.request, mediaType: e.mediaType }); } function resetInitialSettings() { executedRequests = []; loadingRequests = []; } function reset() { eventBus.off(Events.LOADING_COMPLETED, onLoadingCompleted, this); eventBus.off(Events.LOADING_DATA_PROGRESS, onLoadingInProgress, this); eventBus.off(Events.LOADING_ABANDONED, onLoadingAborted, this); if (fragmentLoader) { fragmentLoader.reset(); } resetInitialSettings(); } function addExecutedRequest(request) { executedRequests.push(request); } instance = { setStreamProcessor: setStreamProcessor, getStreamProcessor: getStreamProcessor, getRequests: getRequests, isFragmentLoaded: isFragmentLoaded, isFragmentLoadedOrPending: isFragmentLoadedOrPending, removeExecutedRequestsBeforeTime: removeExecutedRequestsBeforeTime, removeExecutedRequestsAfterTime: removeExecutedRequestsAfterTime, syncExecutedRequestsWithBufferedRange: syncExecutedRequestsWithBufferedRange, abortRequests: abortRequests, executeRequest: executeRequest, reset: reset, addExecutedRequest: addExecutedRequest }; setup(); return instance; } FragmentModel.__dashjs_factory_name = 'FragmentModel'; const factory = FactoryMaker.getClassFactory(FragmentModel); factory.FRAGMENT_MODEL_LOADING = FRAGMENT_MODEL_LOADING; factory.FRAGMENT_MODEL_EXECUTED = FRAGMENT_MODEL_EXECUTED; factory.FRAGMENT_MODEL_CANCELED = FRAGMENT_MODEL_CANCELED; factory.FRAGMENT_MODEL_FAILED = FRAGMENT_MODEL_FAILED; FactoryMaker.updateClassFactory(FragmentModel.__dashjs_factory_name, factory); export default factory; × Search results Close "},"streaming_FragmentSink.js.html":{"id":"streaming_FragmentSink.js.html","title":"Source: streaming/FragmentSink.js","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Source: streaming/FragmentSink.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ /** * The an end place to put fragments after they have been fetched. * @interface FragmentSink */ /** * Append a chunk to the internal buffer. You should assume that the effects of this are asynchronous. * @function FragmentSink#append * @param {Object} chunk A loaded chunk like that generated by the FragmentController */ /** * Remove data from within the specified time ranges. * @function FragmentSink#remove * @param {?Number} start The beginning of the range that should be removed from the sink's internal buffer. If NaN, it is regarded as unbounded. * @param {?Number} end The end of the range that should be removed from the sink's internal buffer. If NaN, it is regarded as unbounded. */ /** * Abort an append operation currently ongoing. * @function FragmentSink#abort */ /** * @function FragmentSink#getAllBufferRanges * @returns {Array} A TimeRanges-like object representing all the buffer ranges that are present in the sink. */ /** * Remove all the data in the sink's internal buffer. * @function FragmentSink#reset */ × Search results Close "},"streaming_metrics_metrics_handlers_GenericMetricHandler.js.html":{"id":"streaming_metrics_metrics_handlers_GenericMetricHandler.js.html","title":"Source: streaming/metrics/metrics/handlers/GenericMetricHandler.js","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Source: streaming/metrics/metrics/handlers/GenericMetricHandler.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ function GenericMetricHandler() { let instance, metricName, reportingController; function initialize(name, rc) { metricName = name; reportingController = rc; } function reset() { reportingController = null; metricName = undefined; } function handleNewMetric(metric, vo) { // simply pass metric straight through if (metric === metricName) { if (reportingController) { reportingController.report(metricName, vo); } } } instance = { initialize: initialize, reset: reset, handleNewMetric: handleNewMetric }; return instance; } GenericMetricHandler.__dashjs_factory_name = 'GenericMetricHandler'; export default dashjs.FactoryMaker.getClassFactory(GenericMetricHandler); /* jshint ignore:line */ × Search results Close "},"streaming_metrics_utils_HandlerHelpers.js.html":{"id":"streaming_metrics_utils_HandlerHelpers.js.html","title":"Source: streaming/metrics/utils/HandlerHelpers.js","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Source: streaming/metrics/utils/HandlerHelpers.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ function HandlerHelpers() { return { reconstructFullMetricName: function (key, n, type) { let mn = key; if (n) { mn += '(' + n; if (type &amp;&amp; type.length) { mn += ',' + type; } mn += ')'; } return mn; }, validateN: function (n_ms) { if (!n_ms) { throw new Error('missing n'); } if (isNaN(n_ms)) { throw new Error('n is NaN'); } // n is a positive integer is defined to refer to the metric // in which the buffer level is recorded every n ms. if (n_ms &lt; 0) { throw new Error('n must be positive'); } return n_ms; } }; } HandlerHelpers.__dashjs_factory_name = 'HandlerHelpers'; export default dashjs.FactoryMaker.getSingletonFactory(HandlerHelpers); /* jshint ignore:line */ × Search results Close "},"streaming_vo_metrics_HTTPRequest.js.html":{"id":"streaming_vo_metrics_HTTPRequest.js.html","title":"Source: streaming/vo/metrics/HTTPRequest.js","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Source: streaming/vo/metrics/HTTPRequest.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ /** * @classdesc This Object holds reference to the HTTPRequest for manifest, fragment and xlink loading. * Members which are not defined in ISO23009-1 Annex D should be prefixed by a _ so that they are ignored * by Metrics Reporting code. */ class HTTPRequest { /** * @class */ constructor() { /** * Identifier of the TCP connection on which the HTTP request was sent. * @public */ this.tcpid = null; /** * This is an optional parameter and should not be included in HTTP request/response transactions for progressive download. * The type of the request: * - MPD * - XLink expansion * - Initialization Fragment * - Index Fragment * - Media Fragment * - Bitstream Switching Fragment * - other * @public */ this.type = null; /** * The original URL (before any redirects or failures) * @public */ this.url = null; /** * The actual URL requested, if different from above * @public */ this.actualurl = null; /** * The contents of the byte-range-spec part of the HTTP Range header. * @public */ this.range = null; /** * Real-Time | The real time at which the request was sent. * @public */ this.trequest = null; /** * Real-Time | The real time at which the first byte of the response was received. * @public */ this.tresponse = null; /** * The HTTP response code. * @public */ this.responsecode = null; /** * The duration of the throughput trace intervals (ms), for successful requests only. * @public */ this.interval = null; /** * Throughput traces, for successful requests only. * @public */ this.trace = []; /** * Type of stream (&quot;audio&quot; | &quot;video&quot; etc..) * @public */ this._stream = null; /** * Real-Time | The real time at which the request finished. * @public */ this._tfinish = null; /** * The duration of the media requests, if available, in milliseconds. * @public */ this._mediaduration = null; /** * all the response headers from request. * @public */ this._responseHeaders = null; /** * The selected service location for the request. string. * @public */ this._serviceLocation = null; } } /** * @classdesc This Object holds reference to the progress of the HTTPRequest. */ class HTTPRequestTrace { /** * @class */ constructor() { /** * Real-Time | Measurement stream start. * @public */ this.s = null; /** * Measurement stream duration (ms). * @public */ this.d = null; /** * List of integers counting the bytes received in each trace interval within the measurement stream. * @public */ this.b = []; } } HTTPRequest.GET = 'GET'; HTTPRequest.HEAD = 'HEAD'; HTTPRequest.MPD_TYPE = 'MPD'; HTTPRequest.XLINK_EXPANSION_TYPE = 'XLinkExpansion'; HTTPRequest.INIT_SEGMENT_TYPE = 'InitializationSegment'; HTTPRequest.INDEX_SEGMENT_TYPE = 'IndexSegment'; HTTPRequest.MEDIA_SEGMENT_TYPE = 'MediaSegment'; HTTPRequest.BITSTREAM_SWITCHING_SEGMENT_TYPE = 'BitstreamSwitchingSegment'; HTTPRequest.OTHER_TYPE = 'other'; export { HTTPRequest, HTTPRequestTrace }; × Search results Close "},"streaming_utils_IsoFile.js.html":{"id":"streaming_utils_IsoFile.js.html","title":"Source: streaming/utils/IsoFile.js","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Source: streaming/utils/IsoFile.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ import IsoBox from '../vo/IsoBox'; import FactoryMaker from '../../core/FactoryMaker'; function IsoFile() { let instance, parsedIsoFile; /** * @param {string} type * @returns {IsoBox|null} * @memberof IsoFile# */ function getBox(type) { if (!type || !parsedIsoFile || !parsedIsoFile.boxes || (parsedIsoFile.boxes.length === 0) || typeof parsedIsoFile.fetch !== 'function') return null; return convertToDashIsoBox(parsedIsoFile.fetch(type)); } /** * @param {string} type * @returns {Array|null} array of {@link IsoBox} * @memberof IsoFile# */ function getBoxes(type) { let boxes = []; if (!type || !parsedIsoFile || typeof parsedIsoFile.fetchAll !== 'function') { return boxes; } let boxData = parsedIsoFile.fetchAll(type); let box; for (let i = 0, ln = boxData.length; i &lt; ln; i++) { box = convertToDashIsoBox(boxData[i]); if (box) { boxes.push(box); } } return boxes; } /** * @param {string} value * @memberof IsoFile# */ function setData(value) { parsedIsoFile = value; } /** * @returns {IsoBox|null} * @memberof IsoFile# */ function getLastBox() { if (!parsedIsoFile || !parsedIsoFile.boxes || !parsedIsoFile.boxes.length) return null; let type = parsedIsoFile.boxes[parsedIsoFile.boxes.length - 1].type; let boxes = getBoxes(type); return boxes.length &gt; 0 ? boxes[boxes.length - 1] : null; } function convertToDashIsoBox(boxData) { if (!boxData) return null; let box = new IsoBox(boxData); if (boxData.hasOwnProperty('_incomplete')) { box.isComplete = !boxData._incomplete; } return box; } instance = { getBox: getBox, getBoxes: getBoxes, setData: setData, getLastBox: getLastBox }; return instance; } IsoFile.__dashjs_factory_name = 'IsoFile'; export default FactoryMaker.getClassFactory(IsoFile); × Search results Close "},"streaming_protection_drm_KeySystem.js.html":{"id":"streaming_protection_drm_KeySystem.js.html","title":"Source: streaming/protection/drm/KeySystem.js","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Source: streaming/protection/drm/KeySystem.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ /** * Defines the public interface for all Key Systems (DRMs) supported * by the player. * * @interface KeySystem */ /** * Key system name string (e.g. 'org.w3.clearkey') * * @instance * @name systemString * @memberof KeySystem * @readonly * @type String */ /** * Key system UUID in the form '01234567-89ab-cdef-0123-456789abcdef' * * @instance * @name uuid * @memberof KeySystem * @readonly * @type String */ /** * The scheme ID URI for this key system in the form * 'urn:uuid:01234567-89ab-cdef-0123-456789abcdef' as used * in DASH ContentProtection elements * * @instance * @name schemeIdURI * @memberof KeySystem * @readonly * @type String */ /** * Parse DRM-specific init data from the ContentProtection * element. * * @function * @name KeySystem#getInitData * @param {Object} contentProtection the json-style contentProtection * object representing the ContentProtection element parsed from the * MPD XML document. * @returns {ArrayBuffer} EME initialization data */ /** * For some key systems, the CDM message contains HTTP headers that * can be parsed by the application and attached to the license request. * Returns a header object with key/value pairs as object properties/values * * @function * @name KeySystem#getRequestHeadersFromMessage * @param {ArrayBuffer} message the CDM message * @returns {?Object} headers object with header names as the object property * names and header values as the corresponding object property values. Return * null if no such headers were found or if the mechanism is not supported by * this key system */ /** * For some key systems, the CDM message contains more than just the * license request data. This method will pull the license request from * the CDM message, if necessary. * * @function * @name KeySystem#getLicenseRequestFromMessage * @param message {ArrayBuffer} the CDM message * @returns {Uint8Array} the license request message as will be passed to * XMLHttpRequest.send() */ /** * Returns a license server URL as parsed from key system initialization data (PSSH). * * @function * @name KeySystem#getLicenseServerURLFromInitData * @param initData {ArrayBuffer} the initialization data. This is just the &quot;Data&quot; field * from the PSSH box definition * @returns {?string} The license server URL or null if URL is not available in initData */ /** * Returns specific CDM (custom) data. * * @function * @name MediaPlayer.dependencies.protection.KeySystem#getCDMData * @returns {ArrayBuffer} the CDM (custom) data */ /** * Returns MediaKeySession session ID. * * @function * @name MediaPlayer.dependencies.protection.KeySystem#getSessionId * @returns {String} the MediaKeySession session ID */ × Search results Close "},"streaming_protection_drm_KeySystemW3CClearKey.js.html":{"id":"streaming_protection_drm_KeySystemW3CClearKey.js.html","title":"Source: streaming/protection/drm/KeySystemW3CClearKey.js","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Source: streaming/protection/drm/KeySystemW3CClearKey.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ import KeyPair from '../vo/KeyPair'; import ClearKeyKeySet from '../vo/ClearKeyKeySet'; import CommonEncryption from '../CommonEncryption'; import ProtectionConstants from '../../constants/ProtectionConstants'; const uuid = '1077efec-c0b2-4d02-ace3-3c1e52e2fb4b'; const systemString = ProtectionConstants.CLEARKEY_KEYSTEM_STRING; const schemeIdURI = 'urn:uuid:' + uuid; function KeySystemW3CClearKey(config) { let instance; const BASE64 = config.BASE64; const debug = config.debug; /** * Returns desired clearkeys (as specified in the CDM message) from protection data * * @param {ProtectionData} protectionData the protection data * @param {ArrayBuffer} message the ClearKey CDM message * @returns {ClearKeyKeySet} the key set or null if none found * @throws {Error} if a keyID specified in the CDM message was not found in the * protection data * @memberof KeySystemClearKey */ function getClearKeysFromProtectionData(protectionData, message) { let clearkeySet = null; if (protectionData) { // ClearKey is the only system that does not require a license server URL, so we // handle it here when keys are specified in protection data const jsonMsg = JSON.parse(String.fromCharCode.apply(null, new Uint8Array(message))); const keyPairs = []; for (let i = 0; i &lt; jsonMsg.kids.length; i++) { const clearkeyID = jsonMsg.kids[i]; const clearkey = (protectionData.clearkeys &amp;&amp; protectionData.clearkeys.hasOwnProperty(clearkeyID)) ? protectionData.clearkeys[clearkeyID] : null; if (!clearkey) { throw new Error('DRM: ClearKey keyID (' + clearkeyID + ') is not known!'); } // KeyIDs from CDM are not base64 padded. Keys may or may not be padded keyPairs.push(new KeyPair(clearkeyID, clearkey)); } clearkeySet = new ClearKeyKeySet(keyPairs); debug.warn('ClearKey schemeIdURI is using W3C Common PSSH systemID (1077efec-c0b2-4d02-ace3-3c1e52e2fb4b) in Content Protection. See DASH-IF IOP v4.1 section 7.6.2.4'); } return clearkeySet; } function getInitData(cp) { return CommonEncryption.parseInitDataFromContentProtection(cp, BASE64); } function getRequestHeadersFromMessage(/*message*/) { return null; } function getLicenseRequestFromMessage(message) { return new Uint8Array(message); } function getLicenseServerURLFromInitData(/*initData*/) { return null; } function getCDMData() { return null; } function getSessionId(/*cp*/) { return null; } instance = { uuid: uuid, schemeIdURI: schemeIdURI, systemString: systemString, getInitData: getInitData, getRequestHeadersFromMessage: getRequestHeadersFromMessage, getLicenseRequestFromMessage: getLicenseRequestFromMessage, getLicenseServerURLFromInitData: getLicenseServerURLFromInitData, getCDMData: getCDMData, getSessionId: getSessionId, getClearKeysFromProtectionData: getClearKeysFromProtectionData }; return instance; } KeySystemW3CClearKey.__dashjs_factory_name = 'KeySystemW3CClearKey'; export default dashjs.FactoryMaker.getSingletonFactory(KeySystemW3CClearKey); /* jshint ignore:line */ × Search results Close "},"streaming_protection_drm_KeySystemClearKey.js.html":{"id":"streaming_protection_drm_KeySystemClearKey.js.html","title":"Source: streaming/protection/drm/KeySystemClearKey.js","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Source: streaming/protection/drm/KeySystemClearKey.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ import KeyPair from '../vo/KeyPair'; import ClearKeyKeySet from '../vo/ClearKeyKeySet'; import CommonEncryption from '../CommonEncryption'; import ProtectionConstants from '../../constants/ProtectionConstants'; const uuid = 'e2719d58-a985-b3c9-781a-b030af78d30e'; const systemString = ProtectionConstants.CLEARKEY_KEYSTEM_STRING; const schemeIdURI = 'urn:uuid:' + uuid; function KeySystemClearKey(config) { config = config || {}; let instance; const BASE64 = config.BASE64; /** * Returns desired clearkeys (as specified in the CDM message) from protection data * * @param {ProtectionData} protectionData the protection data * @param {ArrayBuffer} message the ClearKey CDM message * @returns {ClearKeyKeySet} the key set or null if none found * @throws {Error} if a keyID specified in the CDM message was not found in the * protection data * @memberof KeySystemClearKey */ function getClearKeysFromProtectionData(protectionData, message) { let clearkeySet = null; if (protectionData) { // ClearKey is the only system that does not require a license server URL, so we // handle it here when keys are specified in protection data const jsonMsg = JSON.parse(String.fromCharCode.apply(null, new Uint8Array(message))); const keyPairs = []; for (let i = 0; i &lt; jsonMsg.kids.length; i++) { const clearkeyID = jsonMsg.kids[i]; const clearkey = (protectionData.clearkeys &amp;&amp; protectionData.clearkeys.hasOwnProperty(clearkeyID)) ? protectionData.clearkeys[clearkeyID] : null; if (!clearkey) { throw new Error('DRM: ClearKey keyID (' + clearkeyID + ') is not known!'); } // KeyIDs from CDM are not base64 padded. Keys may or may not be padded keyPairs.push(new KeyPair(clearkeyID, clearkey)); } clearkeySet = new ClearKeyKeySet(keyPairs); } return clearkeySet; } function getInitData(cp) { return CommonEncryption.parseInitDataFromContentProtection(cp, BASE64); } function getRequestHeadersFromMessage(/*message*/) { return null; } function getLicenseRequestFromMessage(message) { return new Uint8Array(message); } function getLicenseServerURLFromInitData(/*initData*/) { return null; } function getCDMData() { return null; } function getSessionId(/*cp*/) { return null; } instance = { uuid: uuid, schemeIdURI: schemeIdURI, systemString: systemString, getInitData: getInitData, getRequestHeadersFromMessage: getRequestHeadersFromMessage, getLicenseRequestFromMessage: getLicenseRequestFromMessage, getLicenseServerURLFromInitData: getLicenseServerURLFromInitData, getCDMData: getCDMData, getSessionId: getSessionId, getClearKeysFromProtectionData: getClearKeysFromProtectionData }; return instance; } KeySystemClearKey.__dashjs_factory_name = 'KeySystemClearKey'; export default dashjs.FactoryMaker.getSingletonFactory(KeySystemClearKey); /* jshint ignore:line */ × Search results Close "},"streaming_protection_drm_KeySystemPlayReady.js.html":{"id":"streaming_protection_drm_KeySystemPlayReady.js.html","title":"Source: streaming/protection/drm/KeySystemPlayReady.js","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Source: streaming/protection/drm/KeySystemPlayReady.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ /** * Microsoft PlayReady DRM * * @class * @implements KeySystem */ import CommonEncryption from '../CommonEncryption'; import ProtectionConstants from '../../constants/ProtectionConstants'; const uuid = '9a04f079-9840-4286-ab92-e65be0885f95'; const systemString = ProtectionConstants.PLAYREADY_KEYSTEM_STRING; const schemeIdURI = 'urn:uuid:' + uuid; const PRCDMData = '&lt;PlayReadyCDMData type=&quot;LicenseAcquisition&quot;&gt;&lt;LicenseAcquisition version=&quot;1.0&quot; Proactive=&quot;false&quot;&gt;&lt;CustomData encoding=&quot;base64encoded&quot;&gt;%CUSTOMDATA%&lt;/CustomData&gt;&lt;/LicenseAcquisition&gt;&lt;/PlayReadyCDMData&gt;'; let protData; function KeySystemPlayReady(config) { config = config || {}; let instance; let messageFormat = 'utf16'; const BASE64 = config.BASE64; function checkConfig() { if (!BASE64 || !BASE64.hasOwnProperty('decodeArray') || !BASE64.hasOwnProperty('decodeArray') ) { throw new Error('Missing config parameter(s)'); } } function getRequestHeadersFromMessage(message) { let msg, xmlDoc; const headers = {}; const parser = new DOMParser(); const dataview = (messageFormat === 'utf16') ? new Uint16Array(message) : new Uint8Array(message); msg = String.fromCharCode.apply(null, dataview); xmlDoc = parser.parseFromString(msg, 'application/xml'); const headerNameList = xmlDoc.getElementsByTagName('name'); const headerValueList = xmlDoc.getElementsByTagName('value'); for (let i = 0; i &lt; headerNameList.length; i++) { headers[headerNameList[i].childNodes[0].nodeValue] = headerValueList[i].childNodes[0].nodeValue; } // some versions of the PlayReady CDM return 'Content' instead of 'Content-Type'. // this is NOT w3c conform and license servers may reject the request! // -&gt; rename it to proper w3c definition! if (headers.hasOwnProperty('Content')) { headers['Content-Type'] = headers.Content; delete headers.Content; } // some devices (Ex: LG SmartTVs) require content-type to be defined if (!headers.hasOwnProperty('Content-Type')) { headers['Content-Type'] = 'text/xml; charset=' + messageFormat; } return headers; } function getLicenseRequestFromMessage(message) { let licenseRequest = null; const parser = new DOMParser(); const dataview = (messageFormat === 'utf16') ? new Uint16Array(message) : new Uint8Array(message); checkConfig(); const msg = String.fromCharCode.apply(null, dataview); const xmlDoc = parser.parseFromString(msg, 'application/xml'); if (xmlDoc.getElementsByTagName('Challenge')[0]) { const Challenge = xmlDoc.getElementsByTagName('Challenge')[0].childNodes[0].nodeValue; if (Challenge) { licenseRequest = BASE64.decode(Challenge); } } else if (xmlDoc.getElementsByTagName('parsererror').length) { // In case it is not an XML doc, return the message itself // There are CDM implementations of some devices (example: some smartTVs) that // return directly the challenge without wrapping it in an xml doc return message; } return licenseRequest; } function getLicenseServerURLFromInitData(initData) { if (initData) { const data = new DataView(initData); const numRecords = data.getUint16(4, true); let offset = 6; const parser = new DOMParser(); for (let i = 0; i &lt; numRecords; i++) { // Parse the PlayReady Record header const recordType = data.getUint16(offset, true); offset += 2; const recordLength = data.getUint16(offset, true); offset += 2; if (recordType !== 0x0001) { offset += recordLength; continue; } const recordData = initData.slice(offset, offset + recordLength); const record = String.fromCharCode.apply(null, new Uint16Array(recordData)); const xmlDoc = parser.parseFromString(record, 'application/xml'); // First try &lt;LA_URL&gt; if (xmlDoc.getElementsByTagName('LA_URL')[0]) { const laurl = xmlDoc.getElementsByTagName('LA_URL')[0].childNodes[0].nodeValue; if (laurl) { return laurl; } } // Optionally, try &lt;LUI_URL&gt; if (xmlDoc.getElementsByTagName('LUI_URL')[0]) { const luiurl = xmlDoc.getElementsByTagName('LUI_URL')[0].childNodes[0].nodeValue; if (luiurl) { return luiurl; } } } } return null; } function getInitData(cpData) { // * desc@ getInitData // * generate PSSH data from PROHeader defined in MPD file // * PSSH format: // * size (4) // * box type(PSSH) (8) // * Protection SystemID (16) // * protection system data size (4) - length of decoded PROHeader // * decoded PROHeader data from MPD file const PSSHBoxType = new Uint8Array([0x70, 0x73, 0x73, 0x68, 0x00, 0x00, 0x00, 0x00]); //'PSSH' 8 bytes const playreadySystemID = new Uint8Array([0x9a, 0x04, 0xf0, 0x79, 0x98, 0x40, 0x42, 0x86, 0xab, 0x92, 0xe6, 0x5b, 0xe0, 0x88, 0x5f, 0x95]); let byteCursor = 0; let uint8arraydecodedPROHeader = null; let PROSize, PSSHSize, PSSHBoxBuffer, PSSHBox, PSSHData; checkConfig(); // Handle common encryption PSSH if ('pssh' in cpData) { return CommonEncryption.parseInitDataFromContentProtection(cpData, BASE64); } // Handle native MS PlayReady ContentProtection elements if ('pro' in cpData) { uint8arraydecodedPROHeader = BASE64.decodeArray(cpData.pro.__text); } else if ('prheader' in cpData) { uint8arraydecodedPROHeader = BASE64.decodeArray(cpData.prheader.__text); } else { return null; } PROSize = uint8arraydecodedPROHeader.length; PSSHSize = 0x4 + PSSHBoxType.length + playreadySystemID.length + 0x4 + PROSize; PSSHBoxBuffer = new ArrayBuffer(PSSHSize); PSSHBox = new Uint8Array(PSSHBoxBuffer); PSSHData = new DataView(PSSHBoxBuffer); PSSHData.setUint32(byteCursor, PSSHSize); byteCursor += 0x4; PSSHBox.set(PSSHBoxType, byteCursor); byteCursor += PSSHBoxType.length; PSSHBox.set(playreadySystemID, byteCursor); byteCursor += playreadySystemID.length; PSSHData.setUint32(byteCursor, PROSize); byteCursor += 0x4; PSSHBox.set(uint8arraydecodedPROHeader, byteCursor); byteCursor += PROSize; return PSSHBox.buffer; } /** * It seems that some PlayReady implementations return their XML-based CDM * messages using UTF16, while others return them as UTF8. Use this function * to modify the message format to expect when parsing CDM messages. * * @param {string} format the expected message format. Either &quot;utf8&quot; or &quot;utf16&quot;. * @throws {Error} Specified message format is not one of &quot;utf8&quot; or &quot;utf16&quot; */ function setPlayReadyMessageFormat(format) { if (format !== 'utf8' &amp;&amp; format !== 'utf16') { throw new Error('Illegal PlayReady message format! -- ' + format); } messageFormat = format; } /** * Initialize the Key system with protection data * @param {Object} protectionData the protection data */ function init(protectionData) { if (protectionData) { protData = protectionData; } } /** * Get Playready Custom data */ function getCDMData() { let customData, cdmData, cdmDataBytes, i; checkConfig(); if (protData &amp;&amp; protData.cdmData) { // Convert custom data into multibyte string customData = []; for (i = 0; i &lt; protData.cdmData.length; ++i) { customData.push(protData.cdmData.charCodeAt(i)); customData.push(0); } customData = String.fromCharCode.apply(null, customData); // Encode in Base 64 the custom data string customData = BASE64.encode(customData); // Initialize CDM data with Base 64 encoded custom data // (see https://msdn.microsoft.com/en-us/library/dn457361.aspx) cdmData = PRCDMData.replace('%CUSTOMDATA%', customData); // Convert CDM data into multibyte characters cdmDataBytes = []; for (i = 0; i &lt; cdmData.length; ++i) { cdmDataBytes.push(cdmData.charCodeAt(i)); cdmDataBytes.push(0); } return new Uint8Array(cdmDataBytes).buffer; } return null; } function getSessionId(/*cp*/) { return null; } instance = { uuid: uuid, schemeIdURI: schemeIdURI, systemString: systemString, getInitData: getInitData, getRequestHeadersFromMessage: getRequestHeadersFromMessage, getLicenseRequestFromMessage: getLicenseRequestFromMessage, getLicenseServerURLFromInitData: getLicenseServerURLFromInitData, getCDMData: getCDMData, getSessionId: getSessionId, setPlayReadyMessageFormat: setPlayReadyMessageFormat, init: init }; return instance; } KeySystemPlayReady.__dashjs_factory_name = 'KeySystemPlayReady'; export default dashjs.FactoryMaker.getSingletonFactory(KeySystemPlayReady); /* jshint ignore:line */ × Search results Close "},"streaming_protection_servers_LicenseServer.js.html":{"id":"streaming_protection_servers_LicenseServer.js.html","title":"Source: streaming/protection/servers/LicenseServer.js","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Source: streaming/protection/servers/LicenseServer.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ /** * Defines the public interface for license server implementations supported * by the player. * * Different license servers have different requirements regarding the methods * used to request DRM licenses. Things like request headers, license response * formats (for both error and success cases) need to be customized for a * specific server implementation * * License servers handle requests for more than just initial license retrieval. * Each API takes a parameter which describes the message type as supported by * the Encrypted Media Extensions. * * @interface */ /** * Returns a new or updated license server URL based on the requirements of the * license server and possibly from information passed in the CDM license message * * @function * @name LicenseServer#getServerURLFromMessage * @param {?string} url the initially established URL (from ProtectionData or initData) * @param {ArrayBuffer} message the CDM message which may be needed to generate the license * requests URL * @param {string} messageType the message type associated with this request. Supported * message types can be found {@link https://w3c.github.io/encrypted-media/#idl-def-MediaKeyMessageType|here}. * @returns {string} the URL to use in license requests */ /** * Returns the HTTP method to be used (i.e. &quot;GET&quot;, &quot;POST&quot;, etc.) in * XMLHttpRequest.open(). * * @function * @name LicenseServer#getHTTPMethod * @param {string} messageType the message type associated with this request. Supported * message types can be found {@link https://w3c.github.io/encrypted-media/#idl-def-MediaKeyMessageType|here}. * @returns {string} the HTTP method */ /** * Returns the response type to set for XMLHttpRequest.responseType * * @function * @name LicenseServer#getResponseType * @param {string} keySystemStr the key system string representing the key system * associated with a license request. Multi-DRM license servers may have different * response types depending on the key system. * @param {string} messageType the message type associated with this request. Supported * message types can be found {@link https://w3c.github.io/encrypted-media/#idl-def-MediaKeyMessageType|here}. * @returns {string} the response type */ /** * Parses the license server response for any message intended for * the CDM. * * @function * @name LicenseServer#getLicenseMessage * @param {Object} serverResponse the response as returned in XMLHttpRequest.response * @param {string} keySystemStr the key system string representing the key system * associated with a license request. * @param {string} messageType the message type associated with this request. Supported * message types can be found {@link https://w3c.github.io/encrypted-media/#idl-def-MediaKeyMessageType|here}. * @returns {ArrayBuffer} message that will be sent to the CDM or null if no CDM message * was present in the response. */ /** * Parses the license server response during error conditions and returns a * string to display for debugging purposes * * @function * @name LicenseServer#getErrorResponse * @param {Object} serverResponse the server response * @param {string} messageType the message type associated with this request. Supported * message types can be found {@link https://w3c.github.io/encrypted-media/#idl-def-MediaKeyMessageType|here}. * @returns {string} an error message that indicates the reason for the failure */ × Search results Close "},"streaming_utils_LiveEdgeFinder.js.html":{"id":"streaming_utils_LiveEdgeFinder.js.html","title":"Source: streaming/utils/LiveEdgeFinder.js","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Source: streaming/utils/LiveEdgeFinder.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ import FactoryMaker from '../../core/FactoryMaker'; /** * @param {Object} config * @returns {{initialize: initialize, getLiveEdge: getLiveEdge, reset: reset}|*} * @constructor */ function LiveEdgeFinder(config) { config = config || {}; let instance; let timelineConverter = config.timelineConverter; let streamProcessor = config.streamProcessor; function checkConfig() { if (!timelineConverter || !timelineConverter.hasOwnProperty('getExpectedLiveEdge') || !streamProcessor || !streamProcessor.hasOwnProperty('getCurrentRepresentationInfo')) { throw new Error('Missing config parameter(s)'); } } function getLiveEdge() { checkConfig(); const representationInfo = streamProcessor.getCurrentRepresentationInfo(); let liveEdge = representationInfo.DVRWindow.end; if (representationInfo.useCalculatedLiveEdgeTime) { liveEdge = timelineConverter.getExpectedLiveEdge(); timelineConverter.setClientTimeOffset(liveEdge - representationInfo.DVRWindow.end); } return liveEdge; } function reset() { timelineConverter = null; streamProcessor = null; } instance = { getLiveEdge: getLiveEdge, reset: reset }; return instance; } LiveEdgeFinder.__dashjs_factory_name = 'LiveEdgeFinder'; export default FactoryMaker.getClassFactory(LiveEdgeFinder); × Search results Close "},"core_Logger.js.html":{"id":"core_Logger.js.html","title":"Source: core/Logger.js","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Source: core/Logger.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ /** * The an end place to put fragments after they have been fetched. * @interface Logger */ /** * This method allows you to send fatal error messages (fatal errors implies playback interruption) to the browser's console. * @param {...*} arguments The message you want to debug. The Arguments object is supported for this method so you can send in comma separated logging items. * @function Logger#fatal */ /** * This method allows you to send error messages to the browser's console. * @param {...*} arguments The message you want to debug. The Arguments object is supported for this method so you can send in comma separated logging items. * @function Logger#error */ /** * This method allows you to send warning messages to the browser's console. * @param {...*} arguments The message you want to debug. The Arguments object is supported for this method so you can send in comma separated logging items. * @function Logger#warning */ /** * This method allows you to send info messages to the browser's console. * @param {...*} arguments The message you want to debug. The Arguments object is supported for this method so you can send in comma separated logging items. * @function Logger#info */ /** * This method allows you to send debug messages to the browser's console. * @param {...*} arguments The message you want to debug. The Arguments object is supported for this method so you can send in comma separated logging items. * @function Logger#debug */ × Search results Close "},"streaming_vo_metrics_ManifestUpdate.js.html":{"id":"streaming_vo_metrics_ManifestUpdate.js.html","title":"Source: streaming/vo/metrics/ManifestUpdate.js","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Source: streaming/vo/metrics/ManifestUpdate.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ /** * @classdesc This Object holds reference to the manifest update information. */ class ManifestUpdate { /** * @class */ constructor() { /** * Media Type Video | Audio | FragmentedText * @public */ this.mediaType = null; /** * MPD Type static | dynamic * @public */ this.type = null; /** * When this manifest update was requested * @public */ this.requestTime = null; /** * When this manifest update was received * @public */ this.fetchTime = null; /** * Calculated Availability Start time of the stream. * @public */ this.availabilityStartTime = null; /** * the seek point (liveEdge for dynamic, Stream[0].startTime for static) * @public */ this.presentationStartTime = 0; /** * The calculated difference between the server and client wall clock time * @public */ this.clientTimeOffset = 0; /** * Actual element.currentTime * @public */ this.currentTime = null; /** * Actual element.ranges * @public */ this.buffered = null; /** * Static is fixed value of zero. dynamic should be ((Now-@availabilityStartTime) - elementCurrentTime) * @public */ this.latency = 0; /** * Array holding list of StreamInfo VO Objects * @public */ this.streamInfo = []; /** * Array holding list of RepresentationInfo VO Objects * @public */ this.representationInfo = []; } } /** * @classdesc This Object holds reference to the current period's stream information when the manifest was updated. */ class ManifestUpdateStreamInfo { /** * @class */ constructor() { /** * Stream@id * @public */ this.id = null; /** * Period Index * @public */ this.index = null; /** * Stream@start * @public */ this.start = null; /** * Stream@duration * @public */ this.duration = null; } } /** * @classdesc This Object holds reference to the current representation's info when the manifest was updated. */ class ManifestUpdateRepresentationInfo { /** * @class */ constructor() { /** * Track@id * @public */ this.id = null; /** * Representation Index * @public */ this.index = null; /** * Media Type Video | Audio | FragmentedText * @public */ this.mediaType = null; /** * Which representation * @public */ this.streamIndex = null; /** * Holds reference to @presentationTimeOffset * @public */ this.presentationTimeOffset = null; /** * Holds reference to @startNumber * @public */ this.startNumber = null; /** * list|template|timeline * @public */ this.fragmentInfoType = null; } } export { ManifestUpdate, ManifestUpdateStreamInfo, ManifestUpdateRepresentationInfo }; × Search results Close "},"streaming_controllers_MediaController.js.html":{"id":"streaming_controllers_MediaController.js.html","title":"Source: streaming/controllers/MediaController.js","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Source: streaming/controllers/MediaController.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ import Constants from '../constants/Constants'; import Events from '../../core/events/Events'; import EventBus from '../../core/EventBus'; import FactoryMaker from '../../core/FactoryMaker'; import Debug from '../../core/Debug'; const TRACK_SWITCH_MODE_NEVER_REPLACE = 'neverReplace'; const TRACK_SWITCH_MODE_ALWAYS_REPLACE = 'alwaysReplace'; const TRACK_SELECTION_MODE_HIGHEST_BITRATE = 'highestBitrate'; const TRACK_SELECTION_MODE_WIDEST_RANGE = 'widestRange'; const DEFAULT_INIT_TRACK_SELECTION_MODE = TRACK_SELECTION_MODE_HIGHEST_BITRATE; function MediaController() { const context = this.context; const eventBus = EventBus(context).getInstance(); let instance, logger, tracks, initialSettings, selectionMode, switchMode, errHandler, domStorage; const validTrackSwitchModes = [ TRACK_SWITCH_MODE_ALWAYS_REPLACE, TRACK_SWITCH_MODE_NEVER_REPLACE ]; const validTrackSelectionModes = [ TRACK_SELECTION_MODE_HIGHEST_BITRATE, TRACK_SELECTION_MODE_WIDEST_RANGE ]; function setup() { logger = Debug(context).getInstance().getLogger(instance); reset(); } /** * @param {string} type * @param {StreamInfo} streamInfo * @memberof MediaController# */ function checkInitialMediaSettingsForType(type, streamInfo) { let settings = getInitialSettings(type); const tracksForType = getTracksFor(type, streamInfo); const tracks = []; if (type === Constants.FRAGMENTED_TEXT) { // Choose the first track setTrack(tracksForType[0]); return; } if (!settings) { settings = domStorage.getSavedMediaSettings(type); setInitialSettings(type, settings); } if (!tracksForType || (tracksForType.length === 0)) return; if (settings) { tracksForType.forEach(function (track) { if (matchSettings(settings, track)) { tracks.push(track); } }); } if (tracks.length === 0) { setTrack(selectInitialTrack(tracksForType)); } else { if (tracks.length &gt; 1) { setTrack(selectInitialTrack(tracks)); } else { setTrack(tracks[0]); } } } /** * @param {MediaInfo} track * @memberof MediaController# */ function addTrack(track) { if (!track) return; const mediaType = track.type; if (!isMultiTrackSupportedByType(mediaType)) return; let streamId = track.streamInfo.id; if (!tracks[streamId]) { tracks[streamId] = createTrackInfo(); } const mediaTracks = tracks[streamId][mediaType].list; for (let i = 0, len = mediaTracks.length; i &lt; len; ++i) { //track is already set. if (isTracksEqual(mediaTracks[i], track)) { return; } } mediaTracks.push(track); let initSettings = getInitialSettings(mediaType); if (initSettings &amp;&amp; (matchSettings(initSettings, track)) &amp;&amp; !getCurrentTrackFor(mediaType, track.streamInfo)) { setTrack(track); } } /** * @param {string} type * @param {StreamInfo} streamInfo * @returns {Array} * @memberof MediaController# */ function getTracksFor(type, streamInfo) { if (!type || !streamInfo) return []; const id = streamInfo.id; if (!tracks[id] || !tracks[id][type]) return []; return tracks[id][type].list; } /** * @param {string} type * @param {StreamInfo} streamInfo * @returns {Object|null} * @memberof MediaController# */ function getCurrentTrackFor(type, streamInfo) { if (!type || !streamInfo || (streamInfo &amp;&amp; !tracks[streamInfo.id])) return null; return tracks[streamInfo.id][type].current; } /** * @param {MediaInfo} track * @returns {boolean} * @memberof MediaController# */ function isCurrentTrack(track) { const type = track.type; const id = track.streamInfo.id; return (tracks[id] &amp;&amp; tracks[id][type] &amp;&amp; isTracksEqual(tracks[id][type].current, track)); } /** * @param {MediaInfo} track * @memberof MediaController# */ function setTrack(track) { if (!track) return; const type = track.type; const streamInfo = track.streamInfo; const id = streamInfo.id; const current = getCurrentTrackFor(type, streamInfo); if (!tracks[id] || !tracks[id][type] || (current &amp;&amp; isTracksEqual(track, current))) return; tracks[id][type].current = track; if (current) { eventBus.trigger(Events.CURRENT_TRACK_CHANGED, {oldMediaInfo: current, newMediaInfo: track, switchMode: switchMode[type]}); } let settings = extractSettings(track); if (!settings || !tracks[id][type].storeLastSettings) return; if (settings.roles) { settings.role = settings.roles[0]; delete settings.roles; } if (settings.accessibility) { settings.accessibility = settings.accessibility[0]; } if (settings.audioChannelConfiguration) { settings.audioChannelConfiguration = settings.audioChannelConfiguration[0]; } domStorage.setSavedMediaSettings(type, settings); } /** * @param {string} type * @param {Object} value * @memberof MediaController# */ function setInitialSettings(type, value) { if (!type || !value) return; initialSettings[type] = value; } /** * @param {string} type * @returns {Object|null} * @memberof MediaController# */ function getInitialSettings(type) { if (!type) return null; return initialSettings[type]; } /** * @param {string} type * @param {string} mode * @memberof MediaController# */ function setSwitchMode(type, mode) { const isModeSupported = (validTrackSwitchModes.indexOf(mode) !== -1); if (!isModeSupported) { logger.warn('Track switch mode is not supported: ' + mode); return; } switchMode[type] = mode; } /** * @param {string} type * @returns {string} mode * @memberof MediaController# */ function getSwitchMode(type) { return switchMode[type]; } /** * @param {string} mode * @memberof MediaController# */ function setSelectionModeForInitialTrack(mode) { const isModeSupported = (validTrackSelectionModes.indexOf(mode) !== -1); if (!isModeSupported) { logger.warn('Track selection mode is not supported: ' + mode); return; } selectionMode = mode; } /** * @returns {string} mode * @memberof MediaController# */ function getSelectionModeForInitialTrack() { return selectionMode || DEFAULT_INIT_TRACK_SELECTION_MODE; } /** * @param {string} type * @returns {boolean} * @memberof MediaController# */ function isMultiTrackSupportedByType(type) { return (type === Constants.AUDIO || type === Constants.VIDEO || type === Constants.TEXT || type === Constants.FRAGMENTED_TEXT || type === Constants.IMAGE); } /** * @param {MediaInfo} t1 - first track to compare * @param {MediaInfo} t2 - second track to compare * @returns {boolean} * @memberof MediaController# */ function isTracksEqual(t1, t2) { const sameId = t1.id === t2.id; const sameViewpoint = t1.viewpoint === t2.viewpoint; const sameLang = t1.lang === t2.lang; const sameRoles = t1.roles.toString() === t2.roles.toString(); const sameAccessibility = t1.accessibility.toString() === t2.accessibility.toString(); const sameAudioChannelConfiguration = t1.audioChannelConfiguration.toString() === t2.audioChannelConfiguration.toString(); return (sameId &amp;&amp; sameViewpoint &amp;&amp; sameLang &amp;&amp; sameRoles &amp;&amp; sameAccessibility &amp;&amp; sameAudioChannelConfiguration); } function setConfig(config) { if (!config) return; if (config.errHandler) { errHandler = config.errHandler; } if (config.domStorage) { domStorage = config.domStorage; } } /** * @memberof MediaController# */ function reset() { tracks = {}; resetInitialSettings(); resetSwitchMode(); } function extractSettings(mediaInfo) { const settings = { lang: mediaInfo.lang, viewpoint: mediaInfo.viewpoint, roles: mediaInfo.roles, accessibility: mediaInfo.accessibility, audioChannelConfiguration: mediaInfo.audioChannelConfiguration }; let notEmpty = settings.lang || settings.viewpoint || (settings.role &amp;&amp; settings.role.length &gt; 0) || (settings.accessibility &amp;&amp; settings.accessibility.length &gt; 0) || (settings.audioChannelConfiguration &amp;&amp; settings.audioChannelConfiguration.length &gt; 0); return notEmpty ? settings : null; } function matchSettings(settings, track) { const matchLang = !settings.lang || (settings.lang === track.lang); const matchViewPoint = !settings.viewpoint || (settings.viewpoint === track.viewpoint); const matchRole = !settings.role || !!track.roles.filter(function (item) { return item === settings.role; })[0]; let matchAccessibility = !settings.accessibility || !!track.accessibility.filter(function (item) { return item === settings.accessibility; })[0]; let matchAudioChannelConfiguration = !settings.audioChannelConfiguration || !!track.audioChannelConfiguration.filter(function (item) { return item === settings.audioChannelConfiguration; })[0]; return (matchLang &amp;&amp; matchViewPoint &amp;&amp; matchRole &amp;&amp; matchAccessibility &amp;&amp; matchAudioChannelConfiguration); } function resetSwitchMode() { switchMode = { audio: TRACK_SWITCH_MODE_ALWAYS_REPLACE, video: TRACK_SWITCH_MODE_NEVER_REPLACE }; } function resetInitialSettings() { initialSettings = { audio: null, video: null }; } function selectInitialTrack(tracks) { let mode = getSelectionModeForInitialTrack(); let tmpArr = []; const getTracksWithHighestBitrate = function (trackArr) { let max = 0; let result = []; let tmp; trackArr.forEach(function (track) { tmp = Math.max.apply(Math, track.bitrateList.map(function (obj) { return obj.bandwidth; })); if (tmp &gt; max) { max = tmp; result = [track]; } else if (tmp === max) { result.push(track); } }); return result; }; const getTracksWithWidestRange = function (trackArr) { let max = 0; let result = []; let tmp; trackArr.forEach(function (track) { tmp = track.representationCount; if (tmp &gt; max) { max = tmp; result = [track]; } else if (tmp === max) { result.push(track); } }); return result; }; switch (mode) { case TRACK_SELECTION_MODE_HIGHEST_BITRATE: tmpArr = getTracksWithHighestBitrate(tracks); if (tmpArr.length &gt; 1) { tmpArr = getTracksWithWidestRange(tmpArr); } break; case TRACK_SELECTION_MODE_WIDEST_RANGE: tmpArr = getTracksWithWidestRange(tracks); if (tmpArr.length &gt; 1) { tmpArr = getTracksWithHighestBitrate(tracks); } break; default: logger.warn('Track selection mode is not supported: ' + mode); break; } return tmpArr[0]; } function createTrackInfo() { return { audio: { list: [], storeLastSettings: true, current: null }, video: { list: [], storeLastSettings: true, current: null }, text: { list: [], storeLastSettings: true, current: null }, fragmentedText: { list: [], storeLastSettings: true, current: null }, image: { list: [], storeLastSettings: true, current: null } }; } instance = { checkInitialMediaSettingsForType: checkInitialMediaSettingsForType, addTrack: addTrack, getTracksFor: getTracksFor, getCurrentTrackFor: getCurrentTrackFor, isCurrentTrack: isCurrentTrack, setTrack: setTrack, setInitialSettings: setInitialSettings, getInitialSettings: getInitialSettings, setSwitchMode: setSwitchMode, getSwitchMode: getSwitchMode, setSelectionModeForInitialTrack: setSelectionModeForInitialTrack, getSelectionModeForInitialTrack: getSelectionModeForInitialTrack, isMultiTrackSupportedByType: isMultiTrackSupportedByType, isTracksEqual: isTracksEqual, setConfig: setConfig, reset: reset }; setup(); return instance; } MediaController.__dashjs_factory_name = 'MediaController'; const factory = FactoryMaker.getSingletonFactory(MediaController); factory.TRACK_SWITCH_MODE_NEVER_REPLACE = TRACK_SWITCH_MODE_NEVER_REPLACE; factory.TRACK_SWITCH_MODE_ALWAYS_REPLACE = TRACK_SWITCH_MODE_ALWAYS_REPLACE; factory.TRACK_SELECTION_MODE_HIGHEST_BITRATE = TRACK_SELECTION_MODE_HIGHEST_BITRATE; factory.TRACK_SELECTION_MODE_WIDEST_RANGE = TRACK_SELECTION_MODE_WIDEST_RANGE; factory.DEFAULT_INIT_TRACK_SELECTION_MODE = DEFAULT_INIT_TRACK_SELECTION_MODE; FactoryMaker.updateSingletonFactory(MediaController.__dashjs_factory_name, factory); export default factory; × Search results Close "},"streaming_MediaPlayerEvents.js.html":{"id":"streaming_MediaPlayerEvents.js.html","title":"Source: streaming/MediaPlayerEvents.js","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Source: streaming/MediaPlayerEvents.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ import EventsBase from '../core/events/EventsBase'; /** * @class * */ class MediaPlayerEvents extends EventsBase { /** * @description Public facing external events to be used when developing a player that implements dash.js. */ constructor() { super(); /** * Triggered when playback will not start yet * as the MPD's availabilityStartTime is in the future. * Check delay property in payload to determine time before playback will start. */ this.AST_IN_FUTURE = 'astInFuture'; /** * Triggered when the video element's buffer state changes to stalled. * Check mediaType in payload to determine type (Video, Audio, FragmentedText). * @event MediaPlayerEvents#BUFFER_EMPTY */ this.BUFFER_EMPTY = 'bufferStalled'; /** * Triggered when the video element's buffer state changes to loaded. * Check mediaType in payload to determine type (Video, Audio, FragmentedText). * @event MediaPlayerEvents#BUFFER_LOADED */ this.BUFFER_LOADED = 'bufferLoaded'; /** * Triggered when the video element's buffer state changes, either stalled or loaded. Check payload for state. * @event MediaPlayerEvents#BUFFER_LEVEL_STATE_CHANGED */ this.BUFFER_LEVEL_STATE_CHANGED = 'bufferStateChanged'; /** * Triggered when there is an error from the element or MSE source buffer. * @event MediaPlayerEvents#ERROR */ this.ERROR = 'error'; /** * Triggered when a fragment download has completed. * @event MediaPlayerEvents#FRAGMENT_LOADING_COMPLETED */ this.FRAGMENT_LOADING_COMPLETED = 'fragmentLoadingCompleted'; /** * Triggered when a partial fragment download has completed. * @event MediaPlayerEvents#FRAGMENT_LOADING_PROGRESS */ this.FRAGMENT_LOADING_PROGRESS = 'fragmentLoadingProgress'; /** * Triggered when a fragment download has started. * @event MediaPlayerEvents#FRAGMENT_LOADING_STARTED */ this.FRAGMENT_LOADING_STARTED = 'fragmentLoadingStarted'; /** * Triggered when a fragment download is abandoned due to detection of slow download base on the ABR abandon rule.. * @event MediaPlayerEvents#FRAGMENT_LOADING_ABANDONED */ this.FRAGMENT_LOADING_ABANDONED = 'fragmentLoadingAbandoned'; /** * Triggered when {@link module:Debug} logger methods are called. * @event MediaPlayerEvents#LOG * @deprecated */ this.LOG = 'log'; //TODO refactor with internal event /** * Triggered when the manifest load is complete * @event MediaPlayerEvents#MANIFEST_LOADED */ this.MANIFEST_LOADED = 'manifestLoaded'; /** * Triggered anytime there is a change to the overall metrics. * @event MediaPlayerEvents#METRICS_CHANGED */ this.METRICS_CHANGED = 'metricsChanged'; /** * Triggered when an individual metric is added, updated or cleared. * @event MediaPlayerEvents#METRIC_CHANGED */ this.METRIC_CHANGED = 'metricChanged'; /** * Triggered every time a new metric is added. * @event MediaPlayerEvents#METRIC_ADDED */ this.METRIC_ADDED = 'metricAdded'; /** * Triggered every time a metric is updated. * @event MediaPlayerEvents#METRIC_UPDATED */ this.METRIC_UPDATED = 'metricUpdated'; /** * Triggered at the stream end of a period. * @event MediaPlayerEvents#PERIOD_SWITCH_COMPLETED */ this.PERIOD_SWITCH_COMPLETED = 'periodSwitchCompleted'; /** * Triggered when a new period starts. * @event MediaPlayerEvents#PERIOD_SWITCH_STARTED */ this.PERIOD_SWITCH_STARTED = 'periodSwitchStarted'; /** * Triggered when an ABR up /down switch is initiated; either by user in manual mode or auto mode via ABR rules. * @event MediaPlayerEvents#QUALITY_CHANGE_REQUESTED */ this.QUALITY_CHANGE_REQUESTED = 'qualityChangeRequested'; /** * Triggered when the new ABR quality is being rendered on-screen. * @event MediaPlayerEvents#QUALITY_CHANGE_RENDERED */ this.QUALITY_CHANGE_RENDERED = 'qualityChangeRendered'; /** * Triggered when the new track is being rendered. * @event MediaPlayerEvents#TRACK_CHANGE_RENDERED */ this.TRACK_CHANGE_RENDERED = 'trackChangeRendered'; /** * Triggered when the source is setup and ready. * @event MediaPlayerEvents#SOURCE_INITIALIZED */ this.SOURCE_INITIALIZED = 'sourceInitialized'; /** * Triggered when a stream (period) is loaded * @event MediaPlayerEvents#STREAM_INITIALIZED */ this.STREAM_INITIALIZED = 'streamInitialized'; /** * Triggered when the player has been reset. * @event MediaPlayerEvents#STREAM_TEARDOWN_COMPLETE */ this.STREAM_TEARDOWN_COMPLETE = 'streamTeardownComplete'; /** * Triggered once all text tracks detected in the MPD are added to the video element. * @event MediaPlayerEvents#TEXT_TRACKS_ADDED */ this.TEXT_TRACKS_ADDED = 'allTextTracksAdded'; /** * Triggered when a text track is added to the video element's TextTrackList * @event MediaPlayerEvents#TEXT_TRACK_ADDED */ this.TEXT_TRACK_ADDED = 'textTrackAdded'; /** * Triggered when a ttml chunk is parsed. * @event MediaPlayerEvents#TTML_PARSED */ this.TTML_PARSED = 'ttmlParsed'; /** * Triggered when a ttml chunk has to be parsed. * @event MediaPlayerEvents#TTML_PARSED */ this.TTML_TO_PARSE = 'ttmlToParse'; /** * Sent when enough data is available that the media can be played, * at least for a couple of frames. This corresponds to the * HAVE_ENOUGH_DATA readyState. * @event MediaPlayerEvents#CAN_PLAY */ this.CAN_PLAY = 'canPlay'; /** * Sent when live catch mechanism has been activated, which implies the measured latency of the low latency * stream that is been played has gone beyond the target one. * @see {@link module:MediaPlayer#setCatchUpPlaybackRate setCatchUpPlaybackRate()} * @see {@link module:MediaPlayer#setLiveDelay setLiveDelay()} * @event MediaPlayerEvents#PLAYBACK_CATCHUP_START */ this.PLAYBACK_CATCHUP_START = 'playbackCatchupStart'; /** * Sent live catch up mechanism has been deactivated. * @see {@link module:MediaPlayer#setCatchUpPlaybackRate setCatchUpPlaybackRate()} * @see {@link module:MediaPlayer#setLiveDelay setLiveDelay()} * @event MediaPlayerEvents#PLAYBACK_CATCHUP_END */ this.PLAYBACK_CATCHUP_END = 'playbackCatchupEnd'; /** * Sent when playback completes. * @event MediaPlayerEvents#PLAYBACK_ENDED */ this.PLAYBACK_ENDED = 'playbackEnded'; /** * Sent when an error occurs. The element's error * attribute contains more information. * @event MediaPlayerEvents#PLAYBACK_ERROR */ this.PLAYBACK_ERROR = 'playbackError'; /** * Sent when playback is not allowed (for example if user gesture is needed). * @event MediaPlayerEvents#PLAYBACK_NOT_ALLOWED */ this.PLAYBACK_NOT_ALLOWED = 'playbackNotAllowed'; /** * The media's metadata has finished loading; all attributes now * contain as much useful information as they're going to. * @event MediaPlayerEvents#PLAYBACK_METADATA_LOADED */ this.PLAYBACK_METADATA_LOADED = 'playbackMetaDataLoaded'; /** * Sent when playback is paused. * @event MediaPlayerEvents#PLAYBACK_PAUSED */ this.PLAYBACK_PAUSED = 'playbackPaused'; /** * Sent when the media begins to play (either for the first time, after having been paused, * or after ending and then restarting). * * @event MediaPlayerEvents#PLAYBACK_PLAYING */ this.PLAYBACK_PLAYING = 'playbackPlaying'; /** * Sent periodically to inform interested parties of progress downloading * the media. Information about the current amount of the media that has * been downloaded is available in the media element's buffered attribute. * @event MediaPlayerEvents#PLAYBACK_PROGRESS */ this.PLAYBACK_PROGRESS = 'playbackProgress'; /** * Sent when the playback speed changes. * @event MediaPlayerEvents#PLAYBACK_RATE_CHANGED */ this.PLAYBACK_RATE_CHANGED = 'playbackRateChanged'; /** * Sent when a seek operation completes. * @event MediaPlayerEvents#PLAYBACK_SEEKED */ this.PLAYBACK_SEEKED = 'playbackSeeked'; /** * Sent when a seek operation begins. * @event MediaPlayerEvents#PLAYBACK_SEEKING */ this.PLAYBACK_SEEKING = 'playbackSeeking'; /** * Sent when a seek operation has been asked. * @event MediaPlayerEvents#PLAYBACK_SEEK_ASKED */ this.PLAYBACK_SEEK_ASKED = 'playbackSeekAsked'; /** * Sent when playback of the media starts after having been paused; * that is, when playback is resumed after a prior pause event. * * @event MediaPlayerEvents#PLAYBACK_STARTED */ this.PLAYBACK_STARTED = 'playbackStarted'; /** * The time indicated by the element's currentTime attribute has changed. * @event MediaPlayerEvents#PLAYBACK_TIME_UPDATED */ this.PLAYBACK_TIME_UPDATED = 'playbackTimeUpdated'; /** * Sent when the media playback has stopped because of a temporary lack of data. * * @event MediaPlayerEvents#PLAYBACK_WAITING */ this.PLAYBACK_WAITING = 'playbackWaiting'; /** * Manifest validity changed - As a result of an MPD validity expiration event. * @event MediaPlayerEvents#MANIFEST_VALIDITY_CHANGED */ this.MANIFEST_VALIDITY_CHANGED = 'manifestValidityChanged'; } } let mediaPlayerEvents = new MediaPlayerEvents(); export default mediaPlayerEvents; × Search results Close "},"streaming_MediaPlayerFactory.js.html":{"id":"streaming_MediaPlayerFactory.js.html","title":"Source: streaming/MediaPlayerFactory.js","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Source: streaming/MediaPlayerFactory.js import MediaPlayer from './MediaPlayer'; function MediaPlayerFactory() { /** * mime-type identifier for any source content to be accepted as a dash manifest by the create() method. * @type {string} */ const SUPPORTED_MIME_TYPE = 'application/dash+xml'; let logger; /** * A new MediaPlayer is instantiated for the supplied videoElement and optional source and context. If no context is provided, * a default DashContext is used. If no source is provided, the videoElement is interrogated to extract the first source whose * type is application/dash+xml. * The autoplay property of the videoElement is preserved. Any preload attribute is ignored. This method should be called after the page onLoad event is dispatched. * @param {HTMLMediaElement} video * @param {HTMLSourceElement} source * @param {Object} context * @returns {MediaPlayer|null} */ function create(video, source, context) { if (!video || !(/^VIDEO$/i).test(video.nodeName)) return null; if (video._dashjs_player) return video._dashjs_player; let player; let videoID = (video.id || video.name || 'video element'); source = source || [].slice.call(video.querySelectorAll('source')).filter(function (s) { return s.type == SUPPORTED_MIME_TYPE; })[0]; if (!source &amp;&amp; video.src) { source = document.createElement('source'); source.src = video.src; } else if (!source &amp;&amp; !video.src) { return null; } context = context || {}; player = MediaPlayer(context).create(); player.initialize(video, source.src, video.autoplay); if (!logger) { logger = player.getDebug().getLogger(); } logger.debug('Converted ' + videoID + ' to dash.js player and added content: ' + source.src); // Store a reference to the player on the video element so it can be gotten at for debugging and so we know its // already been setup. video._dashjs_player = player; return player; } /** * Searches the provided scope for all instances of the indicated selector. If no scope is provided, document is used. If no selector is * specified, [data-dashjs-player] is used. The declarative setup also looks for source elements with the type attribute set to 'application/dash+xml'. * It then looks for those video elements which have a source element defined with a type matching 'application/dash+xml'. * A new MediaPlayer is instantiated for each matching video element and the appropriate source is assigned. * The autoplay property of the video element is preserved. Any preload attribute is ignored. This method should be called after the page onLoad event is dispatched. * Returns an array holding all the MediaPlayer instances that were added by this method. * @param {string} selector - CSS selector * @param {Object} scope * @returns {Array} an array of MediaPlayer objects */ function createAll(selector, scope) { let aPlayers = []; selector = selector || '[data-dashjs-player]'; scope = scope || document; let videos = scope.querySelectorAll(selector); for (let i = 0; i &lt; videos.length; i++) { let player = create(videos[i], null); aPlayers.push(player); } let sources = scope.querySelectorAll('source[type=&quot;' + SUPPORTED_MIME_TYPE + '&quot;]'); for (let i = 0; i &lt; sources.length; i++) { let video = findVideo(sources[i]); let player = create(video, null); aPlayers.push(player); } return aPlayers; } function findVideo(el) { if ((/^VIDEO$/i).test(el.nodeName)) { return el; } else { return findVideo(el.parentNode); } } return { create: create, createAll: createAll }; } let instance = MediaPlayerFactory(); let loadInterval; function loadHandler() { window.removeEventListener('load', loadHandler); instance.createAll(); } function loadIntervalHandler() { if (window.dashjs) { window.clearInterval(loadInterval); instance.createAll(); } } let avoidAutoCreate = typeof window !== 'undefined' &amp;&amp; window &amp;&amp; window.dashjs &amp;&amp; window.dashjs.skipAutoCreate; if (!avoidAutoCreate &amp;&amp; typeof window !== 'undefined' &amp;&amp; window &amp;&amp; window.addEventListener) { if (window.document.readyState === 'complete') { if (window.dashjs) { instance.createAll(); } else { // If loaded asynchronously, window.readyState may be 'complete' even if dashjs hasn't loaded yet loadInterval = window.setInterval(loadIntervalHandler, 500); } } else { window.addEventListener('load', loadHandler); } } export default instance; × Search results Close "},"streaming_metrics_utils_MetricSerialiser.js.html":{"id":"streaming_metrics_utils_MetricSerialiser.js.html","title":"Source: streaming/metrics/utils/MetricSerialiser.js","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Source: streaming/metrics/utils/MetricSerialiser.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ function MetricSerialiser() { // For each entry in the top level list within the metric (in the case // of the DVBErrors metric each entry corresponds to an &quot;error event&quot; // described in clause 10.8.4) the Player shall: function serialise(metric) { let pairs = []; let obj = []; let key, value; // Take each (key, value) pair from the metric entry and create a // string consisting of the name of the key, followed by an equals // ('=') character, followed by the string representation of the // value. The string representation of the value is created based // on the type of the value following the instructions in Table 22. for (key in metric) { if (metric.hasOwnProperty(key) &amp;&amp; (key.indexOf('_') !== 0)) { value = metric[key]; // we want to ensure that keys still end up in the report // even if there is no value if ((value === undefined) || (value === null)) { value = ''; } // DVB A168 10.12.4 Table 22 if (Array.isArray(value)) { // if trace or similar is null, do not include in output if (!value.length) { continue; } obj = []; value.forEach(function (v) { let isBuiltIn = Object.prototype.toString.call(v).slice(8, -1) !== 'Object'; obj.push(isBuiltIn ? v : serialise(v)); }); value = obj.map(encodeURIComponent).join(','); } else if (typeof value === 'string') { value = encodeURIComponent(value); } else if (value instanceof Date) { value = value.toISOString(); } else if (typeof value === 'number') { value = Math.round(value); } pairs.push(key + '=' + value); } } // Concatenate the strings created in the previous step with an // ampersand ('&amp;') character between each one. return pairs.join('&amp;'); } return { serialise: serialise }; } MetricSerialiser.__dashjs_factory_name = 'MetricSerialiser'; export default dashjs.FactoryMaker.getSingletonFactory(MetricSerialiser); /* jshint ignore:line */ × Search results Close "},"streaming_metrics_MetricsReporting.js.html":{"id":"streaming_metrics_MetricsReporting.js.html","title":"Source: streaming/metrics/MetricsReporting.js","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Source: streaming/metrics/MetricsReporting.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ import DVBErrorsTranslator from './utils/DVBErrorsTranslator'; import MetricsReportingEvents from './MetricsReportingEvents'; import MetricsCollectionController from './controllers/MetricsCollectionController'; import MetricsHandlerFactory from './metrics/MetricsHandlerFactory'; import ReportingFactory from './reporting/ReportingFactory'; function MetricsReporting() { let context = this.context; let instance; let dvbErrorsTranslator; /** * Create a MetricsCollectionController, and a DVBErrorsTranslator * @param {Object} config - dependancies from owner * @return {MetricsCollectionController} Metrics Collection Controller */ function createMetricsReporting(config) { dvbErrorsTranslator = DVBErrorsTranslator(context).getInstance({ eventBus: config.eventBus, metricsModel: config.metricsModel, metricsConstants: config.metricsConstants, events: config.events }); return MetricsCollectionController(context).create(config); } /** * Get the ReportingFactory to allow new reporters to be registered * @return {ReportingFactory} Reporting Factory */ function getReportingFactory() { return ReportingFactory(context).getInstance(); } /** * Get the MetricsHandlerFactory to allow new handlers to be registered * @return {MetricsHandlerFactory} Metrics Handler Factory */ function getMetricsHandlerFactory() { return MetricsHandlerFactory(context).getInstance(); } instance = { createMetricsReporting: createMetricsReporting, getReportingFactory: getReportingFactory, getMetricsHandlerFactory: getMetricsHandlerFactory }; return instance; } MetricsReporting.__dashjs_factory_name = 'MetricsReporting'; const factory = dashjs.FactoryMaker.getClassFactory(MetricsReporting); /* jshint ignore:line */ factory.events = MetricsReportingEvents; dashjs.FactoryMaker.updateClassFactory(MetricsReporting.__dashjs_factory_name, factory); /* jshint ignore:line */ export default factory; × Search results Close "},"dash_DashMetrics.js.html":{"id":"dash_DashMetrics.js.html","title":"Source: dash/DashMetrics.js","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Source: dash/DashMetrics.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ import {HTTPRequest} from '../streaming/vo/metrics/HTTPRequest'; import FactoryMaker from '../core/FactoryMaker'; import MetricsConstants from '../streaming/constants/MetricsConstants'; import Round10 from './utils/Round10'; /** * @module DashMetrics * @param {object} config configuration passed to DashMetrics */ function DashMetrics(config) { config = config || {}; let instance; let dashManifestModel = config.dashManifestModel; let manifestModel = config.manifestModel; function getBandwidthForRepresentation(representationId, periodId) { let representation; const manifest = manifestModel.getValue(); let period = manifest.Period_asArray[periodId]; representation = findRepresentation(period, representationId); if (representation === null) { return null; } return representation.bandwidth; } /** * * @param {string} representationId * @param {number} periodIdx * @returns {*} */ function getIndexForRepresentation(representationId, periodIdx) { let representationIndex; const manifest = manifestModel.getValue(); let period = manifest.Period_asArray[periodIdx]; representationIndex = findRepresentationIndex(period, representationId); return representationIndex; } /** * This method returns the current max index based on what is defined in the MPD. * * @param {string} bufferType - String 'audio' or 'video', * @param {number} periodIdx - Make sure this is the period index not id * @return {number} * @memberof module:DashMetrics * @instance */ function getMaxIndexForBufferType(bufferType, periodIdx) { let maxIndex; const manifest = manifestModel.getValue(); if (!manifest) { return -1; } let period = manifest.Period_asArray[periodIdx]; maxIndex = findMaxBufferIndex(period, bufferType); return maxIndex; } /** * @param {MetricsList} metrics * @returns {*} * @memberof module:DashMetrics * @instance */ function getCurrentRepresentationSwitch(metrics) { return getCurrent(metrics, MetricsConstants.TRACK_SWITCH); } /** * @param {MetricsList} metrics * @returns {*} * @memberof module:DashMetrics * @instance */ function getLatestBufferLevelVO(metrics) { return getCurrent(metrics, MetricsConstants.BUFFER_LEVEL); } /** * @param {MetricsList} metrics * @returns {number} * @memberof module:DashMetrics * @instance */ function getCurrentBufferLevel(metrics) { const vo = getLatestBufferLevelVO(metrics); if (vo) { return Round10.round10(vo.level / 1000, -3); } return 0; } /** * @param {MetricsList} metrics * @returns {null|*|vo} * @memberof module:DashMetrics * @instance */ function getRequestsQueue(metrics) { return metrics ? metrics.RequestsQueue : null; } /** * @param {MetricsList} metrics * @returns {*} * @memberof module:DashMetrics * @instance */ function getCurrentHttpRequest(metrics) { if (!metrics) { return null; } const httpList = metrics.HttpList; let currentHttpList = null; let httpListLength, httpListLastIndex; if (!httpList || httpList.length &lt;= 0) { return null; } httpListLength = httpList.length; httpListLastIndex = httpListLength - 1; while (httpListLastIndex &gt;= 0) { if (httpList[httpListLastIndex].responsecode) { currentHttpList = httpList[httpListLastIndex]; break; } httpListLastIndex--; } return currentHttpList; } /** * @param {MetricsList} metrics * @returns {*} * @memberof module:DashMetrics * @instance */ function getHttpRequests(metrics) { if (!metrics) { return []; } return !!metrics.HttpList ? metrics.HttpList : []; } /** * @param {MetricsList} metrics * @param {string} metricName * @returns {*} * @memberof module:DashMetrics * @instance */ function getCurrent(metrics, metricName) { if (!metrics) { return null; } const list = metrics[metricName]; if (!list) { return null; } const length = list.length; if (length &lt;= 0) { return null; } return list[length - 1]; } /** * @param {MetricsList} metrics * @returns {*} * @memberof module:DashMetrics * @instance */ function getCurrentDroppedFrames(metrics) { return getCurrent(metrics, MetricsConstants.DROPPED_FRAMES); } /** * @param {MetricsList} metrics * @returns {*} * @memberof module:DashMetrics * @instance */ function getCurrentSchedulingInfo(metrics) { return getCurrent(metrics, MetricsConstants.SCHEDULING_INFO); } /** * @param {MetricsList} metrics * @returns {*} * @memberof module:DashMetrics * @instance */ function getCurrentManifestUpdate(metrics) { return getCurrent(metrics, MetricsConstants.MANIFEST_UPDATE); } /** * @param {MetricsList} metrics * @returns {*} * @memberof module:DashMetrics * @instance */ function getCurrentDVRInfo(metrics) { return getCurrent(metrics, MetricsConstants.DVR_INFO); } /** * @param {MetricsList} metrics * @param {string} id * @returns {*} * @memberof module:DashMetrics * @instance */ function getLatestMPDRequestHeaderValueByID(metrics, id) { let headers = {}; let httpRequestList, httpRequest, i; httpRequestList = getHttpRequests(metrics); for (i = httpRequestList.length - 1; i &gt;= 0; i--) { httpRequest = httpRequestList[i]; if (httpRequest.type === HTTPRequest.MPD_TYPE) { headers = parseResponseHeaders(httpRequest._responseHeaders); break; } } return headers[id] === undefined ? null : headers[id]; } /** * @param {MetricsList} metrics * @param {string} id * @returns {*} * @memberof module:DashMetrics * @instance */ function getLatestFragmentRequestHeaderValueByID(metrics, id) { let headers = {}; let httpRequest = getCurrentHttpRequest(metrics); if (httpRequest) { headers = parseResponseHeaders(httpRequest._responseHeaders); } return headers[id] === undefined ? null : headers[id]; } function parseResponseHeaders(headerStr) { let headers = {}; if (!headerStr) { return headers; } // Trim headerStr to fix a MS Edge bug with xhr.getAllResponseHeaders method // which send a string starting with a &quot;\\n&quot; character let headerPairs = headerStr.trim().split('\\u000d\\u000a'); for (let i = 0, ilen = headerPairs.length; i &lt; ilen; i++) { let headerPair = headerPairs[i]; let index = headerPair.indexOf('\\u003a\\u0020'); if (index &gt; 0) { headers[headerPair.substring(0, index)] = headerPair.substring(index + 2); } } return headers; } function findRepresentationIndex(period, representationId) { const index = findRepresentation(period, representationId, true); if (index !== null) { return index; } return -1; } function findRepresentation(period, representationId, returnIndex) { let adaptationSet, adaptationSetArray, representation, representationArray, adaptationSetArrayIndex, representationArrayIndex; if (period) { adaptationSetArray = period.AdaptationSet_asArray; for (adaptationSetArrayIndex = 0; adaptationSetArrayIndex &lt; adaptationSetArray.length; adaptationSetArrayIndex = adaptationSetArrayIndex + 1) { adaptationSet = adaptationSetArray[adaptationSetArrayIndex]; representationArray = adaptationSet.Representation_asArray; for (representationArrayIndex = 0; representationArrayIndex &lt; representationArray.length; representationArrayIndex = representationArrayIndex + 1) { representation = representationArray[representationArrayIndex]; if (representationId === representation.id) { if (returnIndex) { return representationArrayIndex; } else { return representation; } } } } } return null; } function adaptationIsType(adaptation, bufferType) { return dashManifestModel.getIsTypeOf(adaptation, bufferType); } function findMaxBufferIndex(period, bufferType) { let adaptationSet, adaptationSetArray, representationArray, adaptationSetArrayIndex; if (!period || !bufferType) return -1; adaptationSetArray = period.AdaptationSet_asArray; for (adaptationSetArrayIndex = 0; adaptationSetArrayIndex &lt; adaptationSetArray.length; adaptationSetArrayIndex = adaptationSetArrayIndex + 1) { adaptationSet = adaptationSetArray[adaptationSetArrayIndex]; representationArray = adaptationSet.Representation_asArray; if (adaptationIsType(adaptationSet, bufferType)) { return representationArray.length; } } return -1; } instance = { getBandwidthForRepresentation: getBandwidthForRepresentation, getIndexForRepresentation: getIndexForRepresentation, getMaxIndexForBufferType: getMaxIndexForBufferType, getCurrentRepresentationSwitch: getCurrentRepresentationSwitch, getLatestBufferLevelVO: getLatestBufferLevelVO, getCurrentBufferLevel: getCurrentBufferLevel, getCurrentHttpRequest: getCurrentHttpRequest, getHttpRequests: getHttpRequests, getCurrentDroppedFrames: getCurrentDroppedFrames, getCurrentSchedulingInfo: getCurrentSchedulingInfo, getCurrentDVRInfo: getCurrentDVRInfo, getCurrentManifestUpdate: getCurrentManifestUpdate, getLatestFragmentRequestHeaderValueByID: getLatestFragmentRequestHeaderValueByID, getLatestMPDRequestHeaderValueByID: getLatestMPDRequestHeaderValueByID, getRequestsQueue: getRequestsQueue }; return instance; } DashMetrics.__dashjs_factory_name = 'DashMetrics'; export default FactoryMaker.getSingletonFactory(DashMetrics); × Search results Close "},"core_Debug.js.html":{"id":"core_Debug.js.html","title":"Source: core/Debug.js","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Source: core/Debug.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ import EventBus from './EventBus'; import Events from './events/Events'; import FactoryMaker from './FactoryMaker'; const LOG_LEVEL_NONE = 0; const LOG_LEVEL_FATAL = 1; const LOG_LEVEL_ERROR = 2; const LOG_LEVEL_WARNING = 3; const LOG_LEVEL_INFO = 4; const LOG_LEVEL_DEBUG = 5; /** * @module Debug */ function Debug() { const context = this.context; const eventBus = EventBus(context).getInstance(); const logFn = []; let instance, showLogTimestamp, showCalleeName, startTime, logLevel; function setup() { showLogTimestamp = true; showCalleeName = true; logLevel = LOG_LEVEL_WARNING; startTime = new Date().getTime(); if (typeof window !== 'undefined' &amp;&amp; window.console) { logFn[LOG_LEVEL_FATAL] = getLogFn(window.console.error); logFn[LOG_LEVEL_ERROR] = getLogFn(window.console.error); logFn[LOG_LEVEL_WARNING] = getLogFn(window.console.warn); logFn[LOG_LEVEL_INFO] = getLogFn(window.console.info); logFn[LOG_LEVEL_DEBUG] = getLogFn(window.console.debug); } } function getLogFn(fn) { if (fn &amp;&amp; fn.bind) { return fn.bind(window.console); } // if not define, return the default function for reporting logs return window.console.log.bind(window.console); } /** * Retrieves a logger which can be used to write logging information in browser console. * @param {object} instance Object for which the logger is created. It is used * to include calle object information in log messages. * @memberof module:Debug * @returns {Logger} * @instance */ function getLogger(instance) { return { fatal: fatal.bind(instance), error: error.bind(instance), warn: warn.bind(instance), info: info.bind(instance), debug: debug.bind(instance) }; } /** * Sets up the log level. The levels are cumulative. For example, if you set the log level * to dashjs.Debug.LOG_LEVEL_WARNING all warnings, errors and fatals will be logged. Possible values * * &lt;ul&gt; * &lt;li&gt;dashjs.Debug.LOG_LEVEL_NONE&lt;br/&gt; * No message is written in the browser console. * * &lt;li&gt;dashjs.Debug.LOG_LEVEL_FATAL&lt;br/&gt; * Log fatal errors. An error is considered fatal when it causes playback to fail completely. * * &lt;li&gt;dashjs.Debug.LOG_LEVEL_ERROR&lt;br/&gt; * Log error messages. * * &lt;li&gt;dashjs.Debug.LOG_LEVEL_WARNING&lt;br/&gt; * Log warning messages. * * &lt;li&gt;dashjs.Debug.LOG_LEVEL_INFO&lt;br/&gt; * Log info messages. * * &lt;li&gt;dashjs.Debug.LOG_LEVEL_DEBUG&lt;br/&gt; * Log debug messages. * &lt;/ul&gt; * @param {number} value Log level * @default true * @memberof module:Debug * @instance */ function setLogLevel(value) { logLevel = value; } /** * Use this method to get the current log level. * @memberof module:Debug * @instance */ function getLogLevel() { return logLevel; } /** * Prepends a timestamp in milliseconds to each log message. * @param {boolean} value Set to true if you want to see a timestamp in each log message. * @default LOG_LEVEL_WARNING * @memberof module:Debug * @instance */ function setLogTimestampVisible(value) { showLogTimestamp = value; } /** * Prepends the callee object name, and media type if available, to each log message. * @param {boolean} value Set to true if you want to see the callee object name and media type in each log message. * @default true * @memberof module:Debug * @instance */ function setCalleeNameVisible(value) { showCalleeName = value; } /** * Toggles logging to the browser's javascript console. If you set to false you will still receive a log event with the same message. * @param {boolean} value Set to false if you want to turn off logging to the browser's console. * @default true * @memberof module:Debug * @instance * @deprecated */ function setLogToBrowserConsole(value) { // Replicate functionality previous to log levels feature if (value) { logLevel = LOG_LEVEL_DEBUG; } else { logLevel = LOG_LEVEL_NONE; } } /** * Use this method to get the state of logToBrowserConsole. * @returns {boolean} The current value of logToBrowserConsole * @memberof module:Debug * @instance * @deprecated */ function getLogToBrowserConsole() { return logLevel !== LOG_LEVEL_NONE; } function fatal(...params) { doLog(LOG_LEVEL_FATAL, this, ...params); } function error(...params) { doLog(LOG_LEVEL_ERROR, this, ...params); } function warn(...params) { doLog(LOG_LEVEL_WARNING, this, ...params); } function info(...params) { doLog(LOG_LEVEL_INFO, this, ...params); } function debug(...params) { doLog(LOG_LEVEL_DEBUG, this, ...params); } function doLog(level, _this, ...params) { if (logLevel &lt; level) { return; } let message = ''; let logTime = null; if (showLogTimestamp) { logTime = new Date().getTime(); message += '[' + (logTime - startTime) + ']'; } if (showCalleeName &amp;&amp; _this &amp;&amp; _this.getClassName) { message += '[' + _this.getClassName() + ']'; if (_this.getType) { message += '[' + _this.getType() + ']'; } } if (message.length &gt; 0) { message += ' '; } Array.apply(null, params).forEach(function (item) { message += item + ' '; }); if (logFn[level]) { logFn[level](message); } // TODO: To be removed eventBus.trigger(Events.LOG, {message: message}); } instance = { getLogger: getLogger, setLogTimestampVisible: setLogTimestampVisible, setCalleeNameVisible: setCalleeNameVisible, setLogToBrowserConsole: setLogToBrowserConsole, getLogToBrowserConsole: getLogToBrowserConsole, setLogLevel: setLogLevel, getLogLevel: getLogLevel }; setup(); return instance; } Debug.__dashjs_factory_name = 'Debug'; const factory = FactoryMaker.getSingletonFactory(Debug); factory.LOG_LEVEL_NONE = LOG_LEVEL_NONE; factory.LOG_LEVEL_FATAL = LOG_LEVEL_FATAL; factory.LOG_LEVEL_ERROR = LOG_LEVEL_ERROR; factory.LOG_LEVEL_WARNING = LOG_LEVEL_WARNING; factory.LOG_LEVEL_INFO = LOG_LEVEL_INFO; factory.LOG_LEVEL_DEBUG = LOG_LEVEL_DEBUG; FactoryMaker.updateSingletonFactory(Debug.__dashjs_factory_name, factory); export default factory; × Search results Close "},"core_FactoryMaker.js.html":{"id":"core_FactoryMaker.js.html","title":"Source: core/FactoryMaker.js","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Source: core/FactoryMaker.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ /** * @module FactoryMaker */ const FactoryMaker = (function () { let instance; const singletonContexts = []; const singletonFactories = {}; const classFactories = {}; function extend(name, childInstance, override, context) { if (!context[name] &amp;&amp; childInstance) { context[name] = { instance: childInstance, override: override }; } } /** * Use this method from your extended object. this.factory is injected into your object. * this.factory.getSingletonInstance(this.context, 'VideoModel') * will return the video model for use in the extended object. * * @param {Object} context - injected into extended object as this.context * @param {string} className - string name found in all dash.js objects * with name __dashjs_factory_name Will be at the bottom. Will be the same as the object's name. * @returns {*} Context aware instance of specified singleton name. * @memberof module:FactoryMaker * @instance */ function getSingletonInstance(context, className) { for (const i in singletonContexts) { const obj = singletonContexts[i]; if (obj.context === context &amp;&amp; obj.name === className) { return obj.instance; } } return null; } /** * Use this method to add an singleton instance to the system. Useful for unit testing to mock objects etc. * * @param {Object} context * @param {string} className * @param {Object} instance * @memberof module:FactoryMaker * @instance */ function setSingletonInstance(context, className, instance) { for (const i in singletonContexts) { const obj = singletonContexts[i]; if (obj.context === context &amp;&amp; obj.name === className) { singletonContexts[i].instance = instance; return; } } singletonContexts.push({ name: className, context: context, instance: instance }); } /*------------------------------------------------------------------------------------------*/ // Factories storage Management /*------------------------------------------------------------------------------------------*/ function getFactoryByName(name, factoriesArray) { return factoriesArray[name]; } function updateFactory(name, factory, factoriesArray) { if (name in factoriesArray) { factoriesArray[name] = factory; } } /*------------------------------------------------------------------------------------------*/ // Class Factories Management /*------------------------------------------------------------------------------------------*/ function updateClassFactory(name, factory) { updateFactory(name, factory, classFactories); } function getClassFactoryByName(name) { return getFactoryByName(name, classFactories); } function getClassFactory(classConstructor) { let factory = getFactoryByName(classConstructor.__dashjs_factory_name, classFactories); if (!factory) { factory = function (context) { if (context === undefined) { context = {}; } return { create: function () { return merge(classConstructor, context, arguments); } }; }; classFactories[classConstructor.__dashjs_factory_name] = factory; // store factory } return factory; } /*------------------------------------------------------------------------------------------*/ // Singleton Factory MAangement /*------------------------------------------------------------------------------------------*/ function updateSingletonFactory(name, factory) { updateFactory(name, factory, singletonFactories); } function getSingletonFactoryByName(name) { return getFactoryByName(name, singletonFactories); } function getSingletonFactory(classConstructor) { let factory = getFactoryByName(classConstructor.__dashjs_factory_name, singletonFactories); if (!factory) { factory = function (context) { let instance; if (context === undefined) { context = {}; } return { getInstance: function () { // If we don't have an instance yet check for one on the context if (!instance) { instance = getSingletonInstance(context, classConstructor.__dashjs_factory_name); } // If there's no instance on the context then create one if (!instance) { instance = merge(classConstructor, context, arguments); singletonContexts.push({ name: classConstructor.__dashjs_factory_name, context: context, instance: instance }); } return instance; } }; }; singletonFactories[classConstructor.__dashjs_factory_name] = factory; // store factory } return factory; } function merge(classConstructor, context, args) { let classInstance; const className = classConstructor.__dashjs_factory_name; const extensionObject = context[className]; if (extensionObject) { let extension = extensionObject.instance; if (extensionObject.override) { //Override public methods in parent but keep parent. classInstance = classConstructor.apply({context}, args); extension = extension.apply({ context, factory: instance, parent: classInstance }, args); for (const prop in extension) { if (classInstance.hasOwnProperty(prop)) { classInstance[prop] = extension[prop]; } } } else { //replace parent object completely with new object. Same as dijon. return extension.apply({ context, factory: instance }, args); } } else { // Create new instance of the class classInstance = classConstructor.apply({context}, args); } // Add getClassName function to class instance prototype (used by Debug) classInstance.getClassName = function () {return className;}; return classInstance; } instance = { extend: extend, getSingletonInstance: getSingletonInstance, setSingletonInstance: setSingletonInstance, getSingletonFactory: getSingletonFactory, getSingletonFactoryByName: getSingletonFactoryByName, updateSingletonFactory: updateSingletonFactory, getClassFactory: getClassFactory, getClassFactoryByName: getClassFactoryByName, updateClassFactory: updateClassFactory }; return instance; }()); export default FactoryMaker; × Search results Close "},"streaming_net_FetchLoader.js.html":{"id":"streaming_net_FetchLoader.js.html","title":"Source: streaming/net/FetchLoader.js","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Source: streaming/net/FetchLoader.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ import FactoryMaker from '../../core/FactoryMaker'; import BoxParser from '../utils/BoxParser'; /** * @module FetchLoader * @description Manages download of resources via HTTP using fetch. * @param {Object} cfg - dependencies from parent */ function FetchLoader(cfg) { cfg = cfg || {}; const requestModifier = cfg.requestModifier; let instance; function load(httpRequest) { // Variables will be used in the callback functions let firstProgress = true; /*jshint ignore:line*/ let needFailureReport = true; /*jshint ignore:line*/ let requestStartTime = new Date(); let lastTraceTime = requestStartTime; /*jshint ignore:line*/ let lastTraceReceivedCount = 0; /*jshint ignore:line*/ let request = httpRequest.request; const headers = new Headers(); /*jshint ignore:line*/ if (request.range) { headers.append('Range', 'bytes=' + request.range); } if (!request.requestStartDate) { request.requestStartDate = requestStartTime; } if (requestModifier) { // modifyRequestHeader expects a XMLHttpRequest object so, // to keep backward compatibility, we should expose a setRequestHeader method // TODO: Remove RequestModifier dependency on XMLHttpRequest object and define // a more generic way to intercept/modify requests requestModifier.modifyRequestHeader({ setRequestHeader: function (header, value) { headers.append(header, value); } }); } let abortController; if (typeof window.AbortController === 'function') { abortController = new AbortController(); /*jshint ignore:line*/ httpRequest.abortController = abortController; } const reqOptions = { method: httpRequest.method, headers: headers, credentials: httpRequest.withCredentials ? 'include' : undefined, signal: abortController ? abortController.signal : undefined }; fetch(httpRequest.url, reqOptions).then(function (response) { if (!httpRequest.response) { httpRequest.response = {}; } httpRequest.response.status = response.status; httpRequest.response.statusText = response.statusText; httpRequest.response.responseURL = response.url; if (!response.ok) { httpRequest.onerror(); } let responseHeaders = ''; for (const key of response.headers.keys()) { responseHeaders += key + ': ' + response.headers.get(key) + '\\n'; } httpRequest.response.responseHeaders = responseHeaders; if (!response.body) { // Fetch returning a ReadableStream response body is not currently supported by all browsers. // Browser compatibility: https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API // If it is not supported, returning the whole segment when it's ready (as xhr) return response.arrayBuffer().then(function (buffer) { httpRequest.response.response = buffer; const event = { loaded: buffer.byteLength, total: buffer.byteLength }; httpRequest.progress(event); httpRequest.onload(); httpRequest.onend(); return; }); } const totalBytes = parseInt(response.headers.get('Content-Length'), 10); let bytesReceived = 0; let signaledFirstByte = false; let remaining = new Uint8Array(); let offset = 0; httpRequest.reader = response.body.getReader(); const processResult = function ({ value, done }) { if (done) { if (remaining) { // If there is pending data, call progress so network metrics // are correctly generated // Same structure as https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequestEventTarget/onprogress httpRequest.progress({ loaded: bytesReceived, total: isNaN(totalBytes) ? bytesReceived : totalBytes, lengthComputable: true }); httpRequest.response.response = remaining.buffer; } httpRequest.onload(); httpRequest.onend(); return; } if (value &amp;&amp; value.length &gt; 0) { remaining = concatTypedArray(remaining, value); bytesReceived += value.length; const boxesInfo = BoxParser().getInstance().findLastTopIsoBoxCompleted(['moov', 'mdat'], remaining, offset); if (boxesInfo.found) { const end = boxesInfo.lastCompletedOffset + boxesInfo.size; // If we are going to pass full buffer, avoid copying it and pass // complete buffer. Otherwise clone the part of the buffer that is completed // and adjust remaining buffer. A clone is needed because ArrayBuffer of a typed-array // keeps a reference to the original data let data; if (end === remaining.length) { data = remaining; remaining = new Uint8Array(); } else { data = new Uint8Array(remaining.subarray(0, end)); remaining = remaining.subarray(end); } // Announce progress but don't track traces. Throughput measures are quite unstable // when they are based in small amount of data httpRequest.progress({ data: data.buffer, lengthComputable: false, noTrace: true }); offset = 0; } else { offset = boxesInfo.lastCompletedOffset; // Call progress so it generates traces that will be later used to know when the first byte // were received if (!signaledFirstByte) { httpRequest.progress({ lengthComputable: false, noTrace: true }); signaledFirstByte = true; } } } read(httpRequest, processResult); }; read(httpRequest, processResult); }) .catch( function (e) { if (httpRequest.onerror) { httpRequest.onerror(e); } }); } function read(httpRequest, processResult) { httpRequest.reader.read() .then(processResult) .catch(function () { // don't do nothing. Manage this error in fetch method promise }); } function concatTypedArray(remaining, data) { if (remaining.length === 0) { return data; } const result = new Uint8Array(remaining.length + data.length); result.set(remaining); result.set(data, remaining.length); return result; } function abort(request) { if (request.abortController) { // For firefox and edge request.abortController.abort(); } else if (request.reader) { // For Chrome try { request.reader.cancel(); } catch (e) { // throw exceptions (TypeError) when reader was previously closed, // for example, because a network issue } } } instance = { load: load, abort: abort }; return instance; } FetchLoader.__dashjs_factory_name = 'FetchLoader'; const factory = FactoryMaker.getClassFactory(FetchLoader); export default factory; × Search results Close "},"streaming_net_HTTPLoader.js.html":{"id":"streaming_net_HTTPLoader.js.html","title":"Source: streaming/net/HTTPLoader.js","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Source: streaming/net/HTTPLoader.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ import XHRLoader from './XHRLoader'; import FetchLoader from './FetchLoader'; import { HTTPRequest } from '../vo/metrics/HTTPRequest'; import FactoryMaker from '../../core/FactoryMaker'; import ErrorHandler from '../utils/ErrorHandler'; /** * @module HTTPLoader * @description Manages download of resources via HTTP. * @param {Object} cfg - dependancies from parent */ function HTTPLoader(cfg) { cfg = cfg || {}; const context = this.context; const errHandler = cfg.errHandler; const metricsModel = cfg.metricsModel; const mediaPlayerModel = cfg.mediaPlayerModel; const requestModifier = cfg.requestModifier; const useFetch = cfg.useFetch || false; let instance; let requests; let delayedRequests; let retryTimers; let downloadErrorToRequestTypeMap; function setup() { requests = []; delayedRequests = []; retryTimers = []; downloadErrorToRequestTypeMap = { [HTTPRequest.MPD_TYPE]: ErrorHandler.DOWNLOAD_ERROR_ID_MANIFEST, [HTTPRequest.XLINK_EXPANSION_TYPE]: ErrorHandler.DOWNLOAD_ERROR_ID_XLINK, [HTTPRequest.INIT_SEGMENT_TYPE]: ErrorHandler.DOWNLOAD_ERROR_ID_INITIALIZATION, [HTTPRequest.MEDIA_SEGMENT_TYPE]: ErrorHandler.DOWNLOAD_ERROR_ID_CONTENT, [HTTPRequest.INDEX_SEGMENT_TYPE]: ErrorHandler.DOWNLOAD_ERROR_ID_CONTENT, [HTTPRequest.BITSTREAM_SWITCHING_SEGMENT_TYPE]: ErrorHandler.DOWNLOAD_ERROR_ID_CONTENT, [HTTPRequest.OTHER_TYPE]: ErrorHandler.DOWNLOAD_ERROR_ID_CONTENT }; } function internalLoad(config, remainingAttempts) { const request = config.request; const traces = []; let firstProgress = true; let needFailureReport = true; let requestStartTime = new Date(); let lastTraceTime = requestStartTime; let lastTraceReceivedCount = 0; let httpRequest; if (!requestModifier || !metricsModel || !errHandler) { throw new Error('config object is not correct or missing'); } const handleLoaded = function (success) { needFailureReport = false; request.requestStartDate = requestStartTime; request.requestEndDate = new Date(); request.firstByteDate = request.firstByteDate || requestStartTime; if (!request.checkExistenceOnly) { metricsModel.addHttpRequest( request.mediaType, null, request.type, request.url, httpRequest.response ? httpRequest.response.responseURL : null, request.serviceLocation || null, request.range || null, request.requestStartDate, request.firstByteDate, request.requestEndDate, httpRequest.response ? httpRequest.response.status : null, request.duration, httpRequest.response &amp;&amp; httpRequest.response.getAllResponseHeaders ? httpRequest.response.getAllResponseHeaders() : httpRequest.response.responseHeaders, success ? traces : null ); } }; const onloadend = function () { if (requests.indexOf(httpRequest) === -1) { return; } else { requests.splice(requests.indexOf(httpRequest), 1); } if (needFailureReport) { handleLoaded(false); if (remainingAttempts &gt; 0) { remainingAttempts--; retryTimers.push( setTimeout(function () { internalLoad(config, remainingAttempts); }, mediaPlayerModel.getRetryIntervalForType(request.type)) ); } else { errHandler.downloadError( downloadErrorToRequestTypeMap[request.type], request.url, request ); if (config.error) { config.error(request, 'error', httpRequest.response.statusText); } if (config.complete) { config.complete(request, httpRequest.response.statusText); } } } }; const progress = function (event) { const currentTime = new Date(); if (firstProgress) { firstProgress = false; if (!event.lengthComputable || (event.lengthComputable &amp;&amp; event.total !== event.loaded)) { request.firstByteDate = currentTime; } } if (event.lengthComputable) { request.bytesLoaded = event.loaded; request.bytesTotal = event.total; } if (!event.noTrace) { traces.push({ s: lastTraceTime, d: currentTime.getTime() - lastTraceTime.getTime(), b: [event.loaded ? event.loaded - lastTraceReceivedCount : 0] }); lastTraceTime = currentTime; lastTraceReceivedCount = event.loaded; } if (config.progress &amp;&amp; event.data) { config.progress(event.data); } }; const onload = function () { if (httpRequest.response.status &gt;= 200 &amp;&amp; httpRequest.response.status &lt;= 299) { handleLoaded(true); if (config.success) { config.success(httpRequest.response.response, httpRequest.response.statusText, httpRequest.response.responseURL); } if (config.complete) { config.complete(request, httpRequest.response.statusText); } } }; const onabort = function () { if (config.abort) { config.abort(request); } }; let loader; if (useFetch &amp;&amp; window.fetch &amp;&amp; request.responseType === 'arraybuffer') { loader = FetchLoader(context).create({ requestModifier: requestModifier }); } else { loader = XHRLoader(context).create({ requestModifier: requestModifier }); } const modifiedUrl = requestModifier.modifyRequestURL(request.url); const verb = request.checkExistenceOnly ? HTTPRequest.HEAD : HTTPRequest.GET; const withCredentials = mediaPlayerModel.getXHRWithCredentialsForType(request.type); httpRequest = { url: modifiedUrl, method: verb, withCredentials: withCredentials, request: request, onload: onload, onend: onloadend, onerror: onloadend, progress: progress, onabort: onabort, loader: loader }; // Adds the ability to delay single fragment loading time to control buffer. let now = new Date().getTime(); if (isNaN(request.delayLoadingTime) || now &gt;= request.delayLoadingTime) { // no delay - just send requests.push(httpRequest); loader.load(httpRequest); } else { // delay let delayedRequest = { httpRequest: httpRequest }; delayedRequests.push(delayedRequest); delayedRequest.delayTimeout = setTimeout(function () { if (delayedRequests.indexOf(delayedRequest) === -1) { return; } else { delayedRequests.splice(delayedRequests.indexOf(delayedRequest), 1); } try { requestStartTime = new Date(); lastTraceTime = requestStartTime; requests.push(delayedRequest.httpRequest); loader.load(delayedRequest.httpRequest); } catch (e) { delayedRequest.httpRequest.onerror(); } }, (request.delayLoadingTime - now)); } } /** * Initiates a download of the resource described by config.request * @param {Object} config - contains request (FragmentRequest or derived type), and callbacks * @memberof module:HTTPLoader * @instance */ function load(config) { if (config.request) { internalLoad( config, mediaPlayerModel.getRetryAttemptsForType( config.request.type ) ); } } /** * Aborts any inflight downloads * @memberof module:HTTPLoader * @instance */ function abort() { retryTimers.forEach(t =&gt; clearTimeout(t)); retryTimers = []; delayedRequests.forEach(x =&gt; clearTimeout(x.delayTimeout)); delayedRequests = []; requests.forEach(x =&gt; { // abort will trigger onloadend which we don't want // when deliberately aborting inflight requests - // set them to undefined so they are not called x.onloadend = x.onerror = x.onprogress = undefined; x.loader.abort(x); x.onabort(); }); requests = []; } instance = { load: load, abort: abort }; setup(); return instance; } HTTPLoader.__dashjs_factory_name = 'HTTPLoader'; const factory = FactoryMaker.getClassFactory(HTTPLoader); export default factory; × Search results Close "},"streaming_MediaPlayer.js.html":{"id":"streaming_MediaPlayer.js.html","title":"Source: streaming/MediaPlayer.js","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Source: streaming/MediaPlayer.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ import Constants from './constants/Constants'; import MetricsConstants from './constants/MetricsConstants'; import UTCTiming from '../dash/vo/UTCTiming'; import PlaybackController from './controllers/PlaybackController'; import StreamController from './controllers/StreamController'; import MediaController from './controllers/MediaController'; import ManifestLoader from './ManifestLoader'; import ErrorHandler from './utils/ErrorHandler'; import Capabilities from './utils/Capabilities'; import TextTracks from './text/TextTracks'; import RequestModifier from './utils/RequestModifier'; import TextController from './text/TextController'; import URIFragmentModel from './models/URIFragmentModel'; import ManifestModel from './models/ManifestModel'; import MediaPlayerModel from './models/MediaPlayerModel'; import MetricsModel from './models/MetricsModel'; import AbrController from './controllers/AbrController'; import VideoModel from './models/VideoModel'; import DOMStorage from './utils/DOMStorage'; import Debug from './../core/Debug'; import EventBus from './../core/EventBus'; import Events from './../core/events/Events'; import MediaPlayerEvents from './MediaPlayerEvents'; import FactoryMaker from '../core/FactoryMaker'; import { getVersionString } from './../core/Version'; //Dash import DashAdapter from '../dash/DashAdapter'; import DashManifestModel from '../dash/models/DashManifestModel'; import DashMetrics from '../dash/DashMetrics'; import TimelineConverter from '../dash/utils/TimelineConverter'; import { HTTPRequest } from './vo/metrics/HTTPRequest'; import BASE64 from '../../externals/base64'; import ISOBoxer from 'codem-isoboxer'; /** * @module MediaPlayer * @description The MediaPlayer is the primary dash.js Module and a Facade to build your player around. * It will allow you access to all the important dash.js properties/methods via the public API and all the * events to build a robust DASH media player. */ function MediaPlayer() { const STREAMING_NOT_INITIALIZED_ERROR = 'You must first call initialize() and set a source before calling this method'; const PLAYBACK_NOT_INITIALIZED_ERROR = 'You must first call initialize() and set a valid source and view before calling this method'; const ELEMENT_NOT_ATTACHED_ERROR = 'You must first call attachView() to set the video element before calling this method'; const SOURCE_NOT_ATTACHED_ERROR = 'You must first call attachSource() with a valid source before calling this method'; const MEDIA_PLAYER_NOT_INITIALIZED_ERROR = 'MediaPlayer not initialized!'; const MEDIA_PLAYER_BAD_ARGUMENT_ERROR = 'MediaPlayer Invalid Arguments!'; const PLAYBACK_CATCHUP_RATE_BAD_ARGUMENT_ERROR = 'Playback catchup rate invalid argument! Use a number from 1 to 1.2'; const context = this.context; const eventBus = EventBus(context).getInstance(); const debug = Debug(context).getInstance(); let instance, logger, source, protectionData, mediaPlayerInitialized, streamingInitialized, playbackInitialized, autoPlay, abrController, timelineConverter, mediaController, protectionController, metricsReportingController, mssHandler, adapter, metricsModel, mediaPlayerModel, errHandler, capabilities, streamController, playbackController, dashMetrics, dashManifestModel, manifestModel, videoModel, textController, domStorage; /* --------------------------------------------------------------------------- INIT FUNCTIONS --------------------------------------------------------------------------- */ function setup() { logger = debug.getLogger(instance); mediaPlayerInitialized = false; playbackInitialized = false; streamingInitialized = false; autoPlay = true; protectionController = null; protectionData = null; adapter = null; Events.extend(MediaPlayerEvents); mediaPlayerModel = MediaPlayerModel(context).getInstance(); videoModel = VideoModel(context).getInstance(); } /** * Configure media player with customs controllers. Helpful for tests * * @param {object=} config controllers configuration * @memberof module:MediaPlayer * @instance */ function setConfig(config) { if (!config) { return; } if (config.capabilities) { capabilities = config.capabilities; } if (config.streamController) { streamController = config.streamController; } if (config.playbackController) { playbackController = config.playbackController; } if (config.mediaPlayerModel) { mediaPlayerModel = config.mediaPlayerModel; } if (config.abrController) { abrController = config.abrController; } if (config.mediaController) { mediaController = config.mediaController; } } /** * Upon creating the MediaPlayer you must call initialize before you call anything else. * There is one exception to this rule. It is crucial to call {@link module:MediaPlayer#extend extend()} * with all your extensions prior to calling initialize. * * ALL arguments are optional and there are individual methods to set each argument later on. * The args in this method are just for convenience and should only be used for a simple player setup. * * @param {HTML5MediaElement=} view - Optional arg to set the video element. {@link module:MediaPlayer#attachView attachView()} * @param {string=} source - Optional arg to set the media source. {@link module:MediaPlayer#attachSource attachSource()} * @param {boolean=} AutoPlay - Optional arg to set auto play. {@link module:MediaPlayer#setAutoPlay setAutoPlay()} * @see {@link module:MediaPlayer#attachView attachView()} * @see {@link module:MediaPlayer#attachSource attachSource()} * @see {@link module:MediaPlayer#setAutoPlay setAutoPlay()} * @memberof module:MediaPlayer * @instance */ function initialize(view, source, AutoPlay) { if (!capabilities) { capabilities = Capabilities(context).getInstance(); } errHandler = ErrorHandler(context).getInstance(); if (!capabilities.supportsMediaSource()) { errHandler.capabilityError('mediasource'); return; } if (mediaPlayerInitialized) return; mediaPlayerInitialized = true; // init some controllers and models timelineConverter = TimelineConverter(context).getInstance(); if (!abrController) { abrController = AbrController(context).getInstance(); } if (!playbackController) { playbackController = PlaybackController(context).getInstance(); } if (!mediaController) { mediaController = MediaController(context).getInstance(); } adapter = DashAdapter(context).getInstance(); dashManifestModel = DashManifestModel(context).getInstance({ mediaController: mediaController, timelineConverter: timelineConverter, adapter: adapter }); manifestModel = ManifestModel(context).getInstance(); dashMetrics = DashMetrics(context).getInstance({ manifestModel: manifestModel, dashManifestModel: dashManifestModel }); metricsModel = MetricsModel(context).getInstance(); textController = TextController(context).getInstance(); domStorage = DOMStorage(context).getInstance({ mediaPlayerModel: mediaPlayerModel }); adapter.setConfig({ dashManifestModel: dashManifestModel }); metricsModel.setConfig({ adapter: adapter }); restoreDefaultUTCTimingSources(); setAutoPlay(AutoPlay !== undefined ? AutoPlay : true); if (view) { attachView(view); } if (source) { attachSource(source); } logger.info('[dash.js ' + getVersion() + '] ' + 'MediaPlayer has been initialized'); } /** * Sets the MPD source and the video element to null. You can also reset the MediaPlayer by * calling attachSource with a new source file. * * Calling this method is all that is necessary to destroy a MediaPlayer instance. * * @memberof module:MediaPlayer * @instance */ function reset() { attachSource(null); attachView(null); protectionData = null; if (protectionController) { protectionController.reset(); protectionController = null; } if (metricsReportingController) { metricsReportingController.reset(); metricsReportingController = null; } } /** * The ready state of the MediaPlayer based on both the video element and MPD source being defined. * * @returns {boolean} The current ready state of the MediaPlayer * @see {@link module:MediaPlayer#attachView attachView()} * @see {@link module:MediaPlayer#attachSource attachSource()} * @memberof module:MediaPlayer * @instance */ function isReady() { return (!!source &amp;&amp; !!videoModel.getElement()); } /** * Use the on method to listen for public events found in MediaPlayer.events. {@link MediaPlayerEvents} * * @param {string} type - {@link MediaPlayerEvents} * @param {Function} listener - callback method when the event fires. * @param {Object} scope - context of the listener so it can be removed properly. * @memberof module:MediaPlayer * @instance */ function on(type, listener, scope) { eventBus.on(type, listener, scope); } /** * Use the off method to remove listeners for public events found in MediaPlayer.events. {@link MediaPlayerEvents} * * @param {string} type - {@link MediaPlayerEvents} * @param {Function} listener - callback method when the event fires. * @param {Object} scope - context of the listener so it can be removed properly. * @memberof module:MediaPlayer * @instance */ function off(type, listener, scope) { eventBus.off(type, listener, scope); } /** * Current version of Dash.js * @returns {string} the current dash.js version string. * @memberof module:MediaPlayer * @instance */ function getVersion() { return getVersionString(); } /** * Use this method to access the dash.js logging class. * * @returns {Debug} * @memberof module:MediaPlayer * @instance */ function getDebug() { return debug; } /* --------------------------------------------------------------------------- PLAYBACK FUNCTIONS --------------------------------------------------------------------------- */ /** * Causes the player to begin streaming the media as set by the {@link module:MediaPlayer#attachSource attachSource()} * method in preparation for playing. It specifically does not require a view to be attached with {@link module:MediaPlayer#attachSource attachView()} to begin preloading. * When a view is attached after preloading, the buffered data is transferred to the attached mediaSource buffers. * * @see {@link module:MediaPlayer#attachSource attachSource()} * @see {@link module:MediaPlayer#attachView attachView()} * @memberof module:MediaPlayer * @instance */ function preload() { if (videoModel.getElement() || streamingInitialized) { return false; } if (source) { initializePlayback(); } else { throw SOURCE_NOT_ATTACHED_ERROR; } } /** * The play method initiates playback of the media defined by the {@link module:MediaPlayer#attachSource attachSource()} method. * This method will call play on the native Video Element. * * @see {@link module:MediaPlayer#attachSource attachSource()} * @memberof module:MediaPlayer * @instance */ function play() { if (!playbackInitialized) { throw PLAYBACK_NOT_INITIALIZED_ERROR; } if (!autoPlay || (isPaused() &amp;&amp; playbackInitialized)) { playbackController.play(); } } /** * This method will call pause on the native Video Element. * * @memberof module:MediaPlayer * @instance */ function pause() { if (!playbackInitialized) { throw PLAYBACK_NOT_INITIALIZED_ERROR; } playbackController.pause(); } /** * Returns a Boolean that indicates whether the Video Element is paused. * @return {boolean} * @memberof module:MediaPlayer * @instance */ function isPaused() { if (!playbackInitialized) { throw PLAYBACK_NOT_INITIALIZED_ERROR; } return playbackController.isPaused(); } /** * Sets the currentTime property of the attached video element. If it is a live stream with a * timeShiftBufferLength, then the DVR window offset will be automatically calculated. * * @param {number} value - A relative time, in seconds, based on the return value of the {@link module:MediaPlayer#duration duration()} method is expected * @see {@link module:MediaPlayer#getDVRSeekOffset getDVRSeekOffset()} * @memberof module:MediaPlayer * @instance */ function seek(value) { if (!playbackInitialized) { throw PLAYBACK_NOT_INITIALIZED_ERROR; } if (typeof value !== 'number' || isNaN(value)) { throw MEDIA_PLAYER_BAD_ARGUMENT_ERROR; } let s = playbackController.getIsDynamic() ? getDVRSeekOffset(value) : value; playbackController.seek(s); } /** * Returns a Boolean that indicates whether the media is in the process of seeking to a new position. * @return {boolean} * @memberof module:MediaPlayer * @instance */ function isSeeking() { if (!playbackInitialized) { throw PLAYBACK_NOT_INITIALIZED_ERROR; } return playbackController.isSeeking(); } /** * Returns a Boolean that indicates whether the media is in the process of dynamic. * @return {boolean} * @memberof module:MediaPlayer * @instance */ function isDynamic() { if (!playbackInitialized) { throw PLAYBACK_NOT_INITIALIZED_ERROR; } return playbackController.getIsDynamic(); } /** * Use this method to set the native Video Element's playback rate. * @param {number} value * @memberof module:MediaPlayer * @instance */ function setPlaybackRate(value) { if (!videoModel.getElement()) { throw ELEMENT_NOT_ATTACHED_ERROR; } getVideoElement().playbackRate = value; } /** * Returns the current playback rate. * @returns {number} * @memberof module:MediaPlayer * @instance */ function getPlaybackRate() { if (!videoModel.getElement()) { throw ELEMENT_NOT_ATTACHED_ERROR; } return getVideoElement().playbackRate; } /** * Use this method to set the catch up rate, as a percentage, for low latency live streams. In low latency mode, * when measured latency is higher than the target one ({@link module:MediaPlayer#setLiveDelay setLiveDelay()}), * dash.js increases playback rate the percentage defined with this method until target is reached. * * Valid values for catch up rate are in range 0-20%. Set it to 0% to turn off live catch up feature. * * Note: Catch-up mechanism is only applied when playing low latency live streams. * * @param {number} value Percentage in which playback rate is increased when live catch up mechanism is activated. * @memberof module:MediaPlayer * @see {@link module:MediaPlayer#setLiveDelay setLiveDelay()} * @default {number} 0.05 * @instance */ function setCatchUpPlaybackRate(value) { if (isNaN(value) || value &lt; 0.0 || value &gt; 0.20) { throw PLAYBACK_CATCHUP_RATE_BAD_ARGUMENT_ERROR; } playbackController.setCatchUpPlaybackRate(value); } /** * Returns the current catchup playback rate. * @returns {number} * @see {@link module:MediaPlayer#setCatchUpPlaybackRate setCatchUpPlaybackRate()} * @memberof module:MediaPlayer * @instance */ function getCatchUpPlaybackRate() { return playbackController.getCatchUpPlaybackRate(); } /** * Use this method to set the native Video Element's muted state. Takes a Boolean that determines whether audio is muted. true if the audio is muted and false otherwise. * @param {boolean} value * @memberof module:MediaPlayer * @instance */ function setMute(value) { if (!videoModel.getElement()) { throw ELEMENT_NOT_ATTACHED_ERROR; } getVideoElement().muted = value; } /** * A Boolean that determines whether audio is muted. * @returns {boolean} * @memberof module:MediaPlayer * @instance */ function isMuted() { if (!videoModel.getElement()) { throw ELEMENT_NOT_ATTACHED_ERROR; } return getVideoElement().muted; } /** * A double indicating the audio volume, from 0.0 (silent) to 1.0 (loudest). * @param {number} value * @memberof module:MediaPlayer * @instance */ function setVolume(value) { if (!videoModel.getElement()) { throw ELEMENT_NOT_ATTACHED_ERROR; } getVideoElement().volume = value; } /** * Returns the current audio volume, from 0.0 (silent) to 1.0 (loudest). * @returns {number} * @memberof module:MediaPlayer * @instance */ function getVolume() { if (!videoModel.getElement()) { throw ELEMENT_NOT_ATTACHED_ERROR; } return getVideoElement().volume; } /** * The length of the buffer for a given media type, in seconds. Valid media * types are &quot;video&quot;, &quot;audio&quot; and &quot;fragmentedText&quot;. If no type is passed * in, then the minimum of video, audio and fragmentedText buffer length is * returned. NaN is returned if an invalid type is requested, the * presentation does not contain that type, or if no arguments are passed * and the presentation does not include any adaption sets of valid media * type. * * @param {string} type - the media type of the buffer * @returns {number} The length of the buffer for the given media type, in * seconds, or NaN * @memberof module:MediaPlayer * @instance */ function getBufferLength(type) { const types = [Constants.VIDEO, Constants.AUDIO, Constants.FRAGMENTED_TEXT]; if (!type) { const buffer = types.map( t =&gt; getTracksFor(t).length &gt; 0 ? getDashMetrics().getCurrentBufferLevel(getMetricsFor(t)) : Number.MAX_VALUE ).reduce( (p, c) =&gt; Math.min(p, c) ); return buffer === Number.MAX_VALUE ? NaN : buffer; } else { if (types.indexOf(type) !== -1) { const buffer = getDashMetrics().getCurrentBufferLevel(getMetricsFor(type)); return buffer ? buffer : NaN; } else { logger.warn('getBufferLength requested for invalid type'); return NaN; } } } /** * The timeShiftBufferLength (DVR Window), in seconds. * * @returns {number} The window of allowable play time behind the live point of a live stream. * @memberof module:MediaPlayer * @instance */ function getDVRWindowSize() { let metric = getDVRInfoMetric(); if (!metric) { return 0; } return metric.manifestInfo.DVRWindowSize; } /** * This method should only be used with a live stream that has a valid timeShiftBufferLength (DVR Window). * NOTE - If you do not need the raw offset value (i.e. media analytics, tracking, etc) consider using the {@link module:MediaPlayer#seek seek()} method * which will calculate this value for you and set the video element's currentTime property all in one simple call. * * @param {number} value - A relative time, in seconds, based on the return value of the {@link module:MediaPlayer#duration duration()} method is expected. * @returns {number} A value that is relative the available range within the timeShiftBufferLength (DVR Window). * @see {@link module:MediaPlayer#seek seek()} * @memberof module:MediaPlayer * @instance */ function getDVRSeekOffset(value) { let metric = getDVRInfoMetric(); let liveDelay = playbackController.getLiveDelay(); if (!metric) { return 0; } let val = metric.range.start + value; if (val &gt; (metric.range.end - liveDelay)) { val = metric.range.end - liveDelay; } return val; } /** * Current time of the playhead, in seconds. * * If called with no arguments then the returned time value is time elapsed since the start point of the first stream, or if it is a live stream, then the time will be based on the return value of the {@link module:MediaPlayer#duration duration()} method. * However if a stream ID is supplied then time is relative to the start of that stream, or is null if there is no such stream id in the manifest. * * @param {string} streamId - The ID of a stream that the returned playhead time must be relative to the start of. If undefined, then playhead time is relative to the first stream. * @returns {number} The current playhead time of the media, or null. * @memberof module:MediaPlayer * @instance */ function time(streamId) { if (!playbackInitialized) { throw PLAYBACK_NOT_INITIALIZED_ERROR; } let t = getVideoElement().currentTime; if (streamId !== undefined) { t = streamController.getTimeRelativeToStreamId(t, streamId); } else if (playbackController.getIsDynamic()) { let metric = getDVRInfoMetric(); t = (metric === null) ? 0 : duration() - (metric.range.end - metric.time); } return t; } /** * Duration of the media's playback, in seconds. * * @returns {number} The current duration of the media. * @memberof module:MediaPlayer * @instance */ function duration() { if (!playbackInitialized) { throw PLAYBACK_NOT_INITIALIZED_ERROR; } let d = getVideoElement().duration; if (playbackController.getIsDynamic()) { let metric = getDVRInfoMetric(); let range; if (!metric) { return 0; } range = metric.range.end - metric.range.start; d = range &lt; metric.manifestInfo.DVRWindowSize ? range : metric.manifestInfo.DVRWindowSize; } return d; } /** * Use this method to get the current playhead time as an absolute value, the time in seconds since midnight UTC, Jan 1 1970. * Note - this property only has meaning for live streams. If called before play() has begun, it will return a value of NaN. * * @returns {number} The current playhead time as UTC timestamp. * @memberof module:MediaPlayer * @instance */ function timeAsUTC() { if (!playbackInitialized) { throw PLAYBACK_NOT_INITIALIZED_ERROR; } if (time() &lt; 0) { return NaN; } return getAsUTC(time()); } /** * Use this method to get the current duration as an absolute value, the time in seconds since midnight UTC, Jan 1 1970. * Note - this property only has meaning for live streams. * * @returns {number} The current duration as UTC timestamp. * @memberof module:MediaPlayer * @instance */ function durationAsUTC() { if (!playbackInitialized) { throw PLAYBACK_NOT_INITIALIZED_ERROR; } return getAsUTC(duration()); } /* --------------------------------------------------------------------------- AUTO BITRATE --------------------------------------------------------------------------- */ /** * When switching multi-bitrate content (auto or manual mode) this property specifies the maximum bitrate allowed. * If you set this property to a value lower than that currently playing, the switching engine will switch down to * satisfy this requirement. If you set it to a value that is lower than the lowest bitrate, it will still play * that lowest bitrate. * * You can set or remove this bitrate cap at anytime before or during playback. To clear this setting you must use the API * and set the value param to NaN. * * This feature is typically used to reserve higher bitrates for playback only when the player is in large or full-screen format. * * @param {string} type - 'video' or 'audio' are the type options. * @param {number} value - Value in kbps representing the maximum bitrate allowed. * @memberof module:MediaPlayer * @instance */ function setMaxAllowedBitrateFor(type, value) { abrController.setMaxAllowedBitrateFor(type, value); } /** * When switching multi-bitrate content (auto or manual mode) this property specifies the minimum bitrate allowed. * If you set this property to a value higher than that currently playing, the switching engine will switch up to * satisfy this requirement. If you set it to a value that is lower than the lowest bitrate, it will still play * that lowest bitrate. * * You can set or remove this bitrate limit at anytime before or during playback. To clear this setting you must use the API * and set the value param to NaN. * * This feature is used to force higher quality playback. * * @param {string} type - 'video' or 'audio' are the type options. * @param {number} value - Value in kbps representing the minimum bitrate allowed. * @memberof module:MediaPlayer * @instance */ function setMinAllowedBitrateFor(type, value) { abrController.setMinAllowedBitrateFor(type, value); } /** * @param {string} type - 'video' or 'audio' are the type options. * @memberof module:MediaPlayer * @see {@link module:MediaPlayer#setMaxAllowedBitrateFor setMaxAllowedBitrateFor()} * @instance */ function getMaxAllowedBitrateFor(type) { return abrController.getMaxAllowedBitrateFor(type); } /** * Gets the top quality BitrateInfo checking portal limit and max allowed. * * It calls getTopQualityIndexFor internally * * @param {string} type - 'video' or 'audio' are the type options. * @memberof module:MediaPlayer * @returns {BitrateInfo | null} * @instance */ function getTopBitrateInfoFor(type) { if (!streamingInitialized) { throw STREAMING_NOT_INITIALIZED_ERROR; } return abrController.getTopBitrateInfoFor(type); } /** * @param {string} type - 'video' or 'audio' are the type options. * @memberof module:MediaPlayer * @see {@link module:MediaPlayer#setMinAllowedBitrateFor setMinAllowedBitrateFor()} * @instance */ function getMinAllowedBitrateFor(type) { return abrController.getMinAllowedBitrateFor(type); } /** * When switching multi-bitrate content (auto or manual mode) this property specifies the maximum representation allowed, * as a proportion of the size of the representation set. * * You can set or remove this cap at anytime before or during playback. To clear this setting you must use the API * and set the value param to NaN. * * If both this and maxAllowedBitrate are defined, maxAllowedBitrate is evaluated first, then maxAllowedRepresentation, * i.e. the lowest value from executing these rules is used. * * This feature is typically used to reserve higher representations for playback only when connected over a fast connection. * * @param {string} type - 'video' or 'audio' are the type options. * @param {number} value - number between 0 and 1, where 1 is allow all representations, and 0 is allow only the lowest. * @memberof module:MediaPlayer * @instance */ function setMaxAllowedRepresentationRatioFor(type, value) { abrController.setMaxAllowedRepresentationRatioFor(type, value); } /** * @param {string} type - 'video' or 'audio' are the type options. * @returns {number} The current representation ratio cap. * @memberof module:MediaPlayer * @see {@link module:MediaPlayer#setMaxAllowedRepresentationRatioFor setMaxAllowedRepresentationRatioFor()} * @instance */ function getMaxAllowedRepresentationRatioFor(type) { return abrController.getMaxAllowedRepresentationRatioFor(type); } /** * Gets the current download quality for media type video, audio or images. For video and audio types the ABR * rules update this value before every new download unless setAutoSwitchQualityFor(type, false) is called. For 'image' * type, thumbnails, there is no ABR algorithm and quality is set manually. * * @param {string} type - 'video', 'audio' or 'image' (thumbnails) * @returns {number} the quality index, 0 corresponding to the lowest bitrate * @memberof module:MediaPlayer * @see {@link module:MediaPlayer#setAutoSwitchQualityFor setAutoSwitchQualityFor()} * @see {@link module:MediaPlayer#setQualityFor setQualityFor()} * @instance */ function getQualityFor(type) { if (!streamingInitialized) { throw STREAMING_NOT_INITIALIZED_ERROR; } if (type === Constants.IMAGE) { const activeStream = getActiveStream(); if (!activeStream) { return -1; } const thumbnailController = activeStream.getThumbnailController(); if (!thumbnailController) { return -1; } return thumbnailController.getCurrentTrackIndex(); } return abrController.getQualityFor(type, streamController.getActiveStreamInfo()); } /** * Sets the current quality for media type instead of letting the ABR Heuristics automatically selecting it. * This value will be overwritten by the ABR rules unless setAutoSwitchQualityFor(type, false) is called. * * @param {string} type - 'video', 'audio' or 'image' * @param {number} value - the quality index, 0 corresponding to the lowest bitrate * @memberof module:MediaPlayer * @see {@link module:MediaPlayer#setAutoSwitchQualityFor setAutoSwitchQualityFor()} * @see {@link module:MediaPlayer#getQualityFor getQualityFor()} * @instance */ function setQualityFor(type, value) { if (!streamingInitialized) { throw STREAMING_NOT_INITIALIZED_ERROR; } if (type === Constants.IMAGE) { const activeStream = getActiveStream(); if (!activeStream) { return; } const thumbnailController = activeStream.getThumbnailController(); if (thumbnailController) { thumbnailController.setTrackByIndex(value); } } abrController.setPlaybackQuality(type, streamController.getActiveStreamInfo(), value); } /** * Update the video element size variables * Should be called on window resize (or any other time player is resized). Fullscreen does trigger a window resize event. * * Once windowResizeEventCalled = true, abrController.checkPortalSize() will use element size variables rather than querying clientWidth every time. * * @memberof module:MediaPlayer * @instance */ function updatePortalSize() { abrController.setElementSize(); abrController.setWindowResizeEventCalled(true); } /** * @memberof module:MediaPlayer * @instance */ function getLimitBitrateByPortal() { return abrController.getLimitBitrateByPortal(); } /** * Sets whether to limit the representation used based on the size of the playback area * * @param {boolean} value * @memberof module:MediaPlayer * @instance */ function setLimitBitrateByPortal(value) { abrController.setLimitBitrateByPortal(value); } /** * @memberof module:MediaPlayer * @instance */ function getUsePixelRatioInLimitBitrateByPortal() { return abrController.getUsePixelRatioInLimitBitrateByPortal(); } /** * Sets whether to take into account the device's pixel ratio when defining the portal dimensions. * Useful on, for example, retina displays. * * @param {boolean} value * @memberof module:MediaPlayer * @instance * @default {boolean} false */ function setUsePixelRatioInLimitBitrateByPortal(value) { abrController.setUsePixelRatioInLimitBitrateByPortal(value); } /** * Use this method to explicitly set the starting bitrate for audio | video * * @param {string} type * @param {number} value - A value of the initial bitrate, kbps * @memberof module:MediaPlayer * @instance */ function setInitialBitrateFor(type, value) { abrController.setInitialBitrateFor(type, value); } /** * @param {string} type * @returns {number} A value of the initial bitrate, kbps * @memberof module:MediaPlayer * @instance */ function getInitialBitrateFor(type) { if (!streamingInitialized) { throw STREAMING_NOT_INITIALIZED_ERROR; //abrController.getInitialBitrateFor is overloaded with ratioDict logic that needs manifest force it to not be callable pre play. } return abrController.getInitialBitrateFor(type); } /** * @param {string} type * @param {number} value - A value of the initial Representation Ratio * @memberof module:MediaPlayer * @instance */ function setInitialRepresentationRatioFor(type, value) { abrController.setInitialRepresentationRatioFor(type, value); } /** * @param {string} type * @returns {number} A value of the initial Representation Ratio * @memberof module:MediaPlayer * @instance */ function getInitialRepresentationRatioFor(type) { return abrController.getInitialRepresentationRatioFor(type); } /** * @param {string} type - 'audio' | 'video' * @returns {boolean} Current state of adaptive bitrate switching * @memberof module:MediaPlayer * @instance */ function getAutoSwitchQualityFor(type) { return abrController.getAutoSwitchBitrateFor(type); } /** * Set to false to switch off adaptive bitrate switching. * * @param {string} type - 'audio' | 'video' * @param {boolean} value * @default true * @memberof module:MediaPlayer * @instance */ function setAutoSwitchQualityFor(type, value) { abrController.setAutoSwitchBitrateFor(type, value); } /** * Get the value of useDeadTimeLatency in AbrController. @see setUseDeadTimeLatencyForAbr * * @returns {boolean} * * @memberof module:MediaPlayer * @instance */ function getUseDeadTimeLatencyForAbr() { return abrController.getUseDeadTimeLatency(); } /** * Set the value of useDeadTimeLatency in AbrController. If true, only the download * portion will be considered part of the download bitrate and latency will be * regarded as static. If false, the reciprocal of the whole transfer time will be used. * Defaults to true. * * @param {boolean=} useDeadTimeLatency - True or false flag. * * @memberof module:MediaPlayer * @instance */ function setUseDeadTimeLatencyForAbr(useDeadTimeLatency) { abrController.setUseDeadTimeLatency(useDeadTimeLatency); } /* --------------------------------------------------------------------------- MEDIA PLAYER CONFIGURATION --------------------------------------------------------------------------- */ /** * &lt;p&gt;Set to false to prevent stream from auto-playing when the view is attached.&lt;/p&gt; * * @param {boolean} value * @default true * @memberof module:MediaPlayer * @see {@link module:MediaPlayer#attachView attachView()} * @instance * */ function setAutoPlay(value) { autoPlay = value; } /** * @returns {boolean} The current autoPlay state. * @memberof module:MediaPlayer * @instance */ function getAutoPlay() { return autoPlay; } /** * &lt;p&gt;Changing this value will lower or increase live stream latency. The detected segment duration will be multiplied by this value * to define a time in seconds to delay a live stream from the live edge.&lt;/p&gt; * &lt;p&gt;Lowering this value will lower latency but may decrease the player's ability to build a stable buffer.&lt;/p&gt; * * @param {number} value - Represents how many segment durations to delay the live stream. * @default 4 * @memberof module:MediaPlayer * @see {@link module:MediaPlayer#useSuggestedPresentationDelay useSuggestedPresentationDelay()} * @instance */ function setLiveDelayFragmentCount(value) { mediaPlayerModel.setLiveDelayFragmentCount(value); } /** * &lt;p&gt;Equivalent in seconds of setLiveDelayFragmentCount&lt;/p&gt; * &lt;p&gt;Lowering this value will lower latency but may decrease the player's ability to build a stable buffer.&lt;/p&gt; * &lt;p&gt;This value should be less than the manifest duration by a couple of segment durations to avoid playback issues&lt;/p&gt; * &lt;p&gt;If set, this parameter will take precedence over setLiveDelayFragmentCount and manifest info&lt;/p&gt; * * @param {number} value - Represents how many seconds to delay the live stream. * @default undefined * @memberof module:MediaPlayer * @see {@link module:MediaPlayer#useSuggestedPresentationDelay useSuggestedPresentationDelay()} * @instance */ function setLiveDelay(value) { mediaPlayerModel.setLiveDelay(value); } /** * @memberof module:MediaPlayer * @see {@link module:MediaPlayer#setLiveDelay setLiveDelay()} * @instance * @returns {number|undefined} Current live stream delay in seconds when previously set, or `undefined` */ function getLiveDelay() { return mediaPlayerModel.getLiveDelay(); } /** * @memberof module:MediaPlayer * @instance * @returns {number|NaN} Current live stream latency in seconds. It is the difference between current time and time position at the playback head. */ function getCurrentLiveLatency() { if (!mediaPlayerInitialized) { throw MEDIA_PLAYER_NOT_INITIALIZED_ERROR; } if (!playbackInitialized) { return NaN; } return playbackController.getCurrentLiveLatency(); } /** * &lt;p&gt;Set to true if you would like to override the default live delay and honor the SuggestedPresentationDelay attribute in by the manifest.&lt;/p&gt; * @param {boolean} value * @default false * @memberof module:MediaPlayer * @see {@link module:MediaPlayer#setLiveDelayFragmentCount setLiveDelayFragmentCount()} * @instance */ function useSuggestedPresentationDelay(value) { mediaPlayerModel.setUseSuggestedPresentationDelay(value); } /** * Set to false if you would like to disable the last known bit rate from being stored during playback and used * to set the initial bit rate for subsequent playback within the expiration window. * * The default expiration is one hour, defined in milliseconds. If expired, the default initial bit rate (closest to 1000 kbps) will be used * for that session and a new bit rate will be stored during that session. * * @param {boolean} enable - Will toggle if feature is enabled. True to enable, False to disable. * @param {number=} ttl - (Optional) A value defined in milliseconds representing how long to cache the bit rate for. Time to live. * @default enable = True, ttl = 360000 (1 hour) * @memberof module:MediaPlayer * @instance * */ function enableLastBitrateCaching(enable, ttl) { mediaPlayerModel.setLastBitrateCachingInfo(enable, ttl); } /** * Set to false if you would like to disable the last known lang for audio (or camera angle for video) from being stored during playback and used * to set the initial settings for subsequent playback within the expiration window. * * The default expiration is one hour, defined in milliseconds. If expired, the default settings will be used * for that session and a new settings will be stored during that session. * * @param {boolean} enable - Will toggle if feature is enabled. True to enable, False to disable. * @param {number=} [ttl] - (Optional) A value defined in milliseconds representing how long to cache the settings for. Time to live. * @default enable = True, ttl = 360000 (1 hour) * @memberof module:MediaPlayer * @instance * */ function enableLastMediaSettingsCaching(enable, ttl) { mediaPlayerModel.setLastMediaSettingsCachingInfo(enable, ttl); } /** * Set to true if you would like dash.js to keep downloading fragments in the background * when the video element is paused. * * @default true * @param {boolean} value * @memberof module:MediaPlayer * @instance */ function setScheduleWhilePaused(value) { mediaPlayerModel.setScheduleWhilePaused(value); } /** * Returns a boolean of the current state of ScheduleWhilePaused. * @returns {boolean} * @see {@link module:MediaPlayer#setScheduleWhilePaused setScheduleWhilePaused()} * @memberof module:MediaPlayer * @instance */ function getScheduleWhilePaused() { return mediaPlayerModel.getScheduleWhilePaused(); } /** * When enabled, after an ABR up-switch in quality, instead of requesting and appending the next fragment * at the end of the current buffer range it is requested and appended closer to the current time * When enabled, The maximum time to render a higher quality is current time + (1.5 * fragment duration). * * Note, When ABR down-switch is detected, we appended the lower quality at the end of the buffer range to preserve the * higher quality media for as long as possible. * * If enabled, it should be noted there are a few cases when the client will not replace inside buffer range but rather * just append at the end. 1. When the buffer level is less than one fragment duration 2. The client * is in an Abandonment State due to recent fragment abandonment event. * * Known issues: * 1. In IE11 with auto switching off, if a user switches to a quality they can not download in time the * fragment may be appended in the same range as the playhead or even in the past, in IE11 it may cause a stutter * or stall in playback. * * * @param {boolean} value * @default {boolean} false * @memberof module:MediaPlayer * @instance */ function setFastSwitchEnabled(value) { //TODO we need to look at track switches for adaptation sets. If always replace it works much like this but clears buffer. Maybe too many ways to do same thing. mediaPlayerModel.setFastSwitchEnabled(value); } /** * Enabled by default. Will return the current state of Fast Switch. * @return {boolean} Returns true if FastSwitch ABR is enabled. * @see {@link module:MediaPlayer#setFastSwitchEnabled setFastSwitchEnabled()} * @memberof module:MediaPlayer * @instance */ function getFastSwitchEnabled() { return mediaPlayerModel.getFastSwitchEnabled(); } /** * Sets the ABR strategy. Valid strategies are &quot;abrDynamic&quot;, &quot;abrBola&quot; and &quot;abrThroughput&quot;. * The ABR strategy can also be changed during a streaming session. * The call has no effect if an invalid method is passed. * * The BOLA strategy chooses bitrate based on current buffer level, with higher bitrates for higher buffer levels. * The Throughput strategy chooses bitrate based on the recent throughput history. * The Dynamic strategy switches smoothly between BOLA and Throughput in real time, playing to the strengths of both. * * @param {string} value * @default &quot;abrDynamic&quot; * @memberof module:MediaPlayer * @instance */ function setABRStrategy(value) { if (value === Constants.ABR_STRATEGY_DYNAMIC || value === Constants.ABR_STRATEGY_BOLA || value === Constants.ABR_STRATEGY_THROUGHPUT) { mediaPlayerModel.setABRStrategy(value); } else { logger.warn('Ignoring setABRStrategy(' + value + ') - unknown value.'); } } /** * Returns the current ABR strategy being used. * @return {string} &quot;abrDynamic&quot;, &quot;abrBola&quot; or &quot;abrThroughput&quot; * @see {@link module:MediaPlayer#setABRStrategy setABRStrategy()} * @memberof module:MediaPlayer * @instance */ function getABRStrategy() { return mediaPlayerModel.getABRStrategy(); } /** * Enable/disable builtin dashjs ABR rules * @param {boolean} value * @default true * @memberof module:MediaPlayer * @instance */ function useDefaultABRRules(value) { mediaPlayerModel.setUseDefaultABRRules(value); } /** * Add a custom ABR Rule * Rule will be apply on next stream if a stream is being played * * @param {string} type - rule type (one of ['qualitySwitchRules','abandonFragmentRules']) * @param {string} rulename - name of rule (used to identify custom rule). If one rule of same name has been added, then existing rule will be updated * @param {object} rule - the rule object instance * @memberof module:MediaPlayer * @instance */ function addABRCustomRule(type, rulename, rule) { mediaPlayerModel.addABRCustomRule(type, rulename, rule); } /** * Remove a custom ABR Rule * * @param {string} rulename - name of the rule to be removed * @memberof module:MediaPlayer * @instance */ function removeABRCustomRule(rulename) { mediaPlayerModel.removeABRCustomRule(rulename); } /** * Remove all custom rules * @memberof module:MediaPlayer * @instance */ function removeAllABRCustomRule() { mediaPlayerModel.removeAllABRCustomRule(); } /** * Sets the moving average method used for smoothing throughput estimates. Valid methods are * &quot;slidingWindow&quot; and &quot;ewma&quot;. The call has no effect if an invalid method is passed. * * The sliding window moving average method computes the average throughput using the last four segments downloaded. * If the stream is live (as opposed to VOD), then only the last three segments are used. * If wide variations in throughput are detected, the number of segments can be dynamically increased to avoid oscillations. * * The exponentially weighted moving average (EWMA) method computes the average using exponential smoothing. * Two separate estimates are maintained, a fast one with a three-second half life and a slow one with an eight-second half life. * The throughput estimate at any time is the minimum of the fast and slow estimates. * This allows a fast reaction to a bandwidth drop and prevents oscillations on bandwidth spikes. * * @param {string} value * @default {string} 'slidingWindow' * @memberof module:MediaPlayer * @instance */ function setMovingAverageMethod(value) { if (value === Constants.MOVING_AVERAGE_SLIDING_WINDOW || value === Constants.MOVING_AVERAGE_EWMA) { mediaPlayerModel.setMovingAverageMethod(value); } else { logger.warn('Warning: Ignoring setMovingAverageMethod(' + value + ') - unknown value.'); } } /** * Return the current moving average method used for smoothing throughput estimates. * @return {string} Returns &quot;slidingWindow&quot; or &quot;ewma&quot;. * @see {@link module:MediaPlayer#setMovingAverageMethod setMovingAverageMethod()} * @memberof module:MediaPlayer * @instance */ function getMovingAverageMethod() { return mediaPlayerModel.getMovingAverageMethod(); } /** * Returns if low latency mode is enabled. Disabled by default. * @return {boolean} true - if enabled * @see {@link module:MediaPlayer#setLowLatencyEnabled setLowLatencyEnabled()} * @memberof module:MediaPlayer * @instance */ function getLowLatencyEnabled() { return mediaPlayerModel.getLowLatencyEnabled(); } /** * Enables low latency mode for dynamic streams. If not specified, liveDelay is set to 3s of buffer. * Browser compatibility (Check row 'ReadableStream response body'): https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API * @param {boolean} value * @memberof module:MediaPlayer * @instance */ function setLowLatencyEnabled(value) { return mediaPlayerModel.setLowLatencyEnabled(value); } /** * &lt;p&gt;Allows you to set a scheme and server source for UTC live edge detection for dynamic streams. * If UTCTiming is defined in the manifest, it will take precedence over any time source manually added.&lt;/p&gt; * &lt;p&gt;If you have exposed the Date header, use the method {@link module:MediaPlayer#clearDefaultUTCTimingSources clearDefaultUTCTimingSources()}. * This will allow the date header on the manifest to be used instead of a time server&lt;/p&gt; * @param {string} schemeIdUri - &lt;ul&gt; * &lt;li&gt;urn:mpeg:dash:utc:http-head:2014&lt;/li&gt; * &lt;li&gt;urn:mpeg:dash:utc:http-xsdate:2014&lt;/li&gt; * &lt;li&gt;urn:mpeg:dash:utc:http-iso:2014&lt;/li&gt; * &lt;li&gt;urn:mpeg:dash:utc:direct:2014&lt;/li&gt; * &lt;/ul&gt; * &lt;p&gt;Some specs referencing early ISO23009-1 drafts incorrectly use * 2012 in the URI, rather than 2014. support these for now.&lt;/p&gt; * &lt;ul&gt; * &lt;li&gt;urn:mpeg:dash:utc:http-head:2012&lt;/li&gt; * &lt;li&gt;urn:mpeg:dash:utc:http-xsdate:2012&lt;/li&gt; * &lt;li&gt;urn:mpeg:dash:utc:http-iso:2012&lt;/li&gt; * &lt;li&gt;urn:mpeg:dash:utc:direct:2012&lt;/li&gt; * &lt;/ul&gt; * @param {string} value - Path to a time source. * @default * &lt;ul&gt; * &lt;li&gt;schemeIdUri:urn:mpeg:dash:utc:http-xsdate:2014&lt;/li&gt; * &lt;li&gt;value:http://time.akamai.com&lt;/li&gt; * &lt;/ul&gt; * @memberof module:MediaPlayer * @see {@link module:MediaPlayer#removeUTCTimingSource removeUTCTimingSource()} * @instance */ function addUTCTimingSource(schemeIdUri, value) { removeUTCTimingSource(schemeIdUri, value); //check if it already exists and remove if so. let vo = new UTCTiming(); vo.schemeIdUri = schemeIdUri; vo.value = value; mediaPlayerModel.getUTCTimingSources().push(vo); } /** * &lt;p&gt;Allows you to remove a UTC time source. Both schemeIdUri and value need to match the Dash.vo.UTCTiming properties in order for the * entry to be removed from the array&lt;/p&gt; * @param {string} schemeIdUri - see {@link module:MediaPlayer#addUTCTimingSource addUTCTimingSource()} * @param {string} value - see {@link module:MediaPlayer#addUTCTimingSource addUTCTimingSource()} * @memberof module:MediaPlayer * @see {@link module:MediaPlayer#clearDefaultUTCTimingSources clearDefaultUTCTimingSources()} * @instance */ function removeUTCTimingSource(schemeIdUri, value) { let UTCTimingSources = mediaPlayerModel.getUTCTimingSources(); UTCTimingSources.forEach(function (obj, idx) { if (obj.schemeIdUri === schemeIdUri &amp;&amp; obj.value === value) { UTCTimingSources.splice(idx, 1); } }); } /** * &lt;p&gt;Allows you to clear the stored array of time sources.&lt;/p&gt; * &lt;p&gt;Example use: If you have exposed the Date header, calling this method * will allow the date header on the manifest to be used instead of the time server.&lt;/p&gt; * &lt;p&gt;Example use: Calling this method, assuming there is not an exposed date header on the manifest, will default back * to using a binary search to discover the live edge&lt;/p&gt; * * @memberof module:MediaPlayer * @see {@link module:MediaPlayer#restoreDefaultUTCTimingSources restoreDefaultUTCTimingSources()} * @instance */ function clearDefaultUTCTimingSources() { mediaPlayerModel.setUTCTimingSources([]); } /** * &lt;p&gt;Allows you to restore the default time sources after calling {@link module:MediaPlayer#clearDefaultUTCTimingSources clearDefaultUTCTimingSources()}&lt;/p&gt; * * @default * &lt;ul&gt; * &lt;li&gt;schemeIdUri:urn:mpeg:dash:utc:http-xsdate:2014&lt;/li&gt; * &lt;li&gt;value:http://time.akamai.com&lt;/li&gt; * &lt;/ul&gt; * * @memberof module:MediaPlayer * @see {@link module:MediaPlayer#addUTCTimingSource addUTCTimingSource()} * @instance */ function restoreDefaultUTCTimingSources() { addUTCTimingSource(MediaPlayerModel.DEFAULT_UTC_TIMING_SOURCE.scheme, MediaPlayerModel.DEFAULT_UTC_TIMING_SOURCE.value); } /** * &lt;p&gt;Allows you to enable the use of the Date Header, if exposed with CORS, as a timing source for live edge detection. The * use of the date header will happen only after the other timing source that take precedence fail or are omitted as described. * {@link module:MediaPlayer#clearDefaultUTCTimingSources clearDefaultUTCTimingSources()} &lt;/p&gt; * * @param {boolean} value - true to enable * @default {boolean} True * @memberof module:MediaPlayer * @see {@link module:MediaPlayer#addUTCTimingSource addUTCTimingSource()} * @instance */ function enableManifestDateHeaderTimeSource(value) { mediaPlayerModel.setUseManifestDateHeaderTimeSource(value); } /** * This value influences the buffer pruning logic. * Allows you to modify the buffer that is kept in source buffer in seconds. * &lt;pre&gt;0|-----------bufferToPrune-----------|-----bufferToKeep-----|currentTime|&lt;/pre&gt; * * @default 20 seconds * @param {int} value * @memberof module:MediaPlayer * @instance */ function setBufferToKeep(value) { mediaPlayerModel.setBufferToKeep(value); } /** * This value influences the buffer pruning logic. * Allows you to modify the buffer ahead of current time position that is kept in source buffer in seconds. * &lt;pre&gt;0|--------|currentTime|-----bufferAheadToKeep----|----bufferToPrune-----------|end|&lt;/pre&gt; * * @default 80 seconds * @param {int} value * @memberof module:MediaPlayer * @instance */ function setBufferAheadToKeep(value) { mediaPlayerModel.setBufferAheadToKeep(value); } /** * This value influences the buffer pruning logic. * Allows you to modify the interval of pruning buffer in seconds. * * @default 10 seconds * @param {int} value * @memberof module:MediaPlayer * @instance */ function setBufferPruningInterval(value) { mediaPlayerModel.setBufferPruningInterval(value); } /** * The time that the internal buffer target will be set to post startup/seeks (NOT top quality). * * When the time is set higher than the default you will have to wait longer * to see automatic bitrate switches but will have a larger buffer which * will increase stability. * * @default 12 seconds. * @param {int} value * @memberof module:MediaPlayer * @instance */ function setStableBufferTime(value) { mediaPlayerModel.setStableBufferTime(value); } /** * The time that the internal buffer target will be set to post startup/seeks (NOT top quality). * * When the time is set higher than the default you will have to wait longer * to see automatic bitrate switches but will have a larger buffer which * will increase stability. * * @default 12 seconds. * @memberof module:MediaPlayer * @instance */ function getStableBufferTime() { return mediaPlayerModel.getStableBufferTime(); } /** * The time that the internal buffer target will be set to once playing the top quality. * If there are multiple bitrates in your adaptation, and the media is playing at the highest * bitrate, then we try to build a larger buffer at the top quality to increase stability * and to maintain media quality. * * @default 30 seconds. * @param {int} value /** * The time that the internal buffer target will be set to once playing the top quality. * If there are multiple bitrates in your adaptation, and the media is playing at the highest * bitrate, then we try to build a larger buffer at the top quality to increase stability * and to maintain media quality. * * @default 30 seconds. * @param {int} value * @memberof module:MediaPlayer * @instance */ function setBufferTimeAtTopQuality(value) { mediaPlayerModel.setBufferTimeAtTopQuality(value); } /** * The time that the internal buffer target will be set to once playing the top quality. * If there are multiple bitrates in your adaptation, and the media is playing at the highest * bitrate, then we try to build a larger buffer at the top quality to increase stability * and to maintain media quality. * * @default 30 seconds. * @memberof module:MediaPlayer * @instance */ function getBufferTimeAtTopQuality() { return mediaPlayerModel.getBufferTimeAtTopQuality(); } /** * The time that the internal buffer target will be set to once playing the top quality for long form content. * * @default 60 seconds. * @see {@link module:MediaPlayer#setLongFormContentDurationThreshold setLongFormContentDurationThreshold()} * @see {@link module:MediaPlayer#setBufferTimeAtTopQuality setBufferTimeAtTopQuality()} * @param {int} value * @memberof module:MediaPlayer * @instance */ function setBufferTimeAtTopQualityLongForm(value) { mediaPlayerModel.setBufferTimeAtTopQualityLongForm(value); } /** * The time that the internal buffer target will be set to once playing the top quality for long form content. * * @default 60 seconds. * @see {@link module:MediaPlayer#setLongFormContentDurationThreshold setLongFormContentDurationThreshold()} * @see {@link module:MediaPlayer#setBufferTimeAtTopQuality setBufferTimeAtTopQuality()} * @memberof module:MediaPlayer * @instance */ function getBufferTimeAtTopQualityLongForm() { return mediaPlayerModel.getBufferTimeAtTopQualityLongForm(); } /** * The threshold which defines if the media is considered long form content. * This will directly affect the buffer targets when playing back at the top quality. * * @see {@link module:MediaPlayer#setBufferTimeAtTopQualityLongForm setBufferTimeAtTopQualityLongForm()} * @default 600 seconds (10 minutes). * @param {number} value * @memberof module:MediaPlayer * @instance */ function setLongFormContentDurationThreshold(value) { mediaPlayerModel.setLongFormContentDurationThreshold(value); } /** * The overlap tolerance time, at both the head and the tail of segments, considered when doing time to segment conversions. * * This is used when calculating which of the loaded segments of a representation corresponds with a given time position. * Its value is never used for calculating the segment index in seeking operations in which it assumes overlap time threshold is zero. * * &lt;pre&gt; * |-o-|--- segment X ----|-o-| * |-o-|---- segment X+1 -----|-o-| * |-o-|---- segment X+2 -----|-o-| * &lt;/pre&gt; * @default 0.05 seconds. * @param {number} value * @memberof module:MediaPlayer * @instance */ function setSegmentOverlapToleranceTime(value) { mediaPlayerModel.setSegmentOverlapToleranceTime(value); } /** * For a given media type, the threshold which defines if the response to a fragment * request is coming from browser cache or not. * Valid media types are &quot;video&quot;, &quot;audio&quot; * * @default 50 milliseconds for video fragment requests; 5 milliseconds for audio fragment requests. * @param {string} type 'video' or 'audio' are the type options. * @param {number} value Threshold value in milliseconds. * @memberof module:MediaPlayer * @instance */ function setCacheLoadThresholdForType(type, value) { mediaPlayerModel.setCacheLoadThresholdForType(type, value); } /** * A percentage between 0.0 and 1 to reduce the measured throughput calculations. * The default is 0.9. The lower the value the more conservative and restricted the * measured throughput calculations will be. please use carefully. This will directly * affect the ABR logic in dash.js * * @param {number} value * @memberof module:MediaPlayer * @instance */ function setBandwidthSafetyFactor(value) { mediaPlayerModel.setBandwidthSafetyFactor(value); } /** * Returns the number of the current BandwidthSafetyFactor * * @return {number} value * @see {@link module:MediaPlayer#setBandwidthSafetyFactor setBandwidthSafetyFactor()} * @memberof module:MediaPlayer * @instance */ function getBandwidthSafetyFactor() { return mediaPlayerModel.getBandwidthSafetyFactor(); } /** * Returns the average throughput computed in the ABR logic * * @param {string} type * @return {number} value * @memberof module:MediaPlayer * @instance */ function getAverageThroughput(type) { const throughputHistory = abrController.getThroughputHistory(); return throughputHistory ? throughputHistory.getAverageThroughput(type) : 0; } /** * A timeout value in seconds, which during the ABRController will block switch-up events. * This will only take effect after an abandoned fragment event occurs. * * @default 10 seconds * @param {int} value * @memberof module:MediaPlayer * @instance */ function setAbandonLoadTimeout(value) { mediaPlayerModel.setAbandonLoadTimeout(value); } /** * Total number of retry attempts that will occur on a fragment load before it fails. * Increase this value to a maximum in order to achieve an automatic playback resume * in case of completely lost internet connection. * * @default 3 * @param {int} value * @memberof module:MediaPlayer * @instance */ function setFragmentLoaderRetryAttempts(value) { mediaPlayerModel.setFragmentRetryAttempts(value); } /** * Time in milliseconds of which to reload a failed fragment load attempt. * * @default 1000 milliseconds * @param {int} value * @memberof module:MediaPlayer * @instance */ function setFragmentLoaderRetryInterval(value) { mediaPlayerModel.setFragmentRetryInterval(value); } /** * Total number of retry attempts that will occur on a manifest load before it fails. * * @default 4 * @param {int} value * @memberof module:MediaPlayer * @instance */ function setManifestLoaderRetryAttempts(value) { mediaPlayerModel.setManifestRetryAttempts(value); } /** * Time in milliseconds of which to reload a failed manifest load attempt. * * @default 1000 milliseconds * @param {int} value * @memberof module:MediaPlayer * @instance */ function setManifestLoaderRetryInterval(value) { mediaPlayerModel.setManifestRetryInterval(value); } /** * Sets whether withCredentials on XHR requests for a particular request * type is true or false * * @default false * @param {string} type - one of HTTPRequest.*_TYPE * @param {boolean} value * @memberof module:MediaPlayer * @instance */ function setXHRWithCredentialsForType(type, value) { mediaPlayerModel.setXHRWithCredentialsForType(type, value); } /** * Gets whether withCredentials on XHR requests for a particular request * type is true or false * * @param {string} type - one of HTTPRequest.*_TYPE * @return {boolean} * @memberof module:MediaPlayer * @instance */ function getXHRWithCredentialsForType(type) { return mediaPlayerModel.getXHRWithCredentialsForType(type); } /** * Sets whether player should jump small gaps (discontinuities) in the buffer. * * @param {boolean} value * @default false * @memberof module:MediaPlayer * @instance * */ function setJumpGaps(value) { mediaPlayerModel.setJumpGaps(value); } /** * Gets current status of jump gaps feature. * @returns {boolean} The current jump gaps state. * @memberof module:MediaPlayer * @instance */ function getJumpGaps() { return mediaPlayerModel.getJumpGaps(); } /** * Time in seconds for a gap to be considered small. * * @param {boolean} value * @default 0.8 * @memberof module:MediaPlayer * @instance * */ function setSmallGapLimit(value) { mediaPlayerModel.setSmallGapLimit(value); } /** * Time in seconds for a gap to be considered small. * @returns {boolean} Current small gap limit * @memberof module:MediaPlayer * @instance */ function getSmallGapLimit() { return mediaPlayerModel.getSmallGapLimit(); } /** * For live streams, set the interval-frequency in milliseconds at which * dash.js will check if the current manifest is still processed before * downloading the next manifest once the minimumUpdatePeriod time has * expired. * @param {int} value * @default 100 * @memberof module:MediaPlayer * @instance * @see {@link module:MediaPlayer#getManifestUpdateRetryInterval getManifestUpdateRetryInterval()} * */ function setManifestUpdateRetryInterval(value) { mediaPlayerModel.setManifestUpdateRetryInterval(value); } /** * For live streams, get the interval-frequency in milliseconds at which * dash.js will check if the current manifest is still processed before * downloading the next manifest once the minimumUpdatePeriod time has * expired. * @returns {int} Current retry delay for manifest update * @memberof module:MediaPlayer * @instance * @see {@link module:MediaPlayer#setManifestUpdateRetryInterval setManifestUpdateRetryInterval()} */ function getManifestUpdateRetryInterval() { return mediaPlayerModel.getManifestUpdateRetryInterval(); } /* --------------------------------------------------------------------------- METRICS --------------------------------------------------------------------------- */ /** * Returns the DashMetrics.js Module. You use this Module to get access to all the public metrics * stored in dash.js * * @see {@link module:DashMetrics} * @returns {Object} * @memberof module:MediaPlayer * @instance */ function getDashMetrics() { return dashMetrics; } /** * * @param {string} type * @returns {Object} * @memberof module:MediaPlayer * @instance */ function getMetricsFor(type) { return metricsModel.getReadOnlyMetricsFor(type); } /* --------------------------------------------------------------------------- TEXT MANAGEMENT --------------------------------------------------------------------------- */ /** * Set default language for text. If default language is not one of text tracks, dash will choose the first one. * * @param {string} lang - default language * @memberof module:MediaPlayer * @instance */ function setTextDefaultLanguage(lang) { if (textController === undefined) { textController = TextController(context).getInstance(); } textController.setTextDefaultLanguage(lang); } /** * Get default language for text. * * @return {string} the default language if it has been set using setTextDefaultLanguage * @memberof module:MediaPlayer * @instance */ function getTextDefaultLanguage() { if (textController === undefined) { textController = TextController(context).getInstance(); } return textController.getTextDefaultLanguage(); } /** * Set enabled default state. * This is used to enable/disable text when a file is loaded. * During playback, use enableText to enable text for the file * * @param {boolean} enable - true to enable text, false otherwise * @memberof module:MediaPlayer * @instance */ function setTextDefaultEnabled(enable) { if (textController === undefined) { textController = TextController(context).getInstance(); } textController.setTextDefaultEnabled(enable); } /** * Get enabled default state. * * @return {boolean} default enable state * @memberof module:MediaPlayer * @instance */ function getTextDefaultEnabled() { if (textController === undefined) { textController = TextController(context).getInstance(); } return textController.getTextDefaultEnabled(); } /** * Enable/disable text * When enabling text, dash will choose the previous selected text track * * @param {boolean} enable - true to enable text, false otherwise (same as setTextTrack(-1)) * @memberof module:MediaPlayer * @instance */ function enableText(enable) { if (textController === undefined) { textController = TextController(context).getInstance(); } textController.enableText(enable); } /** * Enable/disable text * When enabling dash will keep downloading and process fragmented text tracks even if all tracks are in mode &quot;hidden&quot; * * @param {boolean} enable - true to enable text streaming even if all text tracks are hidden. * @memberof module:MediaPlayer * @instance */ function enableForcedTextStreaming(enable) { if (textController === undefined) { textController = TextController(context).getInstance(); } textController.enableForcedTextStreaming(enable); } /** * Return if text is enabled * * @return {boolean} return true if text is enabled, false otherwise * @memberof module:MediaPlayer * @instance */ function isTextEnabled() { if (textController === undefined) { textController = TextController(context).getInstance(); } return textController.isTextEnabled(); } /** * Use this method to change the current text track for both external time text files and fragmented text tracks. There is no need to * set the track mode on the video object to switch a track when using this method. * @param {number} idx - Index of track based on the order of the order the tracks are added Use -1 to disable all tracks. (turn captions off). Use module:MediaPlayer#dashjs.MediaPlayer.events.TEXT_TRACK_ADDED. * @see {@link MediaPlayerEvents#event:TEXT_TRACK_ADDED dashjs.MediaPlayer.events.TEXT_TRACK_ADDED} * @memberof module:MediaPlayer * @instance */ function setTextTrack(idx) { if (!playbackInitialized) { throw PLAYBACK_NOT_INITIALIZED_ERROR; } if (textController === undefined) { textController = TextController(context).getInstance(); } textController.setTextTrack(idx); } function getCurrentTextTrackIndex() { let idx = NaN; if (textController) { idx = textController.getCurrentTrackIdx(); } return idx; } /** * This method serves to control captions z-index value. If 'true' is passed, the captions will have the highest z-index and be * displayed on top of other html elements. Default value is 'false' (z-index is not set). * @param {boolean} value * @memberof module:MediaPlayer * @instance */ function displayCaptionsOnTop(value) { let textTracks = TextTracks(context).getInstance(); textTracks.setConfig({ videoModel: videoModel }); textTracks.initialize(); textTracks.displayCConTop(value); } /* --------------------------------------------------------------------------- VIDEO ELEMENT MANAGEMENT --------------------------------------------------------------------------- */ /** * Returns instance of Video Element that was attached by calling attachView() * @returns {Object} * @memberof module:MediaPlayer * @instance */ function getVideoElement() { if (!videoModel.getElement()) { throw ELEMENT_NOT_ATTACHED_ERROR; } return videoModel.getElement(); } /** * Returns instance of Video Container that was attached by calling attachVideoContainer() * @returns {Object} * @memberof module:MediaPlayer * @instance */ function getVideoContainer() { return videoModel ? videoModel.getVideoContainer() : null; } /** * Use this method to attach an HTML5 element that wraps the video element. * * @param {HTMLElement} container - The HTML5 element containing the video element. * @memberof module:MediaPlayer * @instance */ function attachVideoContainer(container) { if (!videoModel.getElement()) { throw ELEMENT_NOT_ATTACHED_ERROR; } videoModel.setVideoContainer(container); } /** * Use this method to attach an HTML5 VideoElement for dash.js to operate upon. * * @param {Object} element - An HTMLMediaElement that has already been defined in the DOM (or equivalent stub). * @memberof module:MediaPlayer * @instance */ function attachView(element) { if (!mediaPlayerInitialized) { throw MEDIA_PLAYER_NOT_INITIALIZED_ERROR; } videoModel.setElement(element); if (element) { detectProtection(); detectMetricsReporting(); detectMss(); if (streamController) { streamController.switchToVideoElement(); } } if (playbackInitialized) { //Reset if we have been playing before, so this is a new element. resetPlaybackControllers(); } initializePlayback(); } /** * Returns instance of Div that was attached by calling attachTTMLRenderingDiv() * @returns {Object} * @memberof module:MediaPlayer * @instance */ function getTTMLRenderingDiv() { return videoModel ? videoModel.getTTMLRenderingDiv() : null; } /** * Use this method to attach an HTML5 div for dash.js to render rich TTML subtitles. * * @param {HTMLDivElement} div - An unstyled div placed after the video element. It will be styled to match the video size and overlay z-order. * @memberof module:MediaPlayer * @instance */ function attachTTMLRenderingDiv(div) { if (!videoModel.getElement()) { throw ELEMENT_NOT_ATTACHED_ERROR; } videoModel.setTTMLRenderingDiv(div); } /* --------------------------------------------------------------------------- STREAM AND TRACK MANAGEMENT --------------------------------------------------------------------------- */ /** * @param {string} type * @returns {Array} * @memberof module:MediaPlayer * @instance */ function getBitrateInfoListFor(type) { if (!streamingInitialized) { throw STREAMING_NOT_INITIALIZED_ERROR; } let stream = getActiveStream(); return stream ? stream.getBitrateListFor(type) : []; } /** * This method returns the list of all available streams from a given manifest * @param {Object} manifest * @returns {Array} list of {@link StreamInfo} * @memberof module:MediaPlayer * @instance */ function getStreamsFromManifest(manifest) { if (!streamingInitialized) { throw STREAMING_NOT_INITIALIZED_ERROR; } return adapter.getStreamsInfo(manifest); } /** * This method returns the list of all available tracks for a given media type * @param {string} type * @returns {Array} list of {@link MediaInfo} * @memberof module:MediaPlayer * @instance */ function getTracksFor(type) { if (!streamingInitialized) { throw STREAMING_NOT_INITIALIZED_ERROR; } let streamInfo = streamController.getActiveStreamInfo(); if (!streamInfo) return []; return mediaController.getTracksFor(type, streamInfo); } /** * This method returns the list of all available tracks for a given media type and streamInfo from a given manifest * @param {string} type * @param {Object} manifest * @param {Object} streamInfo * @returns {Array} list of {@link MediaInfo} * @memberof module:MediaPlayer * @instance */ function getTracksForTypeFromManifest(type, manifest, streamInfo) { if (!streamingInitialized) { throw STREAMING_NOT_INITIALIZED_ERROR; } streamInfo = streamInfo || adapter.getStreamsInfo(manifest, 1)[0]; return streamInfo ? adapter.getAllMediaInfoForType(streamInfo, type, manifest) : []; } /** * @param {string} type * @returns {Object|null} {@link MediaInfo} * * @memberof module:MediaPlayer * @instance */ function getCurrentTrackFor(type) { if (!streamingInitialized) { throw STREAMING_NOT_INITIALIZED_ERROR; } let streamInfo = streamController.getActiveStreamInfo(); if (!streamInfo) return null; return mediaController.getCurrentTrackFor(type, streamInfo); } /** * This method allows to set media settings that will be used to pick the initial track. Format of the settings * is following: * {lang: langValue, * viewpoint: viewpointValue, * audioChannelConfiguration: audioChannelConfigurationValue, * accessibility: accessibilityValue, * role: roleValue} * * * @param {string} type * @param {Object} value * @memberof module:MediaPlayer * @instance */ function setInitialMediaSettingsFor(type, value) { if (!mediaPlayerInitialized) { throw MEDIA_PLAYER_NOT_INITIALIZED_ERROR; } mediaController.setInitialSettings(type, value); } /** * This method returns media settings that is used to pick the initial track. Format of the settings * is following: * {lang: langValue, * viewpoint: viewpointValue, * audioChannelConfiguration: audioChannelConfigurationValue, * accessibility: accessibilityValue, * role: roleValue} * @param {string} type * @returns {Object} * @memberof module:MediaPlayer * @instance */ function getInitialMediaSettingsFor(type) { if (!mediaPlayerInitialized) { throw MEDIA_PLAYER_NOT_INITIALIZED_ERROR; } return mediaController.getInitialSettings(type); } /** * @param {MediaInfo} track - instance of {@link MediaInfo} * @memberof module:MediaPlayer * @instance */ function setCurrentTrack(track) { if (!streamingInitialized) { throw STREAMING_NOT_INITIALIZED_ERROR; } mediaController.setTrack(track); } /** * This method returns the current track switch mode. * * @param {string} type * @returns {string} mode * @memberof module:MediaPlayer * @instance */ function getTrackSwitchModeFor(type) { if (!mediaPlayerInitialized) { throw MEDIA_PLAYER_NOT_INITIALIZED_ERROR; } return mediaController.getSwitchMode(type); } /** * This method sets the current track switch mode. Available options are: * * MediaController.TRACK_SWITCH_MODE_NEVER_REPLACE * (used to forbid clearing the buffered data (prior to current playback position) after track switch. * Defers to fastSwitchEnabled for placement of new data. Default for video) * * MediaController.TRACK_SWITCH_MODE_ALWAYS_REPLACE * (used to clear the buffered data (prior to current playback position) after track switch. Default for audio) * * @param {string} type * @param {string} mode * @memberof module:MediaPlayer * @instance */ function setTrackSwitchModeFor(type, mode) { if (!mediaPlayerInitialized) { throw MEDIA_PLAYER_NOT_INITIALIZED_ERROR; } mediaController.setSwitchMode(type, mode); } /** * This method sets the selection mode for the initial track. This mode defines how the initial track will be selected * if no initial media settings are set. If initial media settings are set this parameter will be ignored. Available options are: * * MediaController.TRACK_SELECTION_MODE_HIGHEST_BITRATE * this mode makes the player select the track with a highest bitrate. This mode is a default mode. * * MediaController.TRACK_SELECTION_MODE_WIDEST_RANGE * this mode makes the player select the track with a widest range of bitrates * * @param {string} mode * @memberof module:MediaPlayer * @instance */ function setSelectionModeForInitialTrack(mode) { if (!mediaPlayerInitialized) { throw MEDIA_PLAYER_NOT_INITIALIZED_ERROR; } mediaController.setSelectionModeForInitialTrack(mode); } /** * This method returns the track selection mode. * * @returns {string} mode * @memberof module:MediaPlayer * @instance */ function getSelectionModeForInitialTrack() { if (!mediaPlayerInitialized) { throw MEDIA_PLAYER_NOT_INITIALIZED_ERROR; } return mediaController.getSelectionModeForInitialTrack(); } /* --------------------------------------------------------------------------- PROTECTION MANAGEMENT --------------------------------------------------------------------------- /** * Detects if Protection is included and returns an instance of ProtectionController.js * @memberof module:MediaPlayer * @instance */ function getProtectionController() { return detectProtection(); } /** * Will override dash.js protection controller. * @param {ProtectionController} value - valid protection controller instance. * @memberof module:MediaPlayer * @instance */ function attachProtectionController(value) { protectionController = value; } /** * Sets Protection Data required to setup the Protection Module (DRM). Protection Data must * be set before initializing MediaPlayer or, once initialized, before PROTECTION_CREATED event is fired. * @see {@link module:MediaPlayer#initialize initialize()} * @see {@link ProtectionEvents#event:PROTECTION_CREATED dashjs.Protection.events.PROTECTION_CREATED} * @param {ProtectionData} value - object containing * property names corresponding to key system name strings and associated * values being instances of. * @memberof module:MediaPlayer * @instance */ function setProtectionData(value) { protectionData = value; // Propagate changes in case StreamController is already created if (streamController) { streamController.setProtectionData(protectionData); } } /* --------------------------------------------------------------------------- THUMBNAILS MANAGEMENT --------------------------------------------------------------------------- */ /** * Return the thumbnail at time position. * @returns {Thumbnail|null} - Thumbnail for the given time position. It returns null in case there are is not a thumbnails representation or * if it doesn't contain a thumbnail for the given time position. * @param {number} time - A relative time, in seconds, based on the return value of the {@link module:MediaPlayer#duration duration()} method is expected * @memberof module:MediaPlayer * @instance */ function getThumbnail(time) { if (time &lt; 0) { return null; } const s = playbackController.getIsDynamic() ? getDVRSeekOffset(time) : time; const stream = streamController.getStreamForTime(s); if (stream === null) { return null; } const thumbnailController = stream.getThumbnailController(); const streamInfo = stream.getStreamInfo(); if (!thumbnailController || !streamInfo) { return null; } const timeInPeriod = streamController.getTimeRelativeToStreamId(s, stream.getId()); return thumbnailController.get(timeInPeriod); } /* --------------------------------------------------------------------------- TOOLS AND OTHERS FUNCTIONS --------------------------------------------------------------------------- */ /** * Allows application to retrieve a manifest. Manifest loading is asynchro * nous and * requires the app-provided callback function * * @param {string} url - url the manifest url * @param {function} callback - A Callback function provided when retrieving manifests * @memberof module:MediaPlayer * @instance */ function retrieveManifest(url, callback) { let manifestLoader = createManifestLoader(); let self = this; const handler = function (e) { if (!e.error) { callback(e.manifest); } else { callback(null, e.error); } eventBus.off(Events.INTERNAL_MANIFEST_LOADED, handler, self); manifestLoader.reset(); }; eventBus.on(Events.INTERNAL_MANIFEST_LOADED, handler, self); URIFragmentModel(context).getInstance().initialize(url); manifestLoader.load(url); } /** * Returns the source string or manifest that was attached by calling attachSource() * @returns {string | manifest} * @memberof module:MediaPlayer * @instance */ function getSource() { if (!source) { throw SOURCE_NOT_ATTACHED_ERROR; } return source; } /** * Use this method to set a source URL to a valid MPD manifest file OR * a previously downloaded and parsed manifest object. Optionally, can * also provide protection information * * @param {string|Object} urlOrManifest - A URL to a valid MPD manifest file, or a * parsed manifest object. * * * @throws &quot;MediaPlayer not initialized!&quot; * * @memberof module:MediaPlayer * @instance */ function attachSource(urlOrManifest) { if (!mediaPlayerInitialized) { throw MEDIA_PLAYER_NOT_INITIALIZED_ERROR; } if (typeof urlOrManifest === 'string') { URIFragmentModel(context).getInstance().initialize(urlOrManifest); } source = urlOrManifest; if (streamingInitialized || playbackInitialized) { resetPlaybackControllers(); } if (isReady()) { initializePlayback(); } } /** * A utility methods which converts UTC timestamp value into a valid time and date string. * * @param {number} time - UTC timestamp to be converted into date and time. * @param {string} locales - a region identifier (i.e. en_US). * @param {boolean} hour12 - 12 vs 24 hour. Set to true for 12 hour time formatting. * @param {boolean} withDate - default is false. Set to true to append current date to UTC time format. * @returns {string} A formatted time and date string. * @memberof module:MediaPlayer * @instance */ function formatUTC(time, locales, hour12, withDate = false) { const dt = new Date(time * 1000); const d = dt.toLocaleDateString(locales); const t = dt.toLocaleTimeString(locales, { hour12: hour12 }); return withDate ? t + ' ' + d : t; } /** * A utility method which converts seconds into TimeCode (i.e. 300 --&gt; 05:00). * * @param {number} value - A number in seconds to be converted into a formatted time code. * @returns {string} A formatted time code string. * @memberof module:MediaPlayer * @instance */ function convertToTimeCode(value) { value = Math.max(value, 0); let h = Math.floor(value / 3600); let m = Math.floor((value % 3600) / 60); let s = Math.floor((value % 3600) % 60); return (h === 0 ? '' : (h &lt; 10 ? '0' + h.toString() + ':' : h.toString() + ':')) + (m &lt; 10 ? '0' + m.toString() : m.toString()) + ':' + (s &lt; 10 ? '0' + s.toString() : s.toString()); } /** * This method should be used to extend or replace internal dash.js objects. * There are two ways to extend dash.js (determined by the override argument): * &lt;ol&gt; * &lt;li&gt;If you set override to true any public method or property in your custom object will * override the dash.js parent object's property(ies) and will be used instead but the * dash.js parent module will still be created.&lt;/li&gt; * * &lt;li&gt;If you set override to false your object will completely replace the dash.js object. * (Note: This is how it was in 1.x of Dash.js with Dijon).&lt;/li&gt; * &lt;/ol&gt; * &lt;b&gt;When you extend you get access to this.context, this.factory and this.parent to operate with in your custom object.&lt;/b&gt; * &lt;ul&gt; * &lt;li&gt;&lt;b&gt;this.context&lt;/b&gt; - can be used to pass context for singleton access.&lt;/li&gt; * &lt;li&gt;&lt;b&gt;this.factory&lt;/b&gt; - can be used to call factory.getSingletonInstance().&lt;/li&gt; * &lt;li&gt;&lt;b&gt;this.parent&lt;/b&gt; - is the reference of the parent object to call other public methods. (this.parent is excluded if you extend with override set to false or option 2)&lt;/li&gt; * &lt;/ul&gt; * &lt;b&gt;You must call extend before you call initialize&lt;/b&gt; * @see {@link module:MediaPlayer#initialize initialize()} * @param {string} parentNameString - name of parent module * @param {Object} childInstance - overriding object * @param {boolean} override - replace only some methods (true) or the whole object (false) * @memberof module:MediaPlayer * @instance */ function extend(parentNameString, childInstance, override) { FactoryMaker.extend(parentNameString, childInstance, override, context); } //*********************************** // PRIVATE METHODS //*********************************** function resetPlaybackControllers() { playbackInitialized = false; streamingInitialized = false; adapter.reset(); streamController.reset(); playbackController.reset(); abrController.reset(); mediaController.reset(); textController.reset(); if (protectionController) { protectionController.reset(); protectionController = null; detectProtection(); } } function createPlaybackControllers() { // creates or get objects instances const manifestLoader = createManifestLoader(); if (!streamController) { streamController = StreamController(context).getInstance(); } // configure controllers mediaController.setConfig({ errHandler: errHandler, domStorage: domStorage }); streamController.setConfig({ capabilities: capabilities, manifestLoader: manifestLoader, manifestModel: manifestModel, dashManifestModel: dashManifestModel, mediaPlayerModel: mediaPlayerModel, protectionController: protectionController, adapter: adapter, metricsModel: metricsModel, dashMetrics: dashMetrics, errHandler: errHandler, timelineConverter: timelineConverter, videoModel: videoModel, playbackController: playbackController, domStorage: domStorage, abrController: abrController, mediaController: mediaController, textController: textController }); playbackController.setConfig({ streamController: streamController, metricsModel: metricsModel, dashMetrics: dashMetrics, manifestModel: manifestModel, mediaPlayerModel: mediaPlayerModel, dashManifestModel: dashManifestModel, adapter: adapter, videoModel: videoModel }); abrController.setConfig({ streamController: streamController, domStorage: domStorage, mediaPlayerModel: mediaPlayerModel, metricsModel: metricsModel, dashMetrics: dashMetrics, dashManifestModel: dashManifestModel, manifestModel: manifestModel, videoModel: videoModel, adapter: adapter }); abrController.createAbrRulesCollection(); textController.setConfig({ errHandler: errHandler, manifestModel: manifestModel, dashManifestModel: dashManifestModel, mediaController: mediaController, streamController: streamController, videoModel: videoModel }); // initialises controller streamController.initialize(autoPlay, protectionData); } function createManifestLoader() { return ManifestLoader(context).create({ errHandler: errHandler, metricsModel: metricsModel, mediaPlayerModel: mediaPlayerModel, requestModifier: RequestModifier(context).getInstance(), mssHandler: mssHandler }); } function detectProtection() { if (protectionController) { return protectionController; } // do not require Protection as dependencies as this is optional and intended to be loaded separately let Protection = dashjs.Protection; /* jshint ignore:line */ if (typeof Protection === 'function') { //TODO need a better way to register/detect plugin components let protection = Protection(context).create(); Events.extend(Protection.events); MediaPlayerEvents.extend(Protection.events, { publicOnly: true }); if (!capabilities) { capabilities = Capabilities(context).getInstance(); } protectionController = protection.createProtectionSystem({ debug: debug, errHandler: errHandler, videoModel: videoModel, capabilities: capabilities, eventBus: eventBus, events: Events, BASE64: BASE64, constants: Constants }); return protectionController; } return null; } function detectMetricsReporting() { if (metricsReportingController) { return; } // do not require MetricsReporting as dependencies as this is optional and intended to be loaded separately let MetricsReporting = dashjs.MetricsReporting; /* jshint ignore:line */ if (typeof MetricsReporting === 'function') { //TODO need a better way to register/detect plugin components let metricsReporting = MetricsReporting(context).create(); metricsReportingController = metricsReporting.createMetricsReporting({ debug: debug, eventBus: eventBus, mediaElement: getVideoElement(), dashManifestModel: dashManifestModel, metricsModel: metricsModel, events: Events, constants: Constants, metricsConstants: MetricsConstants }); } } function detectMss() { if (mssHandler) { return; } // do not require MssHandler as dependencies as this is optional and intended to be loaded separately let MssHandler = dashjs.MssHandler; /* jshint ignore:line */ if (typeof MssHandler === 'function') { //TODO need a better way to register/detect plugin components mssHandler = MssHandler(context).create({ eventBus: eventBus, mediaPlayerModel: mediaPlayerModel, metricsModel: metricsModel, playbackController: playbackController, protectionController: protectionController, errHandler: errHandler, events: Events, constants: Constants, debug: debug, initSegmentType: HTTPRequest.INIT_SEGMENT_TYPE, BASE64: BASE64, ISOBoxer: ISOBoxer }); } } function getDVRInfoMetric() { let metric = metricsModel.getReadOnlyMetricsFor(Constants.VIDEO) || metricsModel.getReadOnlyMetricsFor(Constants.AUDIO); return dashMetrics.getCurrentDVRInfo(metric); } function getAsUTC(valToConvert) { let metric = getDVRInfoMetric(); let availableFrom, utcValue; if (!metric) { return 0; } availableFrom = metric.manifestInfo.availableFrom.getTime() / 1000; utcValue = valToConvert + (availableFrom + metric.range.start); return utcValue; } function getActiveStream() { if (!streamingInitialized) { throw STREAMING_NOT_INITIALIZED_ERROR; } let streamInfo = streamController.getActiveStreamInfo(); return streamInfo ? streamController.getStreamById(streamInfo.id) : null; } function initializePlayback() { if (!streamingInitialized &amp;&amp; source) { streamingInitialized = true; logger.info('Streaming Initialized'); createPlaybackControllers(); if (typeof source === 'string') { streamController.load(source); } else { streamController.loadWithManifest(source); } } if (!playbackInitialized &amp;&amp; isReady()) { playbackInitialized = true; logger.info('Playback Initialized'); } } instance = { initialize: initialize, setConfig: setConfig, on: on, off: off, extend: extend, attachView: attachView, attachSource: attachSource, isReady: isReady, preload: preload, play: play, isPaused: isPaused, pause: pause, isSeeking: isSeeking, isDynamic: isDynamic, seek: seek, setPlaybackRate: setPlaybackRate, getPlaybackRate: getPlaybackRate, setCatchUpPlaybackRate: setCatchUpPlaybackRate, getCatchUpPlaybackRate: getCatchUpPlaybackRate, setMute: setMute, isMuted: isMuted, setVolume: setVolume, getVolume: getVolume, time: time, duration: duration, timeAsUTC: timeAsUTC, durationAsUTC: durationAsUTC, getActiveStream: getActiveStream, getDVRWindowSize: getDVRWindowSize, getDVRSeekOffset: getDVRSeekOffset, convertToTimeCode: convertToTimeCode, formatUTC: formatUTC, getVersion: getVersion, getDebug: getDebug, getBufferLength: getBufferLength, getVideoContainer: getVideoContainer, getTTMLRenderingDiv: getTTMLRenderingDiv, getVideoElement: getVideoElement, getSource: getSource, setLiveDelayFragmentCount: setLiveDelayFragmentCount, setLiveDelay: setLiveDelay, getLiveDelay: getLiveDelay, getCurrentLiveLatency: getCurrentLiveLatency, useSuggestedPresentationDelay: useSuggestedPresentationDelay, enableLastBitrateCaching: enableLastBitrateCaching, enableLastMediaSettingsCaching: enableLastMediaSettingsCaching, setMaxAllowedBitrateFor: setMaxAllowedBitrateFor, getMaxAllowedBitrateFor: getMaxAllowedBitrateFor, getTopBitrateInfoFor: getTopBitrateInfoFor, setMinAllowedBitrateFor: setMinAllowedBitrateFor, getMinAllowedBitrateFor: getMinAllowedBitrateFor, setMaxAllowedRepresentationRatioFor: setMaxAllowedRepresentationRatioFor, getMaxAllowedRepresentationRatioFor: getMaxAllowedRepresentationRatioFor, setAutoPlay: setAutoPlay, getAutoPlay: getAutoPlay, setScheduleWhilePaused: setScheduleWhilePaused, getScheduleWhilePaused: getScheduleWhilePaused, getDashMetrics: getDashMetrics, getMetricsFor: getMetricsFor, getQualityFor: getQualityFor, setQualityFor: setQualityFor, updatePortalSize: updatePortalSize, getLimitBitrateByPortal: getLimitBitrateByPortal, setLimitBitrateByPortal: setLimitBitrateByPortal, getUsePixelRatioInLimitBitrateByPortal: getUsePixelRatioInLimitBitrateByPortal, setUsePixelRatioInLimitBitrateByPortal: setUsePixelRatioInLimitBitrateByPortal, setTextDefaultLanguage: setTextDefaultLanguage, getTextDefaultLanguage: getTextDefaultLanguage, setTextDefaultEnabled: setTextDefaultEnabled, getTextDefaultEnabled: getTextDefaultEnabled, enableText: enableText, enableForcedTextStreaming: enableForcedTextStreaming, isTextEnabled: isTextEnabled, setTextTrack: setTextTrack, getBitrateInfoListFor: getBitrateInfoListFor, setInitialBitrateFor: setInitialBitrateFor, getInitialBitrateFor: getInitialBitrateFor, setInitialRepresentationRatioFor: setInitialRepresentationRatioFor, getInitialRepresentationRatioFor: getInitialRepresentationRatioFor, getStreamsFromManifest: getStreamsFromManifest, getTracksFor: getTracksFor, getTracksForTypeFromManifest: getTracksForTypeFromManifest, getCurrentTrackFor: getCurrentTrackFor, setInitialMediaSettingsFor: setInitialMediaSettingsFor, getInitialMediaSettingsFor: getInitialMediaSettingsFor, setCurrentTrack: setCurrentTrack, getTrackSwitchModeFor: getTrackSwitchModeFor, setTrackSwitchModeFor: setTrackSwitchModeFor, setSelectionModeForInitialTrack: setSelectionModeForInitialTrack, getSelectionModeForInitialTrack: getSelectionModeForInitialTrack, setFastSwitchEnabled: setFastSwitchEnabled, getFastSwitchEnabled: getFastSwitchEnabled, setMovingAverageMethod: setMovingAverageMethod, getMovingAverageMethod: getMovingAverageMethod, getAutoSwitchQualityFor: getAutoSwitchQualityFor, setAutoSwitchQualityFor: setAutoSwitchQualityFor, setABRStrategy: setABRStrategy, getABRStrategy: getABRStrategy, useDefaultABRRules: useDefaultABRRules, addABRCustomRule: addABRCustomRule, removeABRCustomRule: removeABRCustomRule, removeAllABRCustomRule: removeAllABRCustomRule, setBandwidthSafetyFactor: setBandwidthSafetyFactor, getBandwidthSafetyFactor: getBandwidthSafetyFactor, getAverageThroughput: getAverageThroughput, setAbandonLoadTimeout: setAbandonLoadTimeout, retrieveManifest: retrieveManifest, addUTCTimingSource: addUTCTimingSource, removeUTCTimingSource: removeUTCTimingSource, clearDefaultUTCTimingSources: clearDefaultUTCTimingSources, restoreDefaultUTCTimingSources: restoreDefaultUTCTimingSources, setBufferToKeep: setBufferToKeep, setBufferAheadToKeep: setBufferAheadToKeep, setBufferPruningInterval: setBufferPruningInterval, setStableBufferTime: setStableBufferTime, getStableBufferTime: getStableBufferTime, setBufferTimeAtTopQuality: setBufferTimeAtTopQuality, getBufferTimeAtTopQuality: getBufferTimeAtTopQuality, setBufferTimeAtTopQualityLongForm: setBufferTimeAtTopQualityLongForm, getBufferTimeAtTopQualityLongForm: getBufferTimeAtTopQualityLongForm, setFragmentLoaderRetryAttempts: setFragmentLoaderRetryAttempts, setFragmentLoaderRetryInterval: setFragmentLoaderRetryInterval, setManifestLoaderRetryAttempts: setManifestLoaderRetryAttempts, setManifestLoaderRetryInterval: setManifestLoaderRetryInterval, setXHRWithCredentialsForType: setXHRWithCredentialsForType, getXHRWithCredentialsForType: getXHRWithCredentialsForType, setJumpGaps: setJumpGaps, getJumpGaps: getJumpGaps, setSmallGapLimit: setSmallGapLimit, getSmallGapLimit: getSmallGapLimit, getLowLatencyEnabled: getLowLatencyEnabled, setLowLatencyEnabled: setLowLatencyEnabled, setManifestUpdateRetryInterval: setManifestUpdateRetryInterval, getManifestUpdateRetryInterval: getManifestUpdateRetryInterval, setLongFormContentDurationThreshold: setLongFormContentDurationThreshold, setSegmentOverlapToleranceTime: setSegmentOverlapToleranceTime, setCacheLoadThresholdForType: setCacheLoadThresholdForType, getProtectionController: getProtectionController, attachProtectionController: attachProtectionController, setProtectionData: setProtectionData, enableManifestDateHeaderTimeSource: enableManifestDateHeaderTimeSource, displayCaptionsOnTop: displayCaptionsOnTop, attachVideoContainer: attachVideoContainer, attachTTMLRenderingDiv: attachTTMLRenderingDiv, getCurrentTextTrackIndex: getCurrentTextTrackIndex, getUseDeadTimeLatencyForAbr: getUseDeadTimeLatencyForAbr, setUseDeadTimeLatencyForAbr: setUseDeadTimeLatencyForAbr, getThumbnail: getThumbnail, reset: reset }; setup(); return instance; } MediaPlayer.__dashjs_factory_name = 'MediaPlayer'; const factory = FactoryMaker.getClassFactory(MediaPlayer); factory.events = MediaPlayerEvents; FactoryMaker.updateClassFactory(MediaPlayer.__dashjs_factory_name, factory); export default factory; × Search results Close "},"mss_MssFragmentMoofProcessor.js.html":{"id":"mss_MssFragmentMoofProcessor.js.html","title":"Source: mss/MssFragmentMoofProcessor.js","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Source: mss/MssFragmentMoofProcessor.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ /** * @module MssFragmentMoovProcessor * @param {Object} config object */ function MssFragmentMoofProcessor(config) { config = config || {}; let instance, logger; const metricsModel = config.metricsModel; const playbackController = config.playbackController; const errorHandler = config.errHandler; const ISOBoxer = config.ISOBoxer; const debug = config.debug; function setup() { logger = debug.getLogger(instance); } function processTfrf(request, tfrf, tfdt, streamProcessor) { const representationController = streamProcessor.getRepresentationController(); const representation = representationController.getCurrentRepresentation(); const indexHandler = streamProcessor.getIndexHandler(); const manifest = representation.adaptation.period.mpd.manifest; const adaptation = manifest.Period_asArray[representation.adaptation.period.index].AdaptationSet_asArray[representation.adaptation.index]; const timescale = adaptation.SegmentTemplate.timescale; if (manifest.type !== 'dynamic') { return; } if (!tfrf) { errorHandler.mssError('MSS_NO_TFRF : Missing tfrf in live media segment'); return; } // Get adaptation's segment timeline (always a SegmentTimeline in Smooth Streaming use case) const segments = adaptation.SegmentTemplate.SegmentTimeline.S; const entries = tfrf.entry; let entry, segmentTime; let segment = null; let t = 0; let availabilityStartTime = null; let range; if (entries.length === 0) { return; } // Consider only first tfrf entry (to avoid pre-condition failure on fragment info requests) entry = entries[0]; // Get last segment time segmentTime = segments[segments.length - 1].tManifest ? parseFloat(segments[segments.length - 1].tManifest) : segments[segments.length - 1].t; // Check if we have to append new segment to timeline if (entry.fragment_absolute_time &lt;= segmentTime) { // Update DVR window range // =&gt; set range end to end time of current segment range = { start: segments[0].t / adaptation.SegmentTemplate.timescale, end: (tfdt.baseMediaDecodeTime / adaptation.SegmentTemplate.timescale) + request.duration }; updateDVR(request.mediaType, range, streamProcessor.getStreamInfo().manifestInfo); return; } logger.debug('Add new segment - t = ', (entry.fragment_absolute_time / timescale)); segment = {}; segment.t = entry.fragment_absolute_time; segment.d = entry.fragment_duration; segments.push(segment); if (manifest.timeShiftBufferDepth &amp;&amp; manifest.timeShiftBufferDepth &gt; 0) { // Get timestamp of the last segment segment = segments[segments.length - 1]; t = segment.t; // Determine the segments' availability start time availabilityStartTime = t - (manifest.timeShiftBufferDepth * timescale); // Remove segments prior to availability start time segment = segments[0]; while (segment.t &lt; availabilityStartTime) { logger.debug('Remove segment - t = ' + (segment.t / timescale)); segments.splice(0, 1); segment = segments[0]; } // Update DVR window range // =&gt; set range end to end time of current segment range = { start: segments[0].t / adaptation.SegmentTemplate.timescale, end: (tfdt.baseMediaDecodeTime / adaptation.SegmentTemplate.timescale) + request.duration }; updateDVR(request.mediaType, range, streamProcessor.getStreamInfo().manifestInfo); } indexHandler.updateSegmentList(representation); } function updateDVR(type, range, manifestInfo) { const dvrInfos = metricsModel.getMetricsFor(type).DVRInfo; if (dvrInfos) { if (dvrInfos.length === 0 || (dvrInfos.length &gt; 0 &amp;&amp; range.end &gt; dvrInfos[dvrInfos.length - 1].range.end)) { logger.debug('Update DVR Infos [' + range.start + ' - ' + range.end + ']'); metricsModel.addDVRInfo(type, playbackController.getTime(), manifestInfo, range); } } } // This function returns the offset of the 1st byte of a child box within a container box function getBoxOffset(parent, type) { let offset = 8; let i = 0; for (i = 0; i &lt; parent.boxes.length; i++) { if (parent.boxes[i].type === type) { return offset; } offset += parent.boxes[i].size; } return offset; } function convertFragment(e, sp) { let i; // e.request contains request description object // e.response contains fragment bytes const isoFile = ISOBoxer.parseBuffer(e.response); // Update track_Id in tfhd box const tfhd = isoFile.fetch('tfhd'); tfhd.track_ID = e.request.mediaInfo.index + 1; // Add tfdt box let tfdt = isoFile.fetch('tfdt'); const traf = isoFile.fetch('traf'); if (tfdt === null) { tfdt = ISOBoxer.createFullBox('tfdt', traf, tfhd); tfdt.version = 1; tfdt.flags = 0; tfdt.baseMediaDecodeTime = Math.floor(e.request.startTime * e.request.timescale); } const trun = isoFile.fetch('trun'); // Process tfxd boxes // This box provide absolute timestamp but we take the segment start time for tfdt let tfxd = isoFile.fetch('tfxd'); if (tfxd) { tfxd._parent.boxes.splice(tfxd._parent.boxes.indexOf(tfxd), 1); tfxd = null; } let tfrf = isoFile.fetch('tfrf'); processTfrf(e.request, tfrf, tfdt, sp); if (tfrf) { tfrf._parent.boxes.splice(tfrf._parent.boxes.indexOf(tfrf), 1); tfrf = null; } // If protected content in PIFF1.1 format (sepiff box = Sample Encryption PIFF) // =&gt; convert sepiff box it into a senc box // =&gt; create saio and saiz boxes (if not already present) const sepiff = isoFile.fetch('sepiff'); if (sepiff !== null) { sepiff.type = 'senc'; sepiff.usertype = undefined; let saio = isoFile.fetch('saio'); if (saio === null) { // Create Sample Auxiliary Information Offsets Box box (saio) saio = ISOBoxer.createFullBox('saio', traf); saio.version = 0; saio.flags = 0; saio.entry_count = 1; saio.offset = [0]; const saiz = ISOBoxer.createFullBox('saiz', traf); saiz.version = 0; saiz.flags = 0; saiz.sample_count = sepiff.sample_count; saiz.default_sample_info_size = 0; saiz.sample_info_size = []; if (sepiff.flags &amp; 0x02) { // Sub-sample encryption =&gt; set sample_info_size for each sample for (i = 0; i &lt; sepiff.sample_count; i += 1) { // 10 = 8 (InitializationVector field size) + 2 (subsample_count field size) // 6 = 2 (BytesOfClearData field size) + 4 (BytesOfEncryptedData field size) saiz.sample_info_size[i] = 10 + (6 * sepiff.entry[i].NumberOfEntries); } } else { // No sub-sample encryption =&gt; set default sample_info_size = InitializationVector field size (8) saiz.default_sample_info_size = 8; } } } tfhd.flags &amp;= 0xFFFFFE; // set tfhd.base-data-offset-present to false tfhd.flags |= 0x020000; // set tfhd.default-base-is-moof to true trun.flags |= 0x000001; // set trun.data-offset-present to true // Update trun.data_offset field that corresponds to first data byte (inside mdat box) const moof = isoFile.fetch('moof'); let length = moof.getLength(); trun.data_offset = length + 8; // Update saio box offset field according to new senc box offset let saio = isoFile.fetch('saio'); if (saio !== null) { let trafPosInMoof = getBoxOffset(moof, 'traf'); let sencPosInTraf = getBoxOffset(traf, 'senc'); // Set offset from begin fragment to the first IV field in senc box saio.offset[0] = trafPosInMoof + sencPosInTraf + 16; // 16 = box header (12) + sample_count field size (4) } // Write transformed/processed fragment into request reponse data e.response = isoFile.write(); } function updateSegmentList(e, sp) { // e.request contains request description object // e.response contains fragment bytes if (!e.response) { throw new Error('e.response parameter is missing'); } const isoFile = ISOBoxer.parseBuffer(e.response); // Update track_Id in tfhd box const tfhd = isoFile.fetch('tfhd'); tfhd.track_ID = e.request.mediaInfo.index + 1; // Add tfdt box let tfdt = isoFile.fetch('tfdt'); let traf = isoFile.fetch('traf'); if (tfdt === null) { tfdt = ISOBoxer.createFullBox('tfdt', traf, tfhd); tfdt.version = 1; tfdt.flags = 0; tfdt.baseMediaDecodeTime = Math.floor(e.request.startTime * e.request.timescale); } let tfrf = isoFile.fetch('tfrf'); processTfrf(e.request, tfrf, tfdt, sp); if (tfrf) { tfrf._parent.boxes.splice(tfrf._parent.boxes.indexOf(tfrf), 1); tfrf = null; } } instance = { convertFragment: convertFragment, updateSegmentList: updateSegmentList }; setup(); return instance; } MssFragmentMoofProcessor.__dashjs_factory_name = 'MssFragmentMoofProcessor'; export default dashjs.FactoryMaker.getClassFactory(MssFragmentMoofProcessor); /* jshint ignore:line */ × Search results Close "},"mss_MssFragmentMoovProcessor.js.html":{"id":"mss_MssFragmentMoovProcessor.js.html","title":"Source: mss/MssFragmentMoovProcessor.js","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Source: mss/MssFragmentMoovProcessor.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ /** * @module MssFragmentMoovProcessor * @param {Object} config object */ function MssFragmentMoovProcessor(config) { config = config || {}; const NALUTYPE_SPS = 7; const NALUTYPE_PPS = 8; const constants = config.constants; const ISOBoxer = config.ISOBoxer; let protectionController = config.protectionController; let instance, period, adaptationSet, representation, contentProtection, timescale, trackId; function createFtypBox(isoFile) { let ftyp = ISOBoxer.createBox('ftyp', isoFile); ftyp.major_brand = 'iso6'; ftyp.minor_version = 1; // is an informative integer for the minor version of the major brand ftyp.compatible_brands = []; //is a list, to the end of the box, of brands isom, iso6 and msdh ftyp.compatible_brands[0] = 'isom'; // =&gt; decimal ASCII value for isom ftyp.compatible_brands[1] = 'iso6'; // =&gt; decimal ASCII value for iso6 ftyp.compatible_brands[2] = 'msdh'; // =&gt; decimal ASCII value for msdh return ftyp; } function createMoovBox(isoFile) { // moov box let moov = ISOBoxer.createBox('moov', isoFile); // moov/mvhd createMvhdBox(moov); // moov/trak let trak = ISOBoxer.createBox('trak', moov); // moov/trak/tkhd createTkhdBox(trak); // moov/trak/mdia let mdia = ISOBoxer.createBox('mdia', trak); // moov/trak/mdia/mdhd createMdhdBox(mdia); // moov/trak/mdia/hdlr createHdlrBox(mdia); // moov/trak/mdia/minf let minf = ISOBoxer.createBox('minf', mdia); switch (adaptationSet.type) { case constants.VIDEO: // moov/trak/mdia/minf/vmhd createVmhdBox(minf); break; case constants.AUDIO: // moov/trak/mdia/minf/smhd createSmhdBox(minf); break; default: break; } // moov/trak/mdia/minf/dinf let dinf = ISOBoxer.createBox('dinf', minf); // moov/trak/mdia/minf/dinf/dref createDrefBox(dinf); // moov/trak/mdia/minf/stbl let stbl = ISOBoxer.createBox('stbl', minf); // Create empty stts, stsc, stco and stsz boxes // Use data field as for codem-isoboxer unknown boxes for setting fields value // moov/trak/mdia/minf/stbl/stts let stts = ISOBoxer.createFullBox('stts', stbl); stts._data = [0, 0, 0, 0, 0, 0, 0, 0]; // version = 0, flags = 0, entry_count = 0 // moov/trak/mdia/minf/stbl/stsc let stsc = ISOBoxer.createFullBox('stsc', stbl); stsc._data = [0, 0, 0, 0, 0, 0, 0, 0]; // version = 0, flags = 0, entry_count = 0 // moov/trak/mdia/minf/stbl/stco let stco = ISOBoxer.createFullBox('stco', stbl); stco._data = [0, 0, 0, 0, 0, 0, 0, 0]; // version = 0, flags = 0, entry_count = 0 // moov/trak/mdia/minf/stbl/stsz let stsz = ISOBoxer.createFullBox('stsz', stbl); stsz._data = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]; // version = 0, flags = 0, sample_size = 0, sample_count = 0 // moov/trak/mdia/minf/stbl/stsd createStsdBox(stbl); // moov/mvex let mvex = ISOBoxer.createBox('mvex', moov); // moov/mvex/trex createTrexBox(mvex); if (contentProtection &amp;&amp; protectionController) { let supportedKS = protectionController.getSupportedKeySystemsFromContentProtection(contentProtection); createProtectionSystemSpecificHeaderBox(moov, supportedKS); } } function createMvhdBox(moov) { let mvhd = ISOBoxer.createFullBox('mvhd', moov); mvhd.version = 1; // version = 1 in order to have 64bits duration value mvhd.creation_time = 0; // the creation time of the presentation =&gt; ignore (set to 0) mvhd.modification_time = 0; // the most recent time the presentation was modified =&gt; ignore (set to 0) mvhd.timescale = timescale; // the time-scale for the entire presentation =&gt; 10000000 for MSS mvhd.duration = Math.round(period.duration * timescale); // the length of the presentation (in the indicated timescale) =&gt; take duration of period mvhd.rate = 1.0; // 16.16 number, '1.0' = normal playback mvhd.volume = 1.0; // 8.8 number, '1.0' = full volume mvhd.reserved1 = 0; mvhd.reserved2 = [0x0, 0x0]; mvhd.matrix = [ 1, 0, 0, // provides a transformation matrix for the video; 0, 1, 0, // (u,v,w) are restricted here to (0,0,1) 0, 0, 16384 ]; mvhd.pre_defined = [0, 0, 0, 0, 0, 0]; mvhd.next_track_ID = trackId + 1; // indicates a value to use for the track ID of the next track to be added to this presentation return mvhd; } function createTkhdBox(trak) { let tkhd = ISOBoxer.createFullBox('tkhd', trak); tkhd.version = 1; // version = 1 in order to have 64bits duration value tkhd.flags = 0x1 | // Track_enabled (0x000001): Indicates that the track is enabled 0x2 | // Track_in_movie (0x000002): Indicates that the track is used in the presentation 0x4; // Track_in_preview (0x000004): Indicates that the track is used when previewing the presentation tkhd.creation_time = 0; // the creation time of the presentation =&gt; ignore (set to 0) tkhd.modification_time = 0; // the most recent time the presentation was modified =&gt; ignore (set to 0) tkhd.track_ID = trackId; // uniquely identifies this track over the entire life-time of this presentation tkhd.reserved1 = 0; tkhd.duration = Math.round(period.duration * timescale); // the duration of this track (in the timescale indicated in the Movie Header Box) =&gt; take duration of period tkhd.reserved2 = [0x0, 0x0]; tkhd.layer = 0; // specifies the front-to-back ordering of video tracks; tracks with lower numbers are closer to the viewer =&gt; 0 since only one video track tkhd.alternate_group = 0; // specifies a group or collection of tracks =&gt; ignore tkhd.volume = 1.0; // '1.0' = full volume tkhd.reserved3 = 0; tkhd.matrix = [ 1, 0, 0, // provides a transformation matrix for the video; 0, 1, 0, // (u,v,w) are restricted here to (0,0,1) 0, 0, 16384 ]; tkhd.width = representation.width; // visual presentation width tkhd.height = representation.height; // visual presentation height return tkhd; } function createMdhdBox(mdia) { let mdhd = ISOBoxer.createFullBox('mdhd', mdia); mdhd.version = 1; // version = 1 in order to have 64bits duration value mdhd.creation_time = 0; // the creation time of the presentation =&gt; ignore (set to 0) mdhd.modification_time = 0; // the most recent time the presentation was modified =&gt; ignore (set to 0) mdhd.timescale = timescale; // the time-scale for the entire presentation mdhd.duration = Math.round(period.duration * timescale); // the duration of this media (in the scale of the timescale). If the duration cannot be determined then duration is set to all 1s. mdhd.language = adaptationSet.lang || 'und'; // declares the language code for this media (see getLanguageCode()) mdhd.pre_defined = 0; return mdhd; } function createHdlrBox(mdia) { let hdlr = ISOBoxer.createFullBox('hdlr', mdia); hdlr.pre_defined = 0; switch (adaptationSet.type) { case constants.VIDEO: hdlr.handler_type = 'vide'; break; case constants.AUDIO: hdlr.handler_type = 'soun'; break; default: hdlr.handler_type = 'meta'; break; } hdlr.name = representation.id; hdlr.reserved = [0, 0, 0]; return hdlr; } function createVmhdBox(minf) { let vmhd = ISOBoxer.createFullBox('vmhd', minf); vmhd.flags = 1; vmhd.graphicsmode = 0; // specifies a composition mode for this video track, from the following enumerated set, which may be extended by derived specifications: copy = 0 copy over the existing image vmhd.opcolor = [0, 0, 0]; // is a set of 3 colour values (red, green, blue) available for use by graphics modes return vmhd; } function createSmhdBox(minf) { let smhd = ISOBoxer.createFullBox('smhd', minf); smhd.flags = 1; smhd.balance = 0; // is a fixed-point 8.8 number that places mono audio tracks in a stereo space; 0 is centre (the normal value); full left is -1.0 and full right is 1.0. smhd.reserved = 0; return smhd; } function createDrefBox(dinf) { let dref = ISOBoxer.createFullBox('dref', dinf); dref.entry_count = 1; dref.entries = []; let url = ISOBoxer.createFullBox('url ', dref, false); url.location = ''; url.flags = 1; dref.entries.push(url); return dref; } function createStsdBox(stbl) { let stsd = ISOBoxer.createFullBox('stsd', stbl); stsd.entries = []; switch (adaptationSet.type) { case constants.VIDEO: case constants.AUDIO: stsd.entries.push(createSampleEntry(stsd)); break; default: break; } stsd.entry_count = stsd.entries.length; // is an integer that counts the actual entries return stsd; } function createSampleEntry(stsd) { let codec = representation.codecs.substring(0, representation.codecs.indexOf('.')); switch (codec) { case 'avc1': return createAVCVisualSampleEntry(stsd, codec); case 'mp4a': return createMP4AudioSampleEntry(stsd, codec); default: throw { name: 'Unsupported codec', message: 'Unsupported codec', data: { codec: codec } }; } } function createAVCVisualSampleEntry(stsd, codec) { let avc1; if (contentProtection) { avc1 = ISOBoxer.createBox('encv', stsd, false); } else { avc1 = ISOBoxer.createBox('avc1', stsd, false); } // SampleEntry fields avc1.reserved1 = [0x0, 0x0, 0x0, 0x0, 0x0, 0x0]; avc1.data_reference_index = 1; // VisualSampleEntry fields avc1.pre_defined1 = 0; avc1.reserved2 = 0; avc1.pre_defined2 = [0, 0, 0]; avc1.height = representation.height; avc1.width = representation.width; avc1.horizresolution = 72; // 72 dpi avc1.vertresolution = 72; // 72 dpi avc1.reserved3 = 0; avc1.frame_count = 1; // 1 compressed video frame per sample avc1.compressorname = [ 0x0A, 0x41, 0x56, 0x43, 0x20, 0x43, 0x6F, 0x64, // = 'AVC Coding'; 0x69, 0x6E, 0x67, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 ]; avc1.depth = 0x0018; // 0x0018 – images are in colour with no alpha. avc1.pre_defined3 = 65535; avc1.config = createAVC1ConfigurationRecord(); if (contentProtection) { // Create and add Protection Scheme Info Box let sinf = ISOBoxer.createBox('sinf', avc1); // Create and add Original Format Box =&gt; indicate codec type of the encrypted content createOriginalFormatBox(sinf, codec); // Create and add Scheme Type box createSchemeTypeBox(sinf); // Create and add Scheme Information Box createSchemeInformationBox(sinf); } return avc1; } function createAVC1ConfigurationRecord() { let avcC = null; let avcCLength = 15; // length = 15 by default (0 SPS and 0 PPS) // First get all SPS and PPS from codecPrivateData let sps = []; let pps = []; let AVCProfileIndication = 0; let AVCLevelIndication = 0; let profile_compatibility = 0; let nalus = representation.codecPrivateData.split('00000001').slice(1); let naluBytes, naluType; for (let i = 0; i &lt; nalus.length; i++) { naluBytes = hexStringtoBuffer(nalus[i]); naluType = naluBytes[0] &amp; 0x1F; switch (naluType) { case NALUTYPE_SPS: sps.push(naluBytes); avcCLength += naluBytes.length + 2; // 2 = sequenceParameterSetLength field length break; case NALUTYPE_PPS: pps.push(naluBytes); avcCLength += naluBytes.length + 2; // 2 = pictureParameterSetLength field length break; default: break; } } // Get profile and level from SPS if (sps.length &gt; 0) { AVCProfileIndication = sps[0][1]; profile_compatibility = sps[0][2]; AVCLevelIndication = sps[0][3]; } // Generate avcC buffer avcC = new Uint8Array(avcCLength); let i = 0; // length avcC[i++] = (avcCLength &amp; 0xFF000000) &gt;&gt; 24; avcC[i++] = (avcCLength &amp; 0x00FF0000) &gt;&gt; 16; avcC[i++] = (avcCLength &amp; 0x0000FF00) &gt;&gt; 8; avcC[i++] = (avcCLength &amp; 0x000000FF); avcC.set([0x61, 0x76, 0x63, 0x43], i); // type = 'avcC' i += 4; avcC[i++] = 1; // configurationVersion = 1 avcC[i++] = AVCProfileIndication; avcC[i++] = profile_compatibility; avcC[i++] = AVCLevelIndication; avcC[i++] = 0xFF; // '11111' + lengthSizeMinusOne = 3 avcC[i++] = 0xE0 | sps.length; // '111' + numOfSequenceParameterSets for (let n = 0; n &lt; sps.length; n++) { avcC[i++] = (sps[n].length &amp; 0xFF00) &gt;&gt; 8; avcC[i++] = (sps[n].length &amp; 0x00FF); avcC.set(sps[n], i); i += sps[n].length; } avcC[i++] = pps.length; // numOfPictureParameterSets for (let n = 0; n &lt; pps.length; n++) { avcC[i++] = (pps[n].length &amp; 0xFF00) &gt;&gt; 8; avcC[i++] = (pps[n].length &amp; 0x00FF); avcC.set(pps[n], i); i += pps[n].length; } return avcC; } function createMP4AudioSampleEntry(stsd, codec) { let mp4a; if (contentProtection) { mp4a = ISOBoxer.createBox('enca', stsd, false); } else { mp4a = ISOBoxer.createBox('mp4a', stsd, false); } // SampleEntry fields mp4a.reserved1 = [0x0, 0x0, 0x0, 0x0, 0x0, 0x0]; mp4a.data_reference_index = 1; // AudioSampleEntry fields mp4a.reserved2 = [0x0, 0x0]; mp4a.channelcount = representation.audioChannels; mp4a.samplesize = 16; mp4a.pre_defined = 0; mp4a.reserved_3 = 0; mp4a.samplerate = representation.audioSamplingRate &lt;&lt; 16; mp4a.esds = createMPEG4AACESDescriptor(); if (contentProtection) { // Create and add Protection Scheme Info Box let sinf = ISOBoxer.createBox('sinf', mp4a); // Create and add Original Format Box =&gt; indicate codec type of the encrypted content createOriginalFormatBox(sinf, codec); // Create and add Scheme Type box createSchemeTypeBox(sinf); // Create and add Scheme Information Box createSchemeInformationBox(sinf); } return mp4a; } function createMPEG4AACESDescriptor() { // AudioSpecificConfig (see ISO/IEC 14496-3, subpart 1) =&gt; corresponds to hex bytes contained in 'codecPrivateData' field let audioSpecificConfig = hexStringtoBuffer(representation.codecPrivateData); // ESDS length = esds box header length (= 12) + // ES_Descriptor header length (= 5) + // DecoderConfigDescriptor header length (= 15) + // decoderSpecificInfo header length (= 2) + // AudioSpecificConfig length (= codecPrivateData length) let esdsLength = 34 + audioSpecificConfig.length; let esds = new Uint8Array(esdsLength); let i = 0; // esds box esds[i++] = (esdsLength &amp; 0xFF000000) &gt;&gt; 24; // esds box length esds[i++] = (esdsLength &amp; 0x00FF0000) &gt;&gt; 16; // '' esds[i++] = (esdsLength &amp; 0x0000FF00) &gt;&gt; 8; // '' esds[i++] = (esdsLength &amp; 0x000000FF); // '' esds.set([0x65, 0x73, 0x64, 0x73], i); // type = 'esds' i += 4; esds.set([0, 0, 0, 0], i); // version = 0, flags = 0 i += 4; // ES_Descriptor (see ISO/IEC 14496-1 (Systems)) esds[i++] = 0x03; // tag = 0x03 (ES_DescrTag) esds[i++] = 20 + audioSpecificConfig.length; // size esds[i++] = (trackId &amp; 0xFF00) &gt;&gt; 8; // ES_ID = track_id esds[i++] = (trackId &amp; 0x00FF); // '' esds[i++] = 0; // flags and streamPriority // DecoderConfigDescriptor (see ISO/IEC 14496-1 (Systems)) esds[i++] = 0x04; // tag = 0x04 (DecoderConfigDescrTag) esds[i++] = 15 + audioSpecificConfig.length; // size esds[i++] = 0x40; // objectTypeIndication = 0x40 (MPEG-4 AAC) esds[i] = 0x05 &lt;&lt; 2; // streamType = 0x05 (Audiostream) esds[i] |= 0 &lt;&lt; 1; // upStream = 0 esds[i++] |= 1; // reserved = 1 esds[i++] = 0xFF; // buffersizeDB = undefined esds[i++] = 0xFF; // '' esds[i++] = 0xFF; // '' esds[i++] = (representation.bandwidth &amp; 0xFF000000) &gt;&gt; 24; // maxBitrate esds[i++] = (representation.bandwidth &amp; 0x00FF0000) &gt;&gt; 16; // '' esds[i++] = (representation.bandwidth &amp; 0x0000FF00) &gt;&gt; 8; // '' esds[i++] = (representation.bandwidth &amp; 0x000000FF); // '' esds[i++] = (representation.bandwidth &amp; 0xFF000000) &gt;&gt; 24; // avgbitrate esds[i++] = (representation.bandwidth &amp; 0x00FF0000) &gt;&gt; 16; // '' esds[i++] = (representation.bandwidth &amp; 0x0000FF00) &gt;&gt; 8; // '' esds[i++] = (representation.bandwidth &amp; 0x000000FF); // '' // DecoderSpecificInfo (see ISO/IEC 14496-1 (Systems)) esds[i++] = 0x05; // tag = 0x05 (DecSpecificInfoTag) esds[i++] = audioSpecificConfig.length; // size esds.set(audioSpecificConfig, i); // AudioSpecificConfig bytes return esds; } function createOriginalFormatBox(sinf, codec) { let frma = ISOBoxer.createBox('frma', sinf); frma.data_format = stringToCharCode(codec); } function createSchemeTypeBox(sinf) { let schm = ISOBoxer.createFullBox('schm', sinf); schm.flags = 0; schm.version = 0; schm.scheme_type = 0x63656E63; // 'cenc' =&gt; common encryption schm.scheme_version = 0x00010000; // version set to 0x00010000 (Major version 1, Minor version 0) } function createSchemeInformationBox(sinf) { let schi = ISOBoxer.createBox('schi', sinf); // Create and add Track Encryption Box createTrackEncryptionBox(schi); } function createProtectionSystemSpecificHeaderBox(moov, keySystems) { let pssh_bytes; let pssh; let i; let parsedBuffer; for (i = 0; i &lt; keySystems.length; i += 1) { pssh_bytes = keySystems[i].initData; parsedBuffer = ISOBoxer.parseBuffer(pssh_bytes); pssh = parsedBuffer.fetch('pssh'); if (pssh) { ISOBoxer.Utils.appendBox(moov, pssh); } } } function createTrackEncryptionBox(schi) { let tenc = ISOBoxer.createFullBox('tenc', schi); tenc.flags = 0; tenc.version = 0; tenc.default_IsEncrypted = 0x1; tenc.default_IV_size = 8; tenc.default_KID = (contentProtection &amp;&amp; (contentProtection.length) &gt; 0 &amp;&amp; contentProtection[0]['cenc:default_KID']) ? contentProtection[0]['cenc:default_KID'] : [0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0]; } function createTrexBox(moov) { let trex = ISOBoxer.createFullBox('trex', moov); trex.track_ID = trackId; trex.default_sample_description_index = 1; trex.default_sample_duration = 0; trex.default_sample_size = 0; trex.default_sample_flags = 0; return trex; } function hexStringtoBuffer(str) { let buf = new Uint8Array(str.length / 2); let i; for (i = 0; i &lt; str.length / 2; i += 1) { buf[i] = parseInt('' + str[i * 2] + str[i * 2 + 1], 16); } return buf; } function stringToCharCode(str) { let code = 0; let i; for (i = 0; i &lt; str.length; i += 1) { code |= str.charCodeAt(i) &lt;&lt; ((str.length - i - 1) * 8); } return code; } function generateMoov(rep) { if (!rep || !rep.adaptation) { return; } let isoFile, arrayBuffer; representation = rep; adaptationSet = representation.adaptation; period = adaptationSet.period; trackId = adaptationSet.index + 1; contentProtection = period.mpd.manifest.Period_asArray[period.index].AdaptationSet_asArray[adaptationSet.index].ContentProtection; timescale = period.mpd.manifest.Period_asArray[period.index].AdaptationSet_asArray[adaptationSet.index].SegmentTemplate.timescale; isoFile = ISOBoxer.createFile(); createFtypBox(isoFile); createMoovBox(isoFile); arrayBuffer = isoFile.write(); return arrayBuffer; } instance = { generateMoov: generateMoov }; return instance; } MssFragmentMoovProcessor.__dashjs_factory_name = 'MssFragmentMoovProcessor'; export default dashjs.FactoryMaker.getClassFactory(MssFragmentMoovProcessor); /* jshint ignore:line */ × Search results Close "},"mss_parser_MssParser.js.html":{"id":"mss_parser_MssParser.js.html","title":"Source: mss/parser/MssParser.js","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Source: mss/parser/MssParser.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ /** * @module MssParser * @param {Object} config object */ function MssParser(config) { config = config || {}; const BASE64 = config.BASE64; const debug = config.debug; const constants = config.constants; const DEFAULT_TIME_SCALE = 10000000.0; const SUPPORTED_CODECS = ['AAC', 'AACL', 'AVC1', 'H264', 'TTML', 'DFXP']; // MPEG-DASH Role and accessibility mapping according to ETSI TS 103 285 v1.1.1 (section 7.1.2) const ROLE = { 'SUBT': 'alternate', 'CAPT': 'alternate', // 'CAPT' is commonly equivalent to 'SUBT' 'DESC': 'main' }; const ACCESSIBILITY = { 'DESC': '2' }; const samplingFrequencyIndex = { 96000: 0x0, 88200: 0x1, 64000: 0x2, 48000: 0x3, 44100: 0x4, 32000: 0x5, 24000: 0x6, 22050: 0x7, 16000: 0x8, 12000: 0x9, 11025: 0xA, 8000: 0xB, 7350: 0xC }; const mimeTypeMap = { 'video': 'video/mp4', 'audio': 'audio/mp4', 'text': 'application/mp4' }; let instance, logger, mediaPlayerModel; function setup() { logger = debug.getLogger(instance); mediaPlayerModel = config.mediaPlayerModel; } function mapPeriod(smoothStreamingMedia, timescale) { const period = {}; let streams, adaptation; // For each StreamIndex node, create an AdaptationSet element period.AdaptationSet_asArray = []; streams = smoothStreamingMedia.getElementsByTagName('StreamIndex'); for (let i = 0; i &lt; streams.length; i++) { adaptation = mapAdaptationSet(streams[i], timescale); if (adaptation !== null) { period.AdaptationSet_asArray.push(adaptation); } } if (period.AdaptationSet_asArray.length &gt; 0) { period.AdaptationSet = (period.AdaptationSet_asArray.length &gt; 1) ? period.AdaptationSet_asArray : period.AdaptationSet_asArray[0]; } return period; } function mapAdaptationSet(streamIndex, timescale) { const adaptationSet = {}; const representations = []; let segmentTemplate; let qualityLevels, representation, segments, i; adaptationSet.id = streamIndex.getAttribute('Name') ? streamIndex.getAttribute('Name') : streamIndex.getAttribute('Type'); adaptationSet.contentType = streamIndex.getAttribute('Type'); adaptationSet.lang = streamIndex.getAttribute('Language') || 'und'; adaptationSet.mimeType = mimeTypeMap[adaptationSet.contentType]; adaptationSet.subType = streamIndex.getAttribute('Subtype'); adaptationSet.maxWidth = streamIndex.getAttribute('MaxWidth'); adaptationSet.maxHeight = streamIndex.getAttribute('MaxHeight'); // Map subTypes to MPEG-DASH AdaptationSet role and accessibility (see ETSI TS 103 285 v1.1.1, section 7.1.2) if (adaptationSet.subType) { if (ROLE[adaptationSet.subType]) { let role = { schemeIdUri: 'urn:mpeg:dash:role:2011', value: ROLE[adaptationSet.subType] }; adaptationSet.Role = role; adaptationSet.Role_asArray = [role]; } if (ACCESSIBILITY[adaptationSet.subType]) { let accessibility = { schemeIdUri: 'urn:tva:metadata:cs:AudioPurposeCS:2007', value: ACCESSIBILITY[adaptationSet.subType] }; adaptationSet.Accessibility = accessibility; adaptationSet.Accessibility_asArray = [accessibility]; } } // Create a SegmentTemplate with a SegmentTimeline segmentTemplate = mapSegmentTemplate(streamIndex, timescale); qualityLevels = streamIndex.getElementsByTagName('QualityLevel'); // For each QualityLevel node, create a Representation element for (i = 0; i &lt; qualityLevels.length; i++) { // Propagate BaseURL and mimeType qualityLevels[i].BaseURL = adaptationSet.BaseURL; qualityLevels[i].mimeType = adaptationSet.mimeType; // Set quality level id qualityLevels[i].Id = adaptationSet.id + '_' + qualityLevels[i].getAttribute('Index'); // Map Representation to QualityLevel representation = mapRepresentation(qualityLevels[i], streamIndex); if (representation !== null) { // Copy SegmentTemplate into Representation representation.SegmentTemplate = segmentTemplate; representations.push(representation); } } if (representations.length === 0) { return null; } adaptationSet.Representation = (representations.length &gt; 1) ? representations : representations[0]; adaptationSet.Representation_asArray = representations; // Set SegmentTemplate adaptationSet.SegmentTemplate = segmentTemplate; segments = segmentTemplate.SegmentTimeline.S_asArray; return adaptationSet; } function mapRepresentation(qualityLevel, streamIndex) { const representation = {}; const type = streamIndex.getAttribute('Type'); let fourCCValue = null; representation.id = qualityLevel.Id; representation.bandwidth = parseInt(qualityLevel.getAttribute('Bitrate'), 10); representation.mimeType = qualityLevel.mimeType; representation.width = parseInt(qualityLevel.getAttribute('MaxWidth'), 10); representation.height = parseInt(qualityLevel.getAttribute('MaxHeight'), 10); fourCCValue = qualityLevel.getAttribute('FourCC'); // If FourCC not defined at QualityLevel level, then get it from StreamIndex level if (fourCCValue === null || fourCCValue === '') { fourCCValue = streamIndex.getAttribute('FourCC'); } // If still not defined (optionnal for audio stream, see https://msdn.microsoft.com/en-us/library/ff728116%28v=vs.95%29.aspx), // then we consider the stream is an audio AAC stream if (fourCCValue === null || fourCCValue === '') { if (type === 'audio') { fourCCValue = 'AAC'; } else if (type === 'video') { logger.debug('FourCC is not defined whereas it is required for a QualityLevel element for a StreamIndex of type &quot;video&quot;'); return null; } } // Check if codec is supported if (SUPPORTED_CODECS.indexOf(fourCCValue.toUpperCase()) === -1) { // Do not send warning //this.errHandler.sendWarning(MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_ERR_CODEC_UNSUPPORTED, 'Codec not supported', {codec: fourCCValue}); logger.warn('Codec not supported: ' + fourCCValue); return null; } // Get codecs value according to FourCC field if (fourCCValue === 'H264' || fourCCValue === 'AVC1') { representation.codecs = getH264Codec(qualityLevel); } else if (fourCCValue.indexOf('AAC') &gt;= 0) { representation.codecs = getAACCodec(qualityLevel, fourCCValue); representation.audioSamplingRate = parseInt(qualityLevel.getAttribute('SamplingRate'), 10); representation.audioChannels = parseInt(qualityLevel.getAttribute('Channels'), 10); } else if (fourCCValue.indexOf('TTML') || fourCCValue.indexOf('DFXP')) { representation.codecs = constants.STPP; } representation.codecPrivateData = '' + qualityLevel.getAttribute('CodecPrivateData'); representation.BaseURL = qualityLevel.BaseURL; return representation; } function getH264Codec(qualityLevel) { let codecPrivateData = qualityLevel.getAttribute('CodecPrivateData').toString(); let nalHeader, avcoti; // Extract from the CodecPrivateData field the hexadecimal representation of the following // three bytes in the sequence parameter set NAL unit. // =&gt; Find the SPS nal header nalHeader = /00000001[0-9]7/.exec(codecPrivateData); // =&gt; Find the 6 characters after the SPS nalHeader (if it exists) avcoti = nalHeader &amp;&amp; nalHeader[0] ? (codecPrivateData.substr(codecPrivateData.indexOf(nalHeader[0]) + 10, 6)) : undefined; return 'avc1.' + avcoti; } function getAACCodec(qualityLevel, fourCCValue) { const samplingRate = parseInt(qualityLevel.getAttribute('SamplingRate'), 10); let codecPrivateData = qualityLevel.getAttribute('CodecPrivateData').toString(); let objectType = 0; let codecPrivateDataHex, arr16, indexFreq, extensionSamplingFrequencyIndex; //chrome problem, in implicit AAC HE definition, so when AACH is detected in FourCC //set objectType to 5 =&gt; strange, it should be 2 if (fourCCValue === 'AACH') { objectType = 0x05; } //if codecPrivateData is empty, build it : if (codecPrivateData === undefined || codecPrivateData === '') { objectType = 0x02; //AAC Main Low Complexity =&gt; object Type = 2 indexFreq = samplingFrequencyIndex[samplingRate]; if (fourCCValue === 'AACH') { // 4 bytes : XXXXX XXXX XXXX XXXX XXXXX XXX XXXXXXX // ' ObjectType' 'Freq Index' 'Channels value' 'Extens Sampl Freq' 'ObjectType' 'GAS' 'alignment = 0' objectType = 0x05; // High Efficiency AAC Profile = object Type = 5 SBR codecPrivateData = new Uint8Array(4); extensionSamplingFrequencyIndex = samplingFrequencyIndex[samplingRate * 2]; // in HE AAC Extension Sampling frequence // equals to SamplingRate*2 //Freq Index is present for 3 bits in the first byte, last bit is in the second codecPrivateData[0] = (objectType &lt;&lt; 3) | (indexFreq &gt;&gt; 1); codecPrivateData[1] = (indexFreq &lt;&lt; 7) | (qualityLevel.Channels &lt;&lt; 3) | (extensionSamplingFrequencyIndex &gt;&gt; 1); codecPrivateData[2] = (extensionSamplingFrequencyIndex &lt;&lt; 7) | (0x02 &lt;&lt; 2); // origin object type equals to 2 =&gt; AAC Main Low Complexity codecPrivateData[3] = 0x0; //alignment bits arr16 = new Uint16Array(2); arr16[0] = (codecPrivateData[0] &lt;&lt; 8) + codecPrivateData[1]; arr16[1] = (codecPrivateData[2] &lt;&lt; 8) + codecPrivateData[3]; //convert decimal to hex value codecPrivateDataHex = arr16[0].toString(16); codecPrivateDataHex = arr16[0].toString(16) + arr16[1].toString(16); } else { // 2 bytes : XXXXX XXXX XXXX XXX // ' ObjectType' 'Freq Index' 'Channels value' 'GAS = 000' codecPrivateData = new Uint8Array(2); //Freq Index is present for 3 bits in the first byte, last bit is in the second codecPrivateData[0] = (objectType &lt;&lt; 3) | (indexFreq &gt;&gt; 1); codecPrivateData[1] = (indexFreq &lt;&lt; 7) | (parseInt(qualityLevel.getAttribute('Channels'), 10) &lt;&lt; 3); // put the 2 bytes in an 16 bits array arr16 = new Uint16Array(1); arr16[0] = (codecPrivateData[0] &lt;&lt; 8) + codecPrivateData[1]; //convert decimal to hex value codecPrivateDataHex = arr16[0].toString(16); } codecPrivateData = '' + codecPrivateDataHex; codecPrivateData = codecPrivateData.toUpperCase(); qualityLevel.setAttribute('CodecPrivateData', codecPrivateData); } else if (objectType === 0) { objectType = (parseInt(codecPrivateData.substr(0, 2), 16) &amp; 0xF8) &gt;&gt; 3; } return 'mp4a.40.' + objectType; } function mapSegmentTemplate(streamIndex, timescale) { const segmentTemplate = {}; let mediaUrl, streamIndexTimeScale; mediaUrl = streamIndex.getAttribute('Url').replace('{bitrate}', '$Bandwidth$'); mediaUrl = mediaUrl.replace('{start time}', '$Time$'); streamIndexTimeScale = streamIndex.getAttribute('TimeScale'); streamIndexTimeScale = streamIndexTimeScale ? parseFloat(streamIndexTimeScale) : timescale; segmentTemplate.media = mediaUrl; segmentTemplate.timescale = streamIndexTimeScale; segmentTemplate.SegmentTimeline = mapSegmentTimeline(streamIndex, segmentTemplate.timescale); return segmentTemplate; } function mapSegmentTimeline(streamIndex, timescale) { const segmentTimeline = {}; const chunks = streamIndex.getElementsByTagName('c'); const segments = []; let segment; let prevSegment; let tManifest; let i,j,r; let duration = 0; for (i = 0; i &lt; chunks.length; i++) { segment = {}; // Get time 't' attribute value tManifest = chunks[i].getAttribute('t'); // =&gt; segment.tManifest = original timestamp value as a string (for constructing the fragment request url, see DashHandler) // =&gt; segment.t = number value of timestamp (maybe rounded value, but only for 0.1 microsecond) segment.tManifest = parseFloat(tManifest); segment.t = parseFloat(tManifest); // Get duration 'd' attribute value segment.d = parseFloat(chunks[i].getAttribute('d')); // If 't' not defined for first segment then t=0 if ((i === 0) &amp;&amp; !segment.t) { segment.t = 0; } if (i &gt; 0) { prevSegment = segments[segments.length - 1]; // Update previous segment duration if not defined if (!prevSegment.d) { if (prevSegment.tManifest) { prevSegment.d = parseFloat(tManifest) - parseFloat(prevSegment.tManifest); } else { prevSegment.d = segment.t - prevSegment.t; } } // Set segment absolute timestamp if not set in manifest if (!segment.t) { if (prevSegment.tManifest) { segment.tManifest = parseFloat(prevSegment.tManifest) + prevSegment.d; segment.t = parseFloat(segment.tManifest); } else { segment.t = prevSegment.t + prevSegment.d; } } } duration += segment.d; // Create new segment segments.push(segment); // Support for 'r' attribute (i.e. &quot;repeat&quot; as in MPEG-DASH) r = parseFloat(chunks[i].getAttribute('r')); if (r) { for (j = 0; j &lt; (r - 1); j++) { prevSegment = segments[segments.length - 1]; segment = {}; segment.t = prevSegment.t + prevSegment.d; segment.d = prevSegment.d; if (prevSegment.tManifest) { segment.tManifest = parseFloat(prevSegment.tManifest) + prevSegment.d; } duration += segment.d; segments.push(segment); } } } segmentTimeline.S = segments; segmentTimeline.S_asArray = segments; segmentTimeline.duration = duration / timescale; return segmentTimeline; } function getKIDFromProtectionHeader(protectionHeader) { let prHeader, wrmHeader, xmlReader, KID; // Get PlayReady header as byte array (base64 decoded) prHeader = BASE64.decodeArray(protectionHeader.firstChild.data); // Get Right Management header (WRMHEADER) from PlayReady header wrmHeader = getWRMHeaderFromPRHeader(prHeader); // Convert from multi-byte to unicode wrmHeader = new Uint16Array(wrmHeader.buffer); // Convert to string wrmHeader = String.fromCharCode.apply(null, wrmHeader); // Parse &lt;WRMHeader&gt; to get KID field value xmlReader = (new DOMParser()).parseFromString(wrmHeader, 'application/xml'); KID = xmlReader.querySelector('KID').textContent; // Get KID (base64 decoded) as byte array KID = BASE64.decodeArray(KID); // Convert UUID from little-endian to big-endian convertUuidEndianness(KID); return KID; } function getWRMHeaderFromPRHeader(prHeader) { let length, recordCount, recordType, recordLength, recordValue; let i = 0; // Parse PlayReady header // Length - 32 bits (LE format) length = (prHeader[i + 3] &lt;&lt; 24) + (prHeader[i + 2] &lt;&lt; 16) + (prHeader[i + 1] &lt;&lt; 8) + prHeader[i]; i += 4; // Record count - 16 bits (LE format) recordCount = (prHeader[i + 1] &lt;&lt; 8) + prHeader[i]; i += 2; // Parse records while (i &lt; prHeader.length) { // Record type - 16 bits (LE format) recordType = (prHeader[i + 1] &lt;&lt; 8) + prHeader[i]; i += 2; // Check if Rights Management header (record type = 0x01) if (recordType === 0x01) { // Record length - 16 bits (LE format) recordLength = (prHeader[i + 1] &lt;&lt; 8) + prHeader[i]; i += 2; // Record value =&gt; contains &lt;WRMHEADER&gt; recordValue = new Uint8Array(recordLength); recordValue.set(prHeader.subarray(i, i + recordLength)); return recordValue; } } return null; } function convertUuidEndianness(uuid) { swapBytes(uuid, 0, 3); swapBytes(uuid, 1, 2); swapBytes(uuid, 4, 5); swapBytes(uuid, 6, 7); } function swapBytes(bytes, pos1, pos2) { const temp = bytes[pos1]; bytes[pos1] = bytes[pos2]; bytes[pos2] = temp; } function createPRContentProtection(protectionHeader) { let pro = { __text: protectionHeader.firstChild.data, __prefix: 'mspr' }; return { schemeIdUri: 'urn:uuid:9a04f079-9840-4286-ab92-e65be0885f95', value: 'com.microsoft.playready', pro: pro, pro_asArray: pro }; } function createWidevineContentProtection(protectionHeader, KID) { // Create Widevine CENC header (Protocol Buffer) with KID value const wvCencHeader = new Uint8Array(2 + KID.length); wvCencHeader[0] = 0x12; wvCencHeader[1] = 0x10; wvCencHeader.set(KID, 2); // Create a pssh box const length = 12 /* box length, type, version and flags */ + 16 /* SystemID */ + 4 /* data length */ + wvCencHeader.length; let pssh = new Uint8Array(length); let i = 0; // Set box length value pssh[i++] = (length &amp; 0xFF000000) &gt;&gt; 24; pssh[i++] = (length &amp; 0x00FF0000) &gt;&gt; 16; pssh[i++] = (length &amp; 0x0000FF00) &gt;&gt; 8; pssh[i++] = (length &amp; 0x000000FF); // Set type ('pssh'), version (0) and flags (0) pssh.set([0x70, 0x73, 0x73, 0x68, 0x00, 0x00, 0x00, 0x00], i); i += 8; // Set SystemID ('edef8ba9-79d6-4ace-a3c8-27dcd51d21ed') pssh.set([0xed, 0xef, 0x8b, 0xa9, 0x79, 0xd6, 0x4a, 0xce, 0xa3, 0xc8, 0x27, 0xdc, 0xd5, 0x1d, 0x21, 0xed], i); i += 16; // Set data length value pssh[i++] = (wvCencHeader.length &amp; 0xFF000000) &gt;&gt; 24; pssh[i++] = (wvCencHeader.length &amp; 0x00FF0000) &gt;&gt; 16; pssh[i++] = (wvCencHeader.length &amp; 0x0000FF00) &gt;&gt; 8; pssh[i++] = (wvCencHeader.length &amp; 0x000000FF); // Copy Widevine CENC header pssh.set(wvCencHeader, i); // Convert to BASE64 string pssh = String.fromCharCode.apply(null, pssh); pssh = BASE64.encodeASCII(pssh); return { schemeIdUri: 'urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed', value: 'com.widevine.alpha', pssh: { __text: pssh } }; } function processManifest(xmlDoc, manifestLoadedTime) { const manifest = {}; const contentProtections = []; const smoothStreamingMedia = xmlDoc.getElementsByTagName('SmoothStreamingMedia')[0]; const protection = xmlDoc.getElementsByTagName('Protection')[0]; let protectionHeader = null; let period, adaptations, contentProtection, KID, timestampOffset, startTime, segments, timescale, i, j; // Set manifest node properties manifest.protocol = 'MSS'; manifest.profiles = 'urn:mpeg:dash:profile:isoff-live:2011'; manifest.type = smoothStreamingMedia.getAttribute('IsLive') === 'TRUE' ? 'dynamic' : 'static'; timescale = smoothStreamingMedia.getAttribute('TimeScale'); manifest.timescale = timescale ? parseFloat(timescale) : DEFAULT_TIME_SCALE; manifest.timeShiftBufferDepth = parseFloat(smoothStreamingMedia.getAttribute('DVRWindowLength')) / manifest.timescale; manifest.mediaPresentationDuration = (parseFloat(smoothStreamingMedia.getAttribute('Duration')) === 0) ? Infinity : parseFloat(smoothStreamingMedia.getAttribute('Duration')) / manifest.timescale; manifest.minBufferTime = mediaPlayerModel.getStableBufferTime(); manifest.ttmlTimeIsRelative = true; // In case of live streams, set availabilityStartTime property according to DVRWindowLength if (manifest.type === 'dynamic') { manifest.availabilityStartTime = new Date(manifestLoadedTime.getTime() - (manifest.timeShiftBufferDepth * 1000)); manifest.refreshManifestOnSwitchTrack = true; manifest.doNotUpdateDVRWindowOnBufferUpdated = true; // done by Mss fragment processor manifest.ignorePostponeTimePeriod = true; // in Mss, manifest is never updated } // Map period node to manifest root node manifest.Period = mapPeriod(smoothStreamingMedia, manifest.timescale); manifest.Period_asArray = [manifest.Period]; // Initialize period start time period = manifest.Period; period.start = 0; // ContentProtection node if (protection !== undefined) { protectionHeader = xmlDoc.getElementsByTagName('ProtectionHeader')[0]; // Some packagers put newlines into the ProtectionHeader base64 string, which is not good // because this cannot be correctly parsed. Let's just filter out any newlines found in there. protectionHeader.firstChild.data = protectionHeader.firstChild.data.replace(/\\n|\\r/g, ''); // Get KID (in CENC format) from protection header KID = getKIDFromProtectionHeader(protectionHeader); // Create ContentProtection for PlayReady contentProtection = createPRContentProtection(protectionHeader); contentProtection['cenc:default_KID'] = KID; contentProtections.push(contentProtection); // Create ContentProtection for Widevine (as a CENC protection) contentProtection = createWidevineContentProtection(protectionHeader, KID); contentProtection['cenc:default_KID'] = KID; contentProtections.push(contentProtection); manifest.ContentProtection = contentProtections; manifest.ContentProtection_asArray = contentProtections; } adaptations = period.AdaptationSet_asArray; for (i = 0; i &lt; adaptations.length; i += 1) { adaptations[i].SegmentTemplate.initialization = '$Bandwidth$'; // Propagate content protection information into each adaptation if (manifest.ContentProtection !== undefined) { adaptations[i].ContentProtection = manifest.ContentProtection; adaptations[i].ContentProtection_asArray = manifest.ContentProtection_asArray; } if (manifest.type === 'dynamic') { // Match timeShiftBufferDepth to video segment timeline duration if (manifest.timeShiftBufferDepth &gt; 0 &amp;&amp; adaptations[i].contentType === 'video' &amp;&amp; manifest.timeShiftBufferDepth &gt; adaptations[i].SegmentTemplate.SegmentTimeline.duration) { manifest.timeShiftBufferDepth = adaptations[i].SegmentTemplate.SegmentTimeline.duration; } } } if (manifest.timeShiftBufferDepth &lt; manifest.minBufferTime) { manifest.minBufferTime = manifest.timeShiftBufferDepth; } // Delete Content Protection under root manifest node delete manifest.ContentProtection; delete manifest.ContentProtection_asArray; // In case of VOD streams, check if start time is greater than 0 // Then determine timestamp offset according to higher audio/video start time // (use case = live stream delinearization) if (manifest.type === 'static') { for (i = 0; i &lt; adaptations.length; i++) { if (adaptations[i].contentType === 'audio' || adaptations[i].contentType === 'video') { segments = adaptations[i].SegmentTemplate.SegmentTimeline.S_asArray; startTime = segments[0].t / adaptations[i].SegmentTemplate.timescale; if (timestampOffset === undefined) { timestampOffset = startTime; } timestampOffset = Math.min(timestampOffset, startTime); // Correct content duration according to minimum adaptation's segments duration // in order to force &lt;video&gt; element sending 'ended' event manifest.mediaPresentationDuration = Math.min(manifest.mediaPresentationDuration, adaptations[i].SegmentTemplate.SegmentTimeline.duration); } } // Patch segment templates timestamps and determine period start time (since audio/video should not be aligned to 0) if (timestampOffset &gt; 0) { for (i = 0; i &lt; adaptations.length; i++) { segments = adaptations[i].SegmentTemplate.SegmentTimeline.S_asArray; for (j = 0; j &lt; segments.length; j++) { if (!segments[j].tManifest) { segments[j].tManifest = segments[j].t; } segments[j].t -= (timestampOffset * adaptations[i].SegmentTemplate.timescale); } if (adaptations[i].contentType === 'audio' || adaptations[i].contentType === 'video') { period.start = Math.max(segments[0].t, period.start); adaptations[i].SegmentTemplate.presentationTimeOffset = period.start; } } period.start /= manifest.timescale; } } manifest.mediaPresentationDuration = Math.floor(manifest.mediaPresentationDuration * 1000) / 1000; period.duration = manifest.mediaPresentationDuration; return manifest; } function parseDOM(data) { let xmlDoc = null; if (window.DOMParser) { const parser = new window.DOMParser(); xmlDoc = parser.parseFromString(data, 'text/xml'); if (xmlDoc.getElementsByTagName('parsererror').length &gt; 0) { throw new Error('parsing the manifest failed'); } } return xmlDoc; } function getMatchers() { return null; } function getIron() { return null; } function internalParse(data) { let xmlDoc = null; let manifest = null; const startTime = window.performance.now(); // Parse the MSS XML manifest xmlDoc = parseDOM(data); const xmlParseTime = window.performance.now(); if (xmlDoc === null) { return null; } // Convert MSS manifest into DASH manifest manifest = processManifest(xmlDoc, new Date()); const mss2dashTime = window.performance.now(); logger.info('Parsing complete: (xmlParsing: ' + (xmlParseTime - startTime).toPrecision(3) + 'ms, mss2dash: ' + (mss2dashTime - xmlParseTime).toPrecision(3) + 'ms, total: ' + ((mss2dashTime - startTime) / 1000).toPrecision(3) + 's)'); return manifest; } instance = { parse: internalParse, getMatchers: getMatchers, getIron: getIron }; setup(); return instance; } MssParser.__dashjs_factory_name = 'MssParser'; export default dashjs.FactoryMaker.getClassFactory(MssParser); /* jshint ignore:line */ × Search results Close "},"streaming_utils_ObjectUtils.js.html":{"id":"streaming_utils_ObjectUtils.js.html","title":"Source: streaming/utils/ObjectUtils.js","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Source: streaming/utils/ObjectUtils.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ import FactoryMaker from '../../core/FactoryMaker'; import deepEqual from 'fast-deep-equal'; /** * @module ObjectUtils * @description Provides utility functions for objects */ function ObjectUtils() { let instance; /** * Returns true if objects are equal * @return {boolean} * @param {object} obj1 * @param {object} obj2 * @memberof module:ObjectUtils * @instance */ function areEqual(obj1, obj2) { return deepEqual(obj1, obj2); } instance = { areEqual: areEqual }; return instance; } ObjectUtils.__dashjs_factory_name = 'ObjectUtils'; export default FactoryMaker.getSingletonFactory(ObjectUtils); × Search results Close "},"streaming_protection_controllers_ProtectionController.js.html":{"id":"streaming_protection_controllers_ProtectionController.js.html","title":"Source: streaming/protection/controllers/ProtectionController.js","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Source: streaming/protection/controllers/ProtectionController.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ import CommonEncryption from '../CommonEncryption'; import MediaCapability from '../vo/MediaCapability'; import KeySystemConfiguration from '../vo/KeySystemConfiguration'; /** * @module ProtectionController * @description Provides access to media protection information and functionality. Each * ProtectionController manages a single {@link MediaPlayer.models.ProtectionModel} * which encapsulates a set of protection information (EME APIs, selected key system, * key sessions). The APIs of ProtectionController mostly align with the latest EME * APIs. Key system selection is mostly automated when combined with app-overrideable * functionality provided in {@link ProtectionKeyController}. * @todo ProtectionController does almost all of its tasks automatically after init() is * called. Applications might want more control over this process and want to go through * each step manually (key system selection, session creation, session maintenance). * @param {Object} config */ function ProtectionController(config) { config = config || {}; const protectionKeyController = config.protectionKeyController; let protectionModel = config.protectionModel; const eventBus = config.eventBus; const events = config.events; const debug = config.debug; const BASE64 = config.BASE64; const constants = config.constants; let instance, logger, pendingNeedKeyData, mediaInfoArr, protDataSet, sessionType, robustnessLevel, keySystem; function setup() { logger = debug.getLogger(instance); pendingNeedKeyData = []; mediaInfoArr = []; sessionType = 'temporary'; robustnessLevel = ''; } function checkConfig() { if (!eventBus || !eventBus.hasOwnProperty('on') || !protectionKeyController || !protectionKeyController.hasOwnProperty('getSupportedKeySystemsFromContentProtection')) { throw new Error('Missing config parameter(s)'); } } /** * Initialize this protection system with a given audio * or video stream information. * * @param {StreamInfo} [mediaInfo] Media information * @memberof module:ProtectionController * @instance * @todo This API will change when we have better support for allowing applications * to select different adaptation sets for playback. Right now it is clunky for * applications to create {@link StreamInfo} with the right information, */ function initializeForMedia(mediaInfo) { // Not checking here if a session for similar KS/KID combination is already created // because still don't know which keysystem will be selected. // Once Keysystem is selected and before creating the session, we will do that check // so we create the strictly necessary DRM sessions if (!mediaInfo) { throw new Error('mediaInfo can not be null or undefined'); } checkConfig(); eventBus.on(events.INTERNAL_KEY_MESSAGE, onKeyMessage, this); eventBus.on(events.INTERNAL_KEY_STATUS_CHANGED, onKeyStatusChanged, this); mediaInfoArr.push(mediaInfo); // ContentProtection elements are specified at the AdaptationSet level, so the CP for audio // and video will be the same. Just use one valid MediaInfo object const supportedKS = protectionKeyController.getSupportedKeySystemsFromContentProtection(mediaInfo.contentProtection); if (supportedKS &amp;&amp; supportedKS.length &gt; 0) { selectKeySystem(supportedKS, true); } } /** * Returns a set of supported key systems and CENC initialization data * from the given array of ContentProtection elements. Only * key systems that are supported by this player will be returned. * Key systems are returned in priority order (highest first). * * @param {Array.&lt;Object&gt;} cps - array of content protection elements parsed * from the manifest * @returns {Array.&lt;Object&gt;} array of objects indicating which supported key * systems were found. Empty array is returned if no * supported key systems were found * @memberof module:ProtectionKeyController * @instance */ function getSupportedKeySystemsFromContentProtection(cps) { return protectionKeyController.getSupportedKeySystemsFromContentProtection(cps); } /** * Create a new key session associated with the given initialization data from * the MPD or from the PSSH box in the media * * @param {ArrayBuffer} initData the initialization data * @param {Uint8Array} cdmData the custom data to provide to licenser * @memberof module:ProtectionController * @instance * @fires ProtectionController#KeySessionCreated * @todo In older versions of the EME spec, there was a one-to-one relationship between * initialization data and key sessions. That is no longer true in the latest APIs. This * API will need to modified (and a new &quot;generateRequest(keySession, initData)&quot; API created) * to come up to speed with the latest EME standard */ function createKeySession(initData, cdmData) { const initDataForKS = CommonEncryption.getPSSHForKeySystem(keySystem, initData); const protData = getProtData(keySystem); if (initDataForKS) { // Check for duplicate initData const currentInitData = protectionModel.getAllInitData(); for (let i = 0; i &lt; currentInitData.length; i++) { if (protectionKeyController.initDataEquals(initDataForKS, currentInitData[i])) { logger.warn('DRM: Ignoring initData because we have already seen it!'); return; } } try { protectionModel.createKeySession(initDataForKS, protData, getSessionType(keySystem), cdmData); } catch (error) { eventBus.trigger(events.KEY_SESSION_CREATED, {data: null, error: 'Error creating key session! ' + error.message}); } } else if (initData) { protectionModel.createKeySession(initData, protData, getSessionType(keySystem), cdmData); } else { eventBus.trigger(events.KEY_SESSION_CREATED, {data: null, error: 'Selected key system is ' + keySystem.systemString + '. needkey/encrypted event contains no initData corresponding to that key system!'}); } } /** * Loads a key session with the given session ID from persistent storage. This * essentially creates a new key session * * @param {string} sessionID * @param {string} initData * @memberof module:ProtectionController * @instance * @fires ProtectionController#KeySessionCreated */ function loadKeySession(sessionID, initData) { protectionModel.loadKeySession(sessionID, initData, getSessionType(keySystem)); } /** * Removes the given key session from persistent storage and closes the session * as if {@link ProtectionController#closeKeySession} * was called * * @param {SessionToken} sessionToken the session * token * @memberof module:ProtectionController * @instance * @fires ProtectionController#KeySessionRemoved * @fires ProtectionController#KeySessionClosed */ function removeKeySession(sessionToken) { protectionModel.removeKeySession(sessionToken); } /** * Closes the key session and releases all associated decryption keys. These * keys will no longer be available for decrypting media * * @param {SessionToken} sessionToken the session * token * @memberof module:ProtectionController * @instance * @fires ProtectionController#KeySessionClosed */ function closeKeySession(sessionToken) { protectionModel.closeKeySession(sessionToken); } /** * Sets a server certificate for use by the CDM when signing key messages * intended for a particular license server. This will fire * an error event if a key system has not yet been selected. * * @param {ArrayBuffer} serverCertificate a CDM-specific license server * certificate * @memberof module:ProtectionController * @instance * @fires ProtectionController#ServerCertificateUpdated */ function setServerCertificate(serverCertificate) { protectionModel.setServerCertificate(serverCertificate); } /** * Associate this protection system with the given HTMLMediaElement. This * causes the system to register for needkey/encrypted events from the given * element and provides a destination for setting of MediaKeys * * @param {HTMLMediaElement} element the media element to which the protection * system should be associated * @memberof module:ProtectionController * @instance */ function setMediaElement(element) { if (element) { protectionModel.setMediaElement(element); eventBus.on(events.NEED_KEY, onNeedKey, this); } else if (element === null) { protectionModel.setMediaElement(element); eventBus.off(events.NEED_KEY, onNeedKey, this); } } /** * Sets the session type to use when creating key sessions. Either &quot;temporary&quot; or * &quot;persistent-license&quot;. Default is &quot;temporary&quot;. * * @param {string} value the session type * @memberof module:ProtectionController * @instance */ function setSessionType(value) { sessionType = value; } /** * Sets the robustness level for video and audio capabilities. Optional to remove Chrome warnings. * Possible values are SW_SECURE_CRYPTO, SW_SECURE_DECODE, HW_SECURE_CRYPTO, HW_SECURE_CRYPTO, HW_SECURE_DECODE, HW_SECURE_ALL. * * @param {string} level the robustness level * @memberof module:ProtectionController * @instance */ function setRobustnessLevel(level) { robustnessLevel = level; } /** * Attach KeySystem-specific data to use for license acquisition with EME * * @param {Object} data an object containing property names corresponding to * key system name strings (e.g. &quot;org.w3.clearkey&quot;) and associated values * being instances of {@link ProtectionData} * @memberof module:ProtectionController * @instance */ function setProtectionData(data) { protDataSet = data; protectionKeyController.setProtectionData(data); } /** * Destroys all protection data associated with this protection set. This includes * deleting all key sessions. In the case of persistent key sessions, the sessions * will simply be unloaded and not deleted. Additionally, if this protection set is * associated with a HTMLMediaElement, it will be detached from that element. * * @memberof module:ProtectionController * @instance */ function reset() { eventBus.off(events.INTERNAL_KEY_MESSAGE, onKeyMessage, this); eventBus.off(events.INTERNAL_KEY_STATUS_CHANGED, onKeyStatusChanged, this); setMediaElement(null); keySystem = undefined;//TODO-Refactor look at why undefined is needed for this. refactor if (protectionModel) { protectionModel.reset(); protectionModel = null; } mediaInfoArr = []; } /////////////// // Private /////////////// function getProtData(keySystem) { let protData = null; if (keySystem) { const keySystemString = keySystem.systemString; if (protDataSet) { protData = (keySystemString in protDataSet) ? protDataSet[keySystemString] : null; } } return protData; } function getKeySystemConfiguration(keySystem) { const protData = getProtData(keySystem); const audioCapabilities = []; const videoCapabilities = []; const audioRobustness = (protData &amp;&amp; protData.audioRobustness &amp;&amp; protData.audioRobustness.length &gt; 0) ? protData.audioRobustness : robustnessLevel; const videoRobustness = (protData &amp;&amp; protData.videoRobustness &amp;&amp; protData.videoRobustness.length &gt; 0) ? protData.videoRobustness : robustnessLevel; const ksSessionType = getSessionType(keySystem); mediaInfoArr.forEach((media) =&gt; { if (media.type === constants.AUDIO) { audioCapabilities.push(new MediaCapability(media.codec, audioRobustness)); } else if (media.type === constants.VIDEO) { videoCapabilities.push(new MediaCapability(media.codec, videoRobustness)); } }); return new KeySystemConfiguration( audioCapabilities, videoCapabilities, 'optional', (ksSessionType === 'temporary') ? 'optional' : 'required', [ksSessionType]); } function getSessionType(keySystem) { const protData = getProtData(keySystem); const ksSessionType = (protData &amp;&amp; protData.sessionType) ? protData.sessionType : sessionType; return ksSessionType; } function selectKeySystem(supportedKS, fromManifest) { const self = this; const requestedKeySystems = []; let ksIdx; if (keySystem) { // We have a key system for (ksIdx = 0; ksIdx &lt; supportedKS.length; ksIdx++) { if (keySystem === supportedKS[ksIdx].ks) { requestedKeySystems.push({ks: supportedKS[ksIdx].ks, configs: [getKeySystemConfiguration(keySystem)]}); // Ensure that we would be granted key system access using the key // system and codec information const onKeySystemAccessComplete = function (event) { eventBus.off(events.KEY_SYSTEM_ACCESS_COMPLETE, onKeySystemAccessComplete, self); if (event.error) { if (!fromManifest) { eventBus.trigger(events.KEY_SYSTEM_SELECTED, {error: 'DRM: KeySystem Access Denied! -- ' + event.error}); } } else { logger.info('DRM: KeySystem Access Granted'); eventBus.trigger(events.KEY_SYSTEM_SELECTED, {data: event.data}); if (supportedKS[ksIdx].sessionId) { // Load MediaKeySession with sessionId loadKeySession(supportedKS[ksIdx].sessionId, supportedKS[ksIdx].initData); } else if (supportedKS[ksIdx].initData) { // Create new MediaKeySession with initData createKeySession(supportedKS[ksIdx].initData, supportedKS[ksIdx].cdmData); } } }; eventBus.on(events.KEY_SYSTEM_ACCESS_COMPLETE, onKeySystemAccessComplete, self); protectionModel.requestKeySystemAccess(requestedKeySystems); break; } } } else if (keySystem === undefined) { // First time through, so we need to select a key system keySystem = null; pendingNeedKeyData.push(supportedKS); // Add all key systems to our request list since we have yet to select a key system for (let i = 0; i &lt; supportedKS.length; i++) { requestedKeySystems.push({ks: supportedKS[i].ks, configs: [getKeySystemConfiguration(supportedKS[i].ks)]}); } let keySystemAccess; const onKeySystemAccessComplete = function (event) { eventBus.off(events.KEY_SYSTEM_ACCESS_COMPLETE, onKeySystemAccessComplete, self); if (event.error) { keySystem = undefined; eventBus.off(events.INTERNAL_KEY_SYSTEM_SELECTED, onKeySystemSelected, self); if (!fromManifest) { eventBus.trigger(events.KEY_SYSTEM_SELECTED, {data: null, error: 'DRM: KeySystem Access Denied! -- ' + event.error}); } } else { keySystemAccess = event.data; logger.info('DRM: KeySystem Access Granted (' + keySystemAccess.keySystem.systemString + ')! Selecting key system...'); protectionModel.selectKeySystem(keySystemAccess); } }; var onKeySystemSelected = function (event) { eventBus.off(events.INTERNAL_KEY_SYSTEM_SELECTED, onKeySystemSelected, self); eventBus.off(events.KEY_SYSTEM_ACCESS_COMPLETE, onKeySystemAccessComplete, self); if (!event.error) { keySystem = protectionModel.getKeySystem(); eventBus.trigger(events.KEY_SYSTEM_SELECTED, {data: keySystemAccess}); // Set server certificate from protData const protData = getProtData(keySystem); if (protData &amp;&amp; protData.serverCertificate &amp;&amp; protData.serverCertificate.length &gt; 0) { protectionModel.setServerCertificate(BASE64.decodeArray(protData.serverCertificate).buffer); } for (let i = 0; i &lt; pendingNeedKeyData.length; i++) { for (ksIdx = 0; ksIdx &lt; pendingNeedKeyData[i].length; ksIdx++) { if (keySystem === pendingNeedKeyData[i][ksIdx].ks) { // For Clearkey: if parameters for generating init data was provided by the user, use them for generating // initData and overwrite possible initData indicated in encrypted event (EME) if (protectionKeyController.isClearKey(keySystem) &amp;&amp; protData &amp;&amp; protData.hasOwnProperty('clearkeys')) { const initData = { kids: Object.keys(protData.clearkeys) }; pendingNeedKeyData[i][ksIdx].initData = new TextEncoder().encode(JSON.stringify(initData)); } if (pendingNeedKeyData[i][ksIdx].sessionId) { // Load MediaKeySession with sessionId loadKeySession(pendingNeedKeyData[i][ksIdx].sessionId, pendingNeedKeyData[i][ksIdx].initData); } else if (pendingNeedKeyData[i][ksIdx].initData !== null) { // Create new MediaKeySession with initData createKeySession(pendingNeedKeyData[i][ksIdx].initData, pendingNeedKeyData[i][ksIdx].cdmData); } break; } } } } else { keySystem = undefined; if (!fromManifest) { eventBus.trigger(events.KEY_SYSTEM_SELECTED, {data: null, error: 'DRM: Error selecting key system! -- ' + event.error}); } } }; eventBus.on(events.INTERNAL_KEY_SYSTEM_SELECTED, onKeySystemSelected, self); eventBus.on(events.KEY_SYSTEM_ACCESS_COMPLETE, onKeySystemAccessComplete, self); protectionModel.requestKeySystemAccess(requestedKeySystems); } else { // We are in the process of selecting a key system, so just save the data pendingNeedKeyData.push(supportedKS); } } function sendLicenseRequestCompleteEvent(data, error) { eventBus.trigger(events.LICENSE_REQUEST_COMPLETE, {data: data, error: error}); } function onKeyStatusChanged(e) { if (e.error) { eventBus.trigger(events.KEY_STATUSES_CHANGED, {data: null, error: 'DRM: KeyStatusChange error! -- ' + e.error}); } else { logger.debug('DRM: key status = ' + e.status); } } function onKeyMessage(e) { logger.debug('DRM: onKeyMessage'); if (e.error) { logger.error(e.error); return; } // Dispatch event to applications indicating we received a key message const keyMessage = e.data; eventBus.trigger(events.KEY_MESSAGE, {data: keyMessage}); const messageType = (keyMessage.messageType) ? keyMessage.messageType : 'license-request'; const message = keyMessage.message; const sessionToken = keyMessage.sessionToken; const protData = getProtData(keySystem); const keySystemString = keySystem ? keySystem.systemString : null; const licenseServerData = protectionKeyController.getLicenseServer(keySystem, protData, messageType); const eventData = { sessionToken: sessionToken, messageType: messageType }; // Ensure message from CDM is not empty if (!message || message.byteLength === 0) { sendLicenseRequestCompleteEvent(eventData, 'DRM: Empty key message from CDM'); return; } // Message not destined for license server if (!licenseServerData) { logger.debug('DRM: License server request not required for this message (type = ' + e.data.messageType + '). Session ID = ' + sessionToken.getSessionID()); sendLicenseRequestCompleteEvent(eventData); return; } // Perform any special handling for ClearKey if (protectionKeyController.isClearKey(keySystem)) { const clearkeys = protectionKeyController.processClearKeyLicenseRequest(keySystem, protData, message); if (clearkeys) { logger.debug('DRM: ClearKey license request handled by application!'); sendLicenseRequestCompleteEvent(eventData); protectionModel.updateKeySession(sessionToken, clearkeys); return; } } // All remaining key system scenarios require a request to a remote license server const xhr = new XMLHttpRequest(); // Determine license server URL let url = null; if (protData &amp;&amp; protData.serverURL) { const serverURL = protData.serverURL; if (typeof serverURL === 'string' &amp;&amp; serverURL !== '') { url = serverURL; } else if (typeof serverURL === 'object' &amp;&amp; serverURL.hasOwnProperty(messageType)) { url = serverURL[messageType]; } } else if (protData &amp;&amp; protData.laURL &amp;&amp; protData.laURL !== '') { // TODO: Deprecated! url = protData.laURL; } else { url = keySystem.getLicenseServerURLFromInitData(CommonEncryption.getPSSHData(sessionToken.initData)); if (!url) { url = e.data.laURL; } } // Possibly update or override the URL based on the message url = licenseServerData.getServerURLFromMessage(url, message, messageType); // Ensure valid license server URL if (!url) { sendLicenseRequestCompleteEvent(eventData, 'DRM: No license server URL specified!'); return; } const reportError = function (xhr, eventData, keySystemString, messageType) { const errorMsg = ((xhr.response) ? licenseServerData.getErrorResponse(xhr.response, keySystemString, messageType) : 'NONE'); sendLicenseRequestCompleteEvent(eventData, 'DRM: ' + keySystemString + ' update, XHR complete. status is &quot;' + xhr.statusText + '&quot; (' + xhr.status + '), readyState is ' + xhr.readyState + '. Response is ' + errorMsg); }; xhr.open(licenseServerData.getHTTPMethod(messageType), url, true); xhr.responseType = licenseServerData.getResponseType(keySystemString, messageType); xhr.onload = function () { if (this.status == 200) { const licenseMessage = licenseServerData.getLicenseMessage(this.response, keySystemString, messageType); if (licenseMessage !== null) { sendLicenseRequestCompleteEvent(eventData); protectionModel.updateKeySession(sessionToken, licenseMessage); } else { reportError(this, eventData, keySystemString, messageType); } } else { reportError(this, eventData, keySystemString, messageType); } }; xhr.onabort = function () { sendLicenseRequestCompleteEvent(eventData, 'DRM: ' + keySystemString + ' update, XHR aborted. status is &quot;' + this.statusText + '&quot; (' + this.status + '), readyState is ' + this.readyState); }; xhr.onerror = function () { sendLicenseRequestCompleteEvent(eventData, 'DRM: ' + keySystemString + ' update, XHR error. status is &quot;' + this.statusText + '&quot; (' + this.status + '), readyState is ' + this.readyState); }; // Set optional XMLHttpRequest headers from protection data and message const updateHeaders = function (headers) { if (headers) { for (const key in headers) { if ('authorization' === key.toLowerCase()) { xhr.withCredentials = true; } xhr.setRequestHeader(key, headers[key]); } } }; if (protData) { updateHeaders(protData.httpRequestHeaders); } updateHeaders(keySystem.getRequestHeadersFromMessage(message)); // Overwrite withCredentials property from protData if present if (protData &amp;&amp; typeof protData.withCredentials == 'boolean') { xhr.withCredentials = protData.withCredentials; } xhr.send(keySystem.getLicenseRequestFromMessage(message)); } function onNeedKey(event) { logger.debug('DRM: onNeedKey'); // Ignore non-cenc initData if (event.key.initDataType !== 'cenc') { logger.warn('DRM: Only \\'cenc\\' initData is supported! Ignoring initData of type: ' + event.key.initDataType); return; } // Some browsers return initData as Uint8Array (IE), some as ArrayBuffer (Chrome). // Convert to ArrayBuffer let abInitData = event.key.initData; if (ArrayBuffer.isView(abInitData)) { abInitData = abInitData.buffer; } // If key system has already been selected and initData already seen, then do nothing if (keySystem) { const initDataForKS = CommonEncryption.getPSSHForKeySystem(keySystem, abInitData); if (initDataForKS) { // Check for duplicate initData const currentInitData = protectionModel.getAllInitData(); for (let i = 0; i &lt; currentInitData.length; i++) { if (protectionKeyController.initDataEquals(initDataForKS, currentInitData[i])) { logger.warn('DRM: Ignoring initData because we have already seen it!'); return; } } } } logger.debug('DRM: initData:', String.fromCharCode.apply(null, new Uint8Array(abInitData))); const supportedKS = protectionKeyController.getSupportedKeySystems(abInitData, protDataSet); if (supportedKS.length === 0) { logger.debug('DRM: Received needkey event with initData, but we don\\'t support any of the key systems!'); return; } selectKeySystem(supportedKS, false); } function getKeySystems() { return protectionKeyController ? protectionKeyController.getKeySystems() : []; } instance = { initializeForMedia: initializeForMedia, createKeySession: createKeySession, loadKeySession: loadKeySession, removeKeySession: removeKeySession, closeKeySession: closeKeySession, setServerCertificate: setServerCertificate, setMediaElement: setMediaElement, setSessionType: setSessionType, setRobustnessLevel: setRobustnessLevel, setProtectionData: setProtectionData, getSupportedKeySystemsFromContentProtection: getSupportedKeySystemsFromContentProtection, getKeySystems: getKeySystems, reset: reset }; setup(); return instance; } ProtectionController.__dashjs_factory_name = 'ProtectionController'; export default dashjs.FactoryMaker.getClassFactory(ProtectionController); /* jshint ignore:line */ × Search results Close "},"streaming_protection_controllers_ProtectionKeyController.js.html":{"id":"streaming_protection_controllers_ProtectionKeyController.js.html","title":"Source: streaming/protection/controllers/ProtectionKeyController.js","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Source: streaming/protection/controllers/ProtectionKeyController.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ import CommonEncryption from './../CommonEncryption'; import KeySystemClearKey from './../drm/KeySystemClearKey'; import KeySystemW3CClearKey from './../drm/KeySystemW3CClearKey'; import KeySystemWidevine from './../drm/KeySystemWidevine'; import KeySystemPlayReady from './../drm/KeySystemPlayReady'; import DRMToday from './../servers/DRMToday'; import PlayReady from './../servers/PlayReady'; import Widevine from './../servers/Widevine'; import ClearKey from './../servers/ClearKey'; import ProtectionConstants from '../../constants/ProtectionConstants'; /** * @module ProtectionKeyController * @description Media protection key system functionality that can be modified/overridden by applications */ function ProtectionKeyController() { let context = this.context; let instance, debug, logger, keySystems, BASE64, clearkeyKeySystem, clearkeyW3CKeySystem; function setConfig(config) { if (!config) return; if (config.debug) { debug = config.debug; logger = debug.getLogger(instance); } if (config.BASE64) { BASE64 = config.BASE64; } } function initialize() { keySystems = []; let keySystem; // PlayReady keySystem = KeySystemPlayReady(context).getInstance({ BASE64: BASE64 }); keySystems.push(keySystem); // Widevine keySystem = KeySystemWidevine(context).getInstance({ BASE64: BASE64 }); keySystems.push(keySystem); // ClearKey keySystem = KeySystemClearKey(context).getInstance({ BASE64: BASE64 }); keySystems.push(keySystem); clearkeyKeySystem = keySystem; // W3C ClearKey keySystem = KeySystemW3CClearKey(context).getInstance({ BASE64: BASE64, debug: debug }); keySystems.push(keySystem); clearkeyW3CKeySystem = keySystem; } /** * Returns a prioritized list of key systems supported * by this player (not necessarily those supported by the * user agent) * * @returns {Array.&lt;KeySystem&gt;} a prioritized * list of key systems * @memberof module:ProtectionKeyController * @instance */ function getKeySystems() { return keySystems; } /** * Returns the key system associated with the given key system string * name (i.e. 'org.w3.clearkey') * * @param {string} systemString the system string * @returns {KeySystem|null} the key system * or null if no supported key system is associated with the given key * system string * @memberof module:ProtectionKeyController * @instance */ function getKeySystemBySystemString(systemString) { for (let i = 0; i &lt; keySystems.length; i++) { if (keySystems[i].systemString === systemString) { return keySystems[i]; } } return null; } /** * Determines whether the given key system is ClearKey. This is * necessary because the EME spec defines ClearKey and its method * for providing keys to the key session; and this method has changed * between the various API versions. Our EME-specific ProtectionModels * must know if the system is ClearKey so that it can format the keys * according to the particular spec version. * * @param {Object} keySystem the key * @returns {boolean} true if this is the ClearKey key system, false * otherwise * @memberof module:ProtectionKeyController * @instance */ function isClearKey(keySystem) { return (keySystem === clearkeyKeySystem || keySystem === clearkeyW3CKeySystem); } /** * Check equality of initData array buffers. * * @param {ArrayBuffer} initData1 - first initData * @param {ArrayBuffer} initData2 - second initData * @returns {boolean} true if the initData arrays are equal in size and * contents, false otherwise * @memberof module:ProtectionKeyController * @instance */ function initDataEquals(initData1, initData2) { if (initData1.byteLength === initData2.byteLength) { let data1 = new Uint8Array(initData1); let data2 = new Uint8Array(initData2); for (let j = 0; j &lt; data1.length; j++) { if (data1[j] !== data2[j]) { return false; } } return true; } return false; } /** * Returns a set of supported key systems and CENC initialization data * from the given array of ContentProtection elements. Only * key systems that are supported by this player will be returned. * Key systems are returned in priority order (highest first). * * @param {Array.&lt;Object&gt;} cps - array of content protection elements parsed * from the manifest * @returns {Array.&lt;Object&gt;} array of objects indicating which supported key * systems were found. Empty array is returned if no * supported key systems were found * @memberof module:ProtectionKeyController * @instance */ function getSupportedKeySystemsFromContentProtection(cps) { let cp, ks, ksIdx, cpIdx; let supportedKS = []; if (cps) { for (ksIdx = 0; ksIdx &lt; keySystems.length; ++ksIdx) { ks = keySystems[ksIdx]; for (cpIdx = 0; cpIdx &lt; cps.length; ++cpIdx) { cp = cps[cpIdx]; if (cp.schemeIdUri.toLowerCase() === ks.schemeIdURI) { // Look for DRM-specific ContentProtection supportedKS.push({ ks: ks, initData: ks.getInitData(cp), cdmData: ks.getCDMData(), sessionId: ks.getSessionId(cp) }); } } } } return supportedKS; } /** * Returns key systems supported by this player for the given PSSH * initializationData. Only key systems supported by this player * that have protection data present will be returned. Key systems are returned in priority order * (highest priority first) * * @param {ArrayBuffer} initData Concatenated PSSH data for all DRMs * supported by the content * @param {ProtectionData} protDataSet user specified protection data - license server url etc * supported by the content * @returns {Array.&lt;Object&gt;} array of objects indicating which supported key * systems were found. Empty array is returned if no * supported key systems were found * @memberof module:ProtectionKeyController * @instance */ function getSupportedKeySystems(initData, protDataSet) { let supportedKS = []; let pssh = CommonEncryption.parsePSSHList(initData); let ks, keySystemString, shouldNotFilterOutKeySystem; for (let ksIdx = 0; ksIdx &lt; keySystems.length; ++ksIdx) { ks = keySystems[ksIdx]; keySystemString = ks.systemString; shouldNotFilterOutKeySystem = (protDataSet) ? keySystemString in protDataSet : true; if (ks.uuid in pssh &amp;&amp; shouldNotFilterOutKeySystem) { supportedKS.push({ ks: ks, initData: pssh[ks.uuid], cdmData: ks.getCDMData(), sessionId: ks.getSessionId() }); } } return supportedKS; } /** * Returns the license server implementation data that should be used for this request. * * @param {KeySystem} keySystem the key system * associated with this license request * @param {ProtectionData} protData protection data to use for the * request * @param {string} [messageType=&quot;license-request&quot;] the message type associated with this * request. Supported message types can be found * {@link https://w3c.github.io/encrypted-media/#idl-def-MediaKeyMessageType|here}. * @returns {LicenseServer|null} the license server * implementation that should be used for this request or null if the player should not * pass messages of the given type to a license server * @memberof module:ProtectionKeyController * @instance * */ function getLicenseServer(keySystem, protData, messageType) { // Our default server implementations do not do anything with &quot;license-release&quot; or // &quot;individualization-request&quot; messages, so we just send a success event if (messageType === 'license-release' || messageType === 'individualization-request') { return null; } let licenseServerData = null; if (protData &amp;&amp; protData.hasOwnProperty('drmtoday')) { licenseServerData = DRMToday(context).getInstance({ BASE64: BASE64 }); } else if (keySystem.systemString === ProtectionConstants.WIDEVINE_KEYSTEM_STRING) { licenseServerData = Widevine(context).getInstance(); } else if (keySystem.systemString === ProtectionConstants.PLAYREADY_KEYSTEM_STRING) { licenseServerData = PlayReady(context).getInstance(); } else if (keySystem.systemString === ProtectionConstants.CLEARKEY_KEYSTEM_STRING) { licenseServerData = ClearKey(context).getInstance(); } return licenseServerData; } /** * Allows application-specific retrieval of ClearKey keys. * * @param {KeySystem} clearkeyKeySystem They exact ClearKey System to be used * @param {ProtectionData} protData protection data to use for the * request * @param {ArrayBuffer} message the key message from the CDM * @return {ClearKeyKeySet|null} the clear keys associated with * the request or null if no keys can be returned by this function * @memberof module:ProtectionKeyController * @instance */ function processClearKeyLicenseRequest(clearkeyKeySystem, protData, message) { try { return clearkeyKeySystem.getClearKeysFromProtectionData(protData, message); } catch (error) { logger.error('Failed to retrieve clearkeys from ProtectionData'); return null; } } function setProtectionData(protectionDataSet) { var getProtectionData = function (keySystemString) { var protData = null; if (protectionDataSet) { protData = (keySystemString in protectionDataSet) ? protectionDataSet[keySystemString] : null; } return protData; }; for (var i = 0; i &lt; keySystems.length; i++) { var keySystem = keySystems[i]; if (keySystem.hasOwnProperty('init')) { keySystem.init(getProtectionData(keySystem.systemString)); } } } instance = { initialize: initialize, setProtectionData: setProtectionData, isClearKey: isClearKey, initDataEquals: initDataEquals, getKeySystems: getKeySystems, getKeySystemBySystemString: getKeySystemBySystemString, getSupportedKeySystemsFromContentProtection: getSupportedKeySystemsFromContentProtection, getSupportedKeySystems: getSupportedKeySystems, getLicenseServer: getLicenseServer, processClearKeyLicenseRequest: processClearKeyLicenseRequest, setConfig: setConfig }; return instance; } ProtectionKeyController.__dashjs_factory_name = 'ProtectionKeyController'; export default dashjs.FactoryMaker.getSingletonFactory(ProtectionKeyController); /* jshint ignore:line */ × Search results Close "},"streaming_models_URIFragmentModel.js.html":{"id":"streaming_models_URIFragmentModel.js.html","title":"Source: streaming/models/URIFragmentModel.js","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Source: streaming/models/URIFragmentModel.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ import URIFragmentData from '../vo/URIFragmentData'; import FactoryMaker from '../../core/FactoryMaker'; /** * Model class managing URI fragments. */ function URIFragmentModel() { let instance, URIFragmentDataVO; /** * @param {string} uri The URI to parse for fragment extraction * @memberof module:URIFragmentModel * @instance */ function initialize(uri) { URIFragmentDataVO = new URIFragmentData(); if (!uri) return null; const hashIndex = uri.indexOf('#'); if (hashIndex !== -1) { const fragments = uri.substr(hashIndex + 1).split('&amp;'); for (let i = 0, len = fragments.length; i &lt; len; ++i) { const fragment = fragments[i]; const equalIndex = fragment.indexOf('='); if (equalIndex !== -1) { const key = fragment.substring(0,equalIndex); if (URIFragmentDataVO.hasOwnProperty(key)) { URIFragmentDataVO[key] = fragment.substr(equalIndex + 1); } } } } } /** * @returns {URIFragmentData} Object containing supported URI fragments * @memberof module:URIFragmentModel * @instance */ function getURIFragmentData() { return URIFragmentDataVO; } instance = { initialize: initialize, getURIFragmentData: getURIFragmentData }; return instance; } URIFragmentModel.__dashjs_factory_name = 'URIFragmentModel'; export default FactoryMaker.getSingletonFactory(URIFragmentModel); × Search results Close "},"streaming_utils_URLUtils.js.html":{"id":"streaming_utils_URLUtils.js.html","title":"Source: streaming/utils/URLUtils.js","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Source: streaming/utils/URLUtils.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ import FactoryMaker from '../../core/FactoryMaker'; /** * @module URLUtils * @description Provides utility functions for operating on URLs. * Initially this is simply a method to determine the Base URL of a URL, but * should probably include other things provided all over the place such as * determining whether a URL is relative/absolute, resolving two paths etc. */ function URLUtils() { let resolveFunction; const schemeRegex = /^[a-z][a-z0-9+\\-.]*:/i; const httpUrlRegex = /^https?:\\/\\//i; const httpsUrlRegex = /^https:\\/\\//i; const originRegex = /^([a-z][a-z0-9+\\-.]*:\\/\\/[^\\/]+)\\/?/i; /** * Resolves a url given an optional base url * Uses window.URL to do the resolution. * * @param {string} url * @param {string} [baseUrl] * @return {string} * @memberof module:URLUtils * @instance * @private */ const nativeURLResolver = (url, baseUrl) =&gt; { try { // this will throw if baseurl is undefined, invalid etc return new window.URL(url, baseUrl).toString(); } catch (e) { return url; } }; /** * Resolves a url given an optional base url * Does not resolve ./, ../ etc but will do enough to construct something * which will satisfy XHR etc when window.URL is not available ie * IE11/node etc. * * @param {string} url * @param {string} [baseUrl] * @return {string} * @memberof module:URLUtils * @instance * @private */ const dumbURLResolver = (url, baseUrl) =&gt; { let baseUrlParseFunc = parseBaseUrl; if (!baseUrl) { return url; } if (!isRelative(url)) { return url; } if (isPathAbsolute(url)) { baseUrlParseFunc = parseOrigin; } if (isSchemeRelative(url)) { baseUrlParseFunc = parseScheme; } const base = baseUrlParseFunc(baseUrl); const joinChar = base.charAt(base.length - 1) !== '/' &amp;&amp; url.charAt(0) !== '/' ? '/' : ''; return [base, url].join(joinChar); }; function setup() { try { const u = new window.URL('x', 'http://y'); //jshint ignore:line resolveFunction = nativeURLResolver; } catch (e) { // must be IE11/Node etc } finally { resolveFunction = resolveFunction || dumbURLResolver; } } /** * Returns a string that contains the Base URL of a URL, if determinable. * @param {string} url - full url * @return {string} * @memberof module:URLUtils * @instance */ function parseBaseUrl(url) { const slashIndex = url.indexOf('/'); const lastSlashIndex = url.lastIndexOf('/'); if (slashIndex !== -1) { // if there is only '//' if (lastSlashIndex === slashIndex + 1) { return url; } if (url.indexOf('?') !== -1) { url = url.substring(0, url.indexOf('?')); } return url.substring(0, lastSlashIndex + 1); } return ''; } /** * Returns a string that contains the scheme and origin of a URL, * if determinable. * @param {string} url - full url * @return {string} * @memberof module:URLUtils * @instance */ function parseOrigin(url) { const matches = url.match(originRegex); if (matches) { return matches[1]; } return ''; } /** * Returns a string that contains the scheme of a URL, if determinable. * @param {string} url - full url * @return {string} * @memberof module:URLUtils * @instance */ function parseScheme(url) { const matches = url.match(schemeRegex); if (matches) { return matches[0]; } return ''; } /** * Determines whether the url is relative. * @return {bool} * @param {string} url * @memberof module:URLUtils * @instance */ function isRelative(url) { return !schemeRegex.test(url); } /** * Determines whether the url is path-absolute. * @return {bool} * @param {string} url * @memberof module:URLUtils * @instance */ function isPathAbsolute(url) { return isRelative(url) &amp;&amp; url.charAt(0) === '/'; } /** * Determines whether the url is scheme-relative. * @return {bool} * @param {string} url * @memberof module:URLUtils * @instance */ function isSchemeRelative(url) { return url.indexOf('//') === 0; } /** * Determines whether the url is an HTTP-URL as defined in ISO/IEC * 23009-1:2014 3.1.15. ie URL with a fixed scheme of http or https * @return {bool} * @param {string} url * @memberof module:URLUtils * @instance */ function isHTTPURL(url) { return httpUrlRegex.test(url); } /** * Determines whether the supplied url has https scheme * @return {bool} * @param {string} url * @memberof module:URLUtils * @instance */ function isHTTPS(url) { return httpsUrlRegex.test(url); } /** * Resolves a url given an optional base url * @return {string} * @param {string} url * @param {string} [baseUrl] * @memberof module:URLUtils * @instance */ function resolve(url, baseUrl) { return resolveFunction(url, baseUrl); } setup(); const instance = { parseBaseUrl: parseBaseUrl, parseOrigin: parseOrigin, parseScheme: parseScheme, isRelative: isRelative, isPathAbsolute: isPathAbsolute, isSchemeRelative: isSchemeRelative, isHTTPURL: isHTTPURL, isHTTPS: isHTTPS, resolve: resolve }; return instance; } URLUtils.__dashjs_factory_name = 'URLUtils'; export default FactoryMaker.getSingletonFactory(URLUtils); × Search results Close "},"streaming_net_XHRLoader.js.html":{"id":"streaming_net_XHRLoader.js.html","title":"Source: streaming/net/XHRLoader.js","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Source: streaming/net/XHRLoader.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ import FactoryMaker from '../../core/FactoryMaker'; /** * @module XHRLoader * @description Manages download of resources via HTTP. * @param {Object} cfg - dependencies from parent */ function XHRLoader(cfg) { cfg = cfg || {}; const requestModifier = cfg.requestModifier; let instance; function load(httpRequest) { // Variables will be used in the callback functions let firstProgress = true; /*jshint ignore:line*/ let needFailureReport = true; /*jshint ignore:line*/ let requestStartTime = new Date(); let lastTraceTime = requestStartTime; /*jshint ignore:line*/ let lastTraceReceivedCount = 0; /*jshint ignore:line*/ let request = httpRequest.request; let xhr = new XMLHttpRequest(); xhr.open(httpRequest.method, httpRequest.url, true); if (request.responseType) { xhr.responseType = request.responseType; } if (request.range) { xhr.setRequestHeader('Range', 'bytes=' + request.range); } if (!request.requestStartDate) { request.requestStartDate = requestStartTime; } if (requestModifier) { xhr = requestModifier.modifyRequestHeader(xhr); } xhr.withCredentials = httpRequest.withCredentials; xhr.onload = httpRequest.onload; xhr.onloadend = httpRequest.onend; xhr.onerror = httpRequest.onerror; xhr.onprogress = httpRequest.progress; xhr.onabort = httpRequest.onabort; xhr.send(); httpRequest.response = xhr; } function abort(request) { const x = request.response; x.onloadend = x.onerror = x.onprogress = undefined; //Ignore events from aborted requests. x.abort(); } instance = { load: load, abort: abort }; return instance; } XHRLoader.__dashjs_factory_name = 'XHRLoader'; const factory = FactoryMaker.getClassFactory(XHRLoader); export default factory; × Search results Close "},"streaming_controllers_PlaybackController.js.html":{"id":"streaming_controllers_PlaybackController.js.html","title":"Source: streaming/controllers/PlaybackController.js","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Source: streaming/controllers/PlaybackController.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ import Constants from '../constants/Constants'; import BufferController from './BufferController'; import URIFragmentModel from '../models/URIFragmentModel'; import EventBus from '../../core/EventBus'; import Events from '../../core/events/Events'; import FactoryMaker from '../../core/FactoryMaker'; import Debug from '../../core/Debug'; const LIVE_UPDATE_PLAYBACK_TIME_INTERVAL_MS = 500; const DEFAULT_CATCHUP_PLAYBACK_RATE = 0.05; // Start catching up mechanism for low latency live streaming // when latency goes beyong targetDelay * (1 + LIVE_CATCHUP_START_THRESHOLD) const LIVE_CATCHUP_START_THRESHOLD = 0.35; function PlaybackController() { const context = this.context; const eventBus = EventBus(context).getInstance(); let instance, logger, streamController, metricsModel, dashMetrics, manifestModel, dashManifestModel, adapter, videoModel, currentTime, liveStartTime, wallclockTimeIntervalId, commonEarliestTime, liveDelay, bufferedRange, streamInfo, isDynamic, mediaPlayerModel, playOnceInitialized, lastLivePlaybackTime, originalPlaybackRate, catchingUp, availabilityStartTime; let catchUpPlaybackRate = DEFAULT_CATCHUP_PLAYBACK_RATE; function setup() { logger = Debug(context).getInstance().getLogger(instance); reset(); } function initialize(StreamInfo) { streamInfo = StreamInfo; addAllListeners(); isDynamic = streamInfo.manifestInfo.isDynamic; liveStartTime = streamInfo.start; eventBus.on(Events.DATA_UPDATE_COMPLETED, onDataUpdateCompleted, this); eventBus.on(Events.BYTES_APPENDED_END_FRAGMENT, onBytesAppended, this); eventBus.on(Events.BUFFER_LEVEL_STATE_CHANGED, onBufferLevelStateChanged, this); eventBus.on(Events.PERIOD_SWITCH_STARTED, onPeriodSwitchStarted, this); eventBus.on(Events.PLAYBACK_PROGRESS, onPlaybackProgression, this); eventBus.on(Events.PLAYBACK_TIME_UPDATED, onPlaybackProgression, this); if (playOnceInitialized) { playOnceInitialized = false; play(); } } function onPeriodSwitchStarted(e) { if (!isDynamic &amp;&amp; e.fromStreamInfo &amp;&amp; commonEarliestTime[e.fromStreamInfo.id] !== undefined) { delete bufferedRange[e.fromStreamInfo.id]; delete commonEarliestTime[e.fromStreamInfo.id]; } } function getTimeToStreamEnd() { const startTime = getStreamStartTime(true); const offset = isDynamic ? startTime - streamInfo.start : 0; return parseFloat((startTime + (streamInfo.duration - offset) - getTime()).toFixed(5)); } function play() { if (streamInfo &amp;&amp; videoModel &amp;&amp; videoModel.getElement()) { videoModel.play(); } else { playOnceInitialized = true; } } function isPaused() { return streamInfo &amp;&amp; videoModel ? videoModel.isPaused() : null; } function pause() { if (streamInfo &amp;&amp; videoModel) { videoModel.pause(); } } function isSeeking() { return streamInfo &amp;&amp; videoModel ? videoModel.isSeeking() : null; } function seek(time) { if (streamInfo &amp;&amp; videoModel) { eventBus.trigger(Events.PLAYBACK_SEEK_ASKED); logger.info('Requesting seek to time: ' + time); videoModel.setCurrentTime(time); } } function getTime() { return streamInfo &amp;&amp; videoModel ? videoModel.getTime() : null; } function getPlaybackRate() { return streamInfo &amp;&amp; videoModel ? videoModel.getPlaybackRate() : null; } function getPlayedRanges() { return streamInfo &amp;&amp; videoModel ? videoModel.getPlayedRanges() : null; } function getEnded() { return streamInfo &amp;&amp; videoModel ? videoModel.getEnded() : null; } function getIsDynamic() { return isDynamic; } function getStreamController() { return streamController; } function setLiveStartTime(value) { liveStartTime = value; } function getLiveStartTime() { return liveStartTime; } function setCatchUpPlaybackRate(value) { catchUpPlaybackRate = value; // If value == 0.0, deactivate catchup mechanism if (value === 0.0 &amp;&amp; getPlaybackRate() &gt; 1.0) { stopPlaybackCatchUp(); } } function getCatchUpPlaybackRate() { return catchUpPlaybackRate; } /** * Computes the desirable delay for the live edge to avoid a risk of getting 404 when playing at the bleeding edge * @param {number} fragmentDuration - seconds? * @param {number} dvrWindowSize - seconds? * @returns {number} object * @memberof PlaybackController# */ function computeLiveDelay(fragmentDuration, dvrWindowSize) { const mpd = dashManifestModel.getMpd(manifestModel.getValue()); let delay; let ret; const END_OF_PLAYLIST_PADDING = 10; if (mediaPlayerModel.getUseSuggestedPresentationDelay() &amp;&amp; mpd.hasOwnProperty(Constants.SUGGESTED_PRESENTATION_DELAY)) { delay = mpd.suggestedPresentationDelay; } else if (mediaPlayerModel.getLowLatencyEnabled()) { delay = 0; } else if (mediaPlayerModel.getLiveDelay()) { delay = mediaPlayerModel.getLiveDelay(); // If set by user, this value takes precedence } else if (!isNaN(fragmentDuration)) { delay = fragmentDuration * mediaPlayerModel.getLiveDelayFragmentCount(); } else { delay = streamInfo.manifestInfo.minBufferTime * 2; } if (mpd.availabilityStartTime) { availabilityStartTime = mpd.availabilityStartTime.getTime(); } if (dvrWindowSize &gt; 0) { // cap target latency to: // - dvrWindowSize / 2 for short playlists // - dvrWindowSize - END_OF_PLAYLIST_PADDING for longer playlists const targetDelayCapping = Math.max(dvrWindowSize - END_OF_PLAYLIST_PADDING, dvrWindowSize / 2); ret = Math.min(delay, targetDelayCapping); } else { ret = delay; } liveDelay = ret; return ret; } function getLiveDelay() { return liveDelay; } function getCurrentLiveLatency() { if (!isDynamic || isNaN(availabilityStartTime)) { return NaN; } const currentTime = getTime(); if (isNaN(currentTime) || currentTime === 0) { return 0; } return ((Math.round(new Date().getTime() - (currentTime * 1000 + availabilityStartTime))) / 1000).toFixed(3); } function startPlaybackCatchUp() { if (videoModel) { const playbackRate = 1 + getCatchUpPlaybackRate(); const currentRate = getPlaybackRate(); if (playbackRate !== currentRate) { catchingUp = true; logger.info('Starting live catchup mechanism. Setting playback rate to', playbackRate); originalPlaybackRate = currentRate; videoModel.getElement().playbackRate = playbackRate; eventBus.trigger(Events.PLAYBACK_CATCHUP_START, { sender: instance }); } } } function stopPlaybackCatchUp() { if (videoModel) { const playbackRate = originalPlaybackRate || 1; if (playbackRate !== getPlaybackRate()) { catchingUp = false; logger.info('Stopping live catchup mechanism. Setting playback rate to', playbackRate); videoModel.getElement().playbackRate = playbackRate; eventBus.trigger(Events.PLAYBACK_CATCHUP_END, { sender: instance }); } } } function reset() { currentTime = 0; liveStartTime = NaN; playOnceInitialized = false; commonEarliestTime = {}; liveDelay = 0; availabilityStartTime = 0; catchUpPlaybackRate = DEFAULT_CATCHUP_PLAYBACK_RATE; bufferedRange = {}; if (videoModel) { eventBus.off(Events.DATA_UPDATE_COMPLETED, onDataUpdateCompleted, this); eventBus.off(Events.BUFFER_LEVEL_STATE_CHANGED, onBufferLevelStateChanged, this); eventBus.off(Events.BYTES_APPENDED_END_FRAGMENT, onBytesAppended, this); eventBus.off(Events.PERIOD_SWITCH_STARTED, onPeriodSwitchStarted, this); eventBus.off(Events.PLAYBACK_PROGRESS, onPlaybackProgression, this); eventBus.off(Events.PLAYBACK_TIME_UPDATED, onPlaybackProgression, this); stopUpdatingWallclockTime(); removeAllListeners(); } wallclockTimeIntervalId = null; videoModel = null; streamInfo = null; isDynamic = null; } function setConfig(config) { if (!config) return; if (config.streamController) { streamController = config.streamController; } if (config.metricsModel) { metricsModel = config.metricsModel; } if (config.dashMetrics) { dashMetrics = config.dashMetrics; } if (config.manifestModel) { manifestModel = config.manifestModel; } if (config.dashManifestModel) { dashManifestModel = config.dashManifestModel; } if (config.mediaPlayerModel) { mediaPlayerModel = config.mediaPlayerModel; } if (config.adapter) { adapter = config.adapter; } if (config.videoModel) { videoModel = config.videoModel; } } function getStartTimeFromUriParameters() { const fragData = URIFragmentModel(context).getInstance().getURIFragmentData(); let uriParameters; if (fragData) { uriParameters = {}; const r = parseInt(fragData.r, 10); if (r &gt;= 0 &amp;&amp; streamInfo &amp;&amp; r &lt; streamInfo.manifestInfo.DVRWindowSize &amp;&amp; fragData.t === null) { fragData.t = Math.floor(Date.now() / 1000) - streamInfo.manifestInfo.DVRWindowSize + r; } uriParameters.fragS = parseInt(fragData.s, 10); uriParameters.fragT = parseInt(fragData.t, 10); } return uriParameters; } /** * @param {boolean} ignoreStartOffset - ignore URL fragment start offset if true * @param {number} liveEdge - liveEdge value * @returns {number} object * @memberof PlaybackController# */ function getStreamStartTime(ignoreStartOffset, liveEdge) { let presentationStartTime; let startTimeOffset = NaN; const uriParameters = getStartTimeFromUriParameters(); if (uriParameters) { if (!ignoreStartOffset) { startTimeOffset = !isNaN(uriParameters.fragS) ? uriParameters.fragS : uriParameters.fragT; } else { startTimeOffset = streamInfo.start; } } else { // handle case where no media fragments are parsed from the manifest URL startTimeOffset = 0; } if (isDynamic) { if (!isNaN(startTimeOffset)) { presentationStartTime = startTimeOffset - (streamInfo.manifestInfo.availableFrom.getTime() / 1000); if (presentationStartTime &gt; liveStartTime || presentationStartTime &lt; (!isNaN(liveEdge) ? (liveEdge - streamInfo.manifestInfo.DVRWindowSize) : NaN)) { presentationStartTime = null; } } presentationStartTime = presentationStartTime || liveStartTime; } else { if (!isNaN(startTimeOffset) &amp;&amp; startTimeOffset &lt; Math.max(streamInfo.manifestInfo.duration, streamInfo.duration) &amp;&amp; startTimeOffset &gt;= 0) { presentationStartTime = startTimeOffset; } else { let earliestTime = commonEarliestTime[streamInfo.id]; //set by ready bufferStart after first onBytesAppended presentationStartTime = earliestTime !== undefined ? Math.max(earliestTime.audio !== undefined ? earliestTime.audio : 0, earliestTime.video !== undefined ? earliestTime.video : 0, streamInfo.start) : streamInfo.start; } } return presentationStartTime; } function getActualPresentationTime(currentTime) { const metrics = metricsModel.getReadOnlyMetricsFor(Constants.VIDEO) || metricsModel.getReadOnlyMetricsFor(Constants.AUDIO); const DVRMetrics = dashMetrics.getCurrentDVRInfo(metrics); const DVRWindow = DVRMetrics ? DVRMetrics.range : null; let actualTime; if (!DVRWindow) return NaN; if (currentTime &gt; DVRWindow.end) { actualTime = Math.max(DVRWindow.end - streamInfo.manifestInfo.minBufferTime * 2, DVRWindow.start); } else if (currentTime + 0.250 &lt; DVRWindow.start) { // Checking currentTime plus 250ms as the 'timeupdate' is fired with a frequency between 4Hz and 66Hz // https://developer.mozilla.org/en-US/docs/Web/Events/timeupdate // http://w3c.github.io/html/single-page.html#offsets-into-the-media-resource actualTime = DVRWindow.start; } else { return currentTime; } return actualTime; } function startUpdatingWallclockTime() { if (wallclockTimeIntervalId !== null) return; const tick = function () { onWallclockTime(); }; wallclockTimeIntervalId = setInterval(tick, mediaPlayerModel.getWallclockTimeUpdateInterval()); } function stopUpdatingWallclockTime() { clearInterval(wallclockTimeIntervalId); wallclockTimeIntervalId = null; } function updateCurrentTime() { if (isPaused() || !isDynamic || videoModel.getReadyState() === 0) return; const currentTime = getTime(); const actualTime = getActualPresentationTime(currentTime); const timeChanged = (!isNaN(actualTime) &amp;&amp; actualTime !== currentTime); if (timeChanged) { seek(actualTime); } } function onDataUpdateCompleted(e) { if (e.error) return; const representationInfo = adapter.convertDataToRepresentationInfo(e.currentRepresentation); const info = representationInfo.mediaInfo.streamInfo; if (streamInfo.id !== info.id) return; streamInfo = info; updateCurrentTime(); } function onCanPlay() { eventBus.trigger(Events.CAN_PLAY); } function onPlaybackStart() { logger.info('Native video element event: play'); updateCurrentTime(); startUpdatingWallclockTime(); eventBus.trigger(Events.PLAYBACK_STARTED, { startTime: getTime() }); } function onPlaybackWaiting() { logger.info('Native video element event: waiting'); eventBus.trigger(Events.PLAYBACK_WAITING, { playingTime: getTime() }); } function onPlaybackPlaying() { logger.info('Native video element event: playing'); eventBus.trigger(Events.PLAYBACK_PLAYING, { playingTime: getTime() }); } function onPlaybackPaused() { logger.info('Native video element event: pause'); eventBus.trigger(Events.PLAYBACK_PAUSED, { ended: getEnded() }); } function onPlaybackSeeking() { const seekTime = getTime(); logger.info('Seeking to: ' + seekTime); startUpdatingWallclockTime(); eventBus.trigger(Events.PLAYBACK_SEEKING, { seekTime: seekTime }); } function onPlaybackSeeked() { logger.info('Native video element event: seeked'); eventBus.trigger(Events.PLAYBACK_SEEKED); } function onPlaybackTimeUpdated() { const time = getTime(); currentTime = time; eventBus.trigger(Events.PLAYBACK_TIME_UPDATED, { timeToEnd: getTimeToStreamEnd(), time: time }); } function updateLivePlaybackTime() { const now = Date.now(); if (!lastLivePlaybackTime || now &gt; lastLivePlaybackTime + LIVE_UPDATE_PLAYBACK_TIME_INTERVAL_MS) { lastLivePlaybackTime = now; onPlaybackTimeUpdated(); } } function onPlaybackProgress() { eventBus.trigger(Events.PLAYBACK_PROGRESS); } function onPlaybackRateChanged() { const rate = getPlaybackRate(); logger.info('Native video element event: ratechange: ', rate); eventBus.trigger(Events.PLAYBACK_RATE_CHANGED, { playbackRate: rate }); } function onPlaybackMetaDataLoaded() { logger.info('Native video element event: loadedmetadata'); eventBus.trigger(Events.PLAYBACK_METADATA_LOADED); startUpdatingWallclockTime(); } function onPlaybackEnded() { logger.info('Native video element event: ended'); pause(); stopUpdatingWallclockTime(); eventBus.trigger(Events.PLAYBACK_ENDED); } function onPlaybackError(event) { const target = event.target || event.srcElement; eventBus.trigger(Events.PLAYBACK_ERROR, { error: target.error }); } function onWallclockTime() { eventBus.trigger(Events.WALLCLOCK_TIME_UPDATED, { isDynamic: isDynamic, time: new Date() }); // Updates playback time for paused dynamic streams // (video element doesn't call timeupdate when the playback is paused) if (getIsDynamic() &amp;&amp; isPaused()) { updateLivePlaybackTime(); } } function checkTimeInRanges(time, ranges) { if (ranges &amp;&amp; ranges.length &gt; 0) { for (let i = 0, len = ranges.length; i &lt; len; i++) { if (time &gt;= ranges.start(i) &amp;&amp; time &lt; ranges.end(i)) { return true; } } } return false; } function onPlaybackProgression() { if (isDynamic &amp;&amp; mediaPlayerModel.getLowLatencyEnabled() &amp;&amp; getCatchUpPlaybackRate() &gt; 0.0) { if (!catchingUp &amp;&amp; needToCatchUp()) { startPlaybackCatchUp(); } else if (stopCatchingUp()) { stopPlaybackCatchUp(); } } } function needToCatchUp() { return getCurrentLiveLatency() &gt; (mediaPlayerModel.getLiveDelay() * (1 + LIVE_CATCHUP_START_THRESHOLD)); } function stopCatchingUp() { return getCurrentLiveLatency() &lt;= (mediaPlayerModel.getLiveDelay() ); } function onBytesAppended(e) { let earliestTime, initialStartTime; let ranges = e.bufferedRanges; if (!ranges || !ranges.length) return; if (commonEarliestTime[streamInfo.id] &amp;&amp; commonEarliestTime[streamInfo.id].started === true) { //stream has already been started. return; } const type = e.sender.getType(); if (bufferedRange[streamInfo.id] === undefined) { bufferedRange[streamInfo.id] = []; } bufferedRange[streamInfo.id][type] = ranges; if (commonEarliestTime[streamInfo.id] === undefined) { commonEarliestTime[streamInfo.id] = []; commonEarliestTime[streamInfo.id].started = false; } if (commonEarliestTime[streamInfo.id][type] === undefined) { commonEarliestTime[streamInfo.id][type] = Math.max(ranges.start(0), streamInfo.start); } const hasVideoTrack = streamController.isVideoTrackPresent(); const hasAudioTrack = streamController.isAudioTrackPresent(); initialStartTime = getStreamStartTime(false); if (hasAudioTrack &amp;&amp; hasVideoTrack) { //current stream has audio and video contents if (!isNaN(commonEarliestTime[streamInfo.id].audio) &amp;&amp; !isNaN(commonEarliestTime[streamInfo.id].video)) { if (commonEarliestTime[streamInfo.id].audio &lt; commonEarliestTime[streamInfo.id].video) { // common earliest is video time // check buffered audio range has video time, if ok, we seek, otherwise, we wait some other data earliestTime = commonEarliestTime[streamInfo.id].video &gt; initialStartTime ? commonEarliestTime[streamInfo.id].video : initialStartTime; ranges = bufferedRange[streamInfo.id].audio; } else { // common earliest is audio time // check buffered video range has audio time, if ok, we seek, otherwise, we wait some other data earliestTime = commonEarliestTime[streamInfo.id].audio &gt; initialStartTime ? commonEarliestTime[streamInfo.id].audio : initialStartTime; ranges = bufferedRange[streamInfo.id].video; } if (checkTimeInRanges(earliestTime, ranges)) { if (!isSeeking()) { seek(earliestTime); } commonEarliestTime[streamInfo.id].started = true; } } } else { //current stream has only audio or only video content if (commonEarliestTime[streamInfo.id][type]) { earliestTime = commonEarliestTime[streamInfo.id][type] &gt; initialStartTime ? commonEarliestTime[streamInfo.id][type] : initialStartTime; if (!isSeeking()) { seek(earliestTime); } commonEarliestTime[streamInfo.id].started = true; } } } function onBufferLevelStateChanged(e) { // do not stall playback when get an event from Stream that is not active if (e.streamInfo.id !== streamInfo.id) return; videoModel.setStallState(e.mediaType, e.state === BufferController.BUFFER_EMPTY); } function addAllListeners() { videoModel.addEventListener('canplay', onCanPlay); videoModel.addEventListener('play', onPlaybackStart); videoModel.addEventListener('waiting', onPlaybackWaiting); videoModel.addEventListener('playing', onPlaybackPlaying); videoModel.addEventListener('pause', onPlaybackPaused); videoModel.addEventListener('error', onPlaybackError); videoModel.addEventListener('seeking', onPlaybackSeeking); videoModel.addEventListener('seeked', onPlaybackSeeked); videoModel.addEventListener('timeupdate', onPlaybackTimeUpdated); videoModel.addEventListener('progress', onPlaybackProgress); videoModel.addEventListener('ratechange', onPlaybackRateChanged); videoModel.addEventListener('loadedmetadata', onPlaybackMetaDataLoaded); videoModel.addEventListener('ended', onPlaybackEnded); } function removeAllListeners() { videoModel.removeEventListener('canplay', onCanPlay); videoModel.removeEventListener('play', onPlaybackStart); videoModel.removeEventListener('waiting', onPlaybackWaiting); videoModel.removeEventListener('playing', onPlaybackPlaying); videoModel.removeEventListener('pause', onPlaybackPaused); videoModel.removeEventListener('error', onPlaybackError); videoModel.removeEventListener('seeking', onPlaybackSeeking); videoModel.removeEventListener('seeked', onPlaybackSeeked); videoModel.removeEventListener('timeupdate', onPlaybackTimeUpdated); videoModel.removeEventListener('progress', onPlaybackProgress); videoModel.removeEventListener('ratechange', onPlaybackRateChanged); videoModel.removeEventListener('loadedmetadata', onPlaybackMetaDataLoaded); videoModel.removeEventListener('ended', onPlaybackEnded); } instance = { initialize: initialize, setConfig: setConfig, getStartTimeFromUriParameters: getStartTimeFromUriParameters, getStreamStartTime: getStreamStartTime, getTimeToStreamEnd: getTimeToStreamEnd, getTime: getTime, getPlaybackRate: getPlaybackRate, getPlayedRanges: getPlayedRanges, getEnded: getEnded, getIsDynamic: getIsDynamic, getStreamController: getStreamController, setCatchUpPlaybackRate: setCatchUpPlaybackRate, setLiveStartTime: setLiveStartTime, getLiveStartTime: getLiveStartTime, computeLiveDelay: computeLiveDelay, getLiveDelay: getLiveDelay, getCurrentLiveLatency: getCurrentLiveLatency, play: play, isPaused: isPaused, pause: pause, isSeeking: isSeeking, seek: seek, reset: reset }; setup(); return instance; } PlaybackController.__dashjs_factory_name = 'PlaybackController'; export default FactoryMaker.getSingletonFactory(PlaybackController); × Search results Close "},"streaming_vo_metrics_PlayList.js.html":{"id":"streaming_vo_metrics_PlayList.js.html","title":"Source: streaming/vo/metrics/PlayList.js","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Source: streaming/vo/metrics/PlayList.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ /** * @classdesc a PlayList from ISO23009-1 Annex D, this Object holds reference to the playback session information */ class PlayList { /** * @class */ constructor() { /** * Timestamp of the user action that starts the playback stream... * @public */ this.start = null; /** * Presentation time at which playout was requested by the user... * @public */ this.mstart = null; /** * Type of user action which triggered playout * - New playout request (e.g. initial playout or seeking) * - Resume from pause * - Other user request (e.g. user-requested quality change) * - Start of a metrics collection stream (hence earlier entries in the play list not collected) * @public */ this.starttype = null; /** * List of streams of continuous rendering of decoded samples. * @public */ this.trace = []; } } /* Public Static Constants */ PlayList.INITIAL_PLAYOUT_START_REASON = 'initial_playout'; PlayList.SEEK_START_REASON = 'seek'; PlayList.RESUME_FROM_PAUSE_START_REASON = 'resume'; PlayList.METRICS_COLLECTION_START_REASON = 'metrics_collection_start'; /** * @classdesc a PlayList.Trace from ISO23009-1 Annex D */ class PlayListTrace { /** * @class */ constructor() { /** * The value of the Representation@id of the Representation from which the samples were taken. * @type {string} * @public */ this.representationid = null; /** * If not present, this metrics concerns the Representation as a whole. * If present, subreplevel indicates the greatest value of any * Subrepresentation@level being rendered. * @type {number} * @public */ this.subreplevel = null; /** * The time at which the first sample was rendered * @type {number} * @public */ this.start = null; /** * The presentation time of the first sample rendered. * @type {number} * @public */ this.mstart = null; /** * The duration of the continuously presented samples (which is the same in real time and media time). &quot;Continuously presented&quot; means that the media clock continued to advance at the playout speed throughout the interval. NOTE: the spec does not call out the units, but all other durations etc are in ms, and we use ms too. * @type {number} * @public */ this.duration = null; /** * The playback speed relative to normal playback speed (i.e.normal forward playback speed is 1.0). * @type {number} * @public */ this.playbackspeed = null; /** * The reason why continuous presentation of this Representation was stopped. * representation switch * rebuffering * user request * end of Period * end of Stream * end of content * end of a metrics collection period * * @type {string} * @public */ this.stopreason = null; } } PlayListTrace.REPRESENTATION_SWITCH_STOP_REASON = 'representation_switch'; PlayListTrace.REBUFFERING_REASON = 'rebuffering'; PlayListTrace.USER_REQUEST_STOP_REASON = 'user_request'; PlayListTrace.END_OF_PERIOD_STOP_REASON = 'end_of_period'; PlayListTrace.END_OF_CONTENT_STOP_REASON = 'end_of_content'; PlayListTrace.METRICS_COLLECTION_STOP_REASON = 'metrics_collection_end'; PlayListTrace.FAILURE_STOP_REASON = 'failure'; export { PlayList, PlayListTrace }; × Search results Close "},"streaming_protection_servers_PlayReady.js.html":{"id":"streaming_protection_servers_PlayReady.js.html","title":"Source: streaming/protection/servers/PlayReady.js","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Source: streaming/protection/servers/PlayReady.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ /* global escape: true */ /** * Microsoft PlayReady Test License Server * * For testing content that uses the PlayReady test server at * * @implements LicenseServer * @class */ function PlayReady() { let instance; const soap = 'http://schemas.xmlsoap.org/soap/envelope/'; function uintToString(arrayBuffer) { const encodedString = String.fromCharCode.apply(null, new Uint8Array(arrayBuffer)); const decodedString = decodeURIComponent(escape(encodedString)); return decodedString; } function parseServerResponse(serverResponse) { if (window.DOMParser) { const stringResponse = uintToString(serverResponse); const parser = new window.DOMParser(); const xmlDoc = parser.parseFromString(stringResponse, 'text/xml'); const envelope = xmlDoc ? xmlDoc.getElementsByTagNameNS(soap, 'Envelope')[0] : null; const body = envelope ? envelope.getElementsByTagNameNS(soap, 'Body')[0] : null; const fault = body ? body.getElementsByTagNameNS(soap, 'Fault')[0] : null; if (fault) { return null; } } return serverResponse; } function parseErrorResponse(serverResponse) { let faultstring = ''; let statusCode = ''; let message = ''; let idStart = -1; let idEnd = -1; if (window.DOMParser) { const stringResponse = uintToString(serverResponse); const parser = new window.DOMParser(); const xmlDoc = parser.parseFromString(stringResponse, 'text/xml'); const envelope = xmlDoc ? xmlDoc.getElementsByTagNameNS(soap, 'Envelope')[0] : null; const body = envelope ? envelope.getElementsByTagNameNS(soap, 'Body')[0] : null; const fault = body ? body.getElementsByTagNameNS(soap, 'Fault')[0] : null; const detail = fault ? fault.getElementsByTagName('detail')[0] : null; const exception = detail ? detail.getElementsByTagName('Exception')[0] : null; let node = null; if (fault === null) { return stringResponse; } node = fault.getElementsByTagName('faultstring')[0].firstChild; faultstring = node ? node.nodeValue : null; if (exception !== null) { node = exception.getElementsByTagName('StatusCode')[0]; statusCode = node ? node.firstChild.nodeValue : null; node = exception.getElementsByTagName('Message')[0]; message = node ? node.firstChild.nodeValue : null; idStart = message ? message.lastIndexOf('[') + 1 : -1; idEnd = message ? message.indexOf(']') : -1; message = message ? message.substring(idStart, idEnd) : ''; } } let errorString = `code: ${statusCode}, name: ${faultstring}`; if (message) { errorString += `, message: ${message}`; } return errorString; } function getServerURLFromMessage(url /*, message, messageType*/) { return url; } function getHTTPMethod(/*messageType*/) { return 'POST'; } function getResponseType(/*keySystemStr, messageType*/) { return 'arraybuffer'; } function getLicenseMessage(serverResponse/*, keySystemStr, messageType*/) { return parseServerResponse.call(this, serverResponse); } function getErrorResponse(serverResponse/*, keySystemStr, messageType*/) { return parseErrorResponse.call(this, serverResponse); } instance = { getServerURLFromMessage: getServerURLFromMessage, getHTTPMethod: getHTTPMethod, getResponseType: getResponseType, getLicenseMessage: getLicenseMessage, getErrorResponse: getErrorResponse }; return instance; } PlayReady.__dashjs_factory_name = 'PlayReady'; export default dashjs.FactoryMaker.getSingletonFactory(PlayReady); /* jshint ignore:line */ × Search results Close "},"streaming_PreBufferSink.js.html":{"id":"streaming_PreBufferSink.js.html","title":"Source: streaming/PreBufferSink.js","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Source: streaming/PreBufferSink.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ import Debug from '../core/Debug'; import FactoryMaker from '../core/FactoryMaker'; /** * This is a sink that is used to temporarily hold onto media chunks before a video element is added. * The discharge() function is used to get the chunks out of the PreBuffer for adding to a real SourceBuffer. * * @class PreBufferSink * @implements FragmentSink */ function PreBufferSink(onAppendedCallback) { const context = this.context; let instance, logger; let chunks = []; let outstandingInit; let onAppended = onAppendedCallback; function setup() { logger = Debug(context).getInstance().getLogger(instance); } function reset() { chunks = []; outstandingInit = null; onAppended = null; } function append(chunk) { if (chunk.segmentType !== 'InitializationSegment') { //Init segments are stored in the initCache. chunks.push(chunk); chunks.sort(function (a, b) { return a.start - b.start; }); outstandingInit = null; } else {//We need to hold an init chunk for when a corresponding media segment is being downloaded when the discharge happens. outstandingInit = chunk; } logger.debug('PreBufferSink appended chunk s: ' + chunk.start + '; e: ' + chunk.end); if (onAppended) { onAppended({ chunk: chunk }); } } function remove(start, end) { chunks = chunks.filter( a =&gt; !((isNaN(end) || a.start &lt; end) &amp;&amp; (isNaN(start) || a.end &gt; start))); //The opposite of the getChunks predicate. } //Nothing async, nothing to abort. function abort() { } function getAllBufferRanges() { let ranges = []; for (let i = 0; i &lt; chunks.length; i++) { let chunk = chunks[i]; if (ranges.length === 0 || chunk.start &gt; ranges[ranges.length - 1].end) { ranges.push({ start: chunk.start, end: chunk.end }); } else { ranges[ranges.length - 1].end = chunk.end; } } //Implements TimeRanges interface. So acts just like sourceBuffer.buffered. const timeranges = { start: function (n) { return ranges[n].start; }, end: function (n) { return ranges[n].end; } }; Object.defineProperty(timeranges, 'length', { get: function () { return ranges.length; } }); return timeranges; } function updateTimestampOffset() { // Nothing to do } /** * Return the all chunks in the buffer the lie between times start and end. * Because a chunk cannot be split, this returns the full chunk if any part of its time lies in the requested range. * Chunks are removed from the buffer when they are discharged. * @function PreBufferSink#discharge * @param {?Number} start The start time from which to discharge from the buffer. If NaN, it is regarded as unbounded. * @param {?Number} end The end time from which to discharge from the buffer. If NaN, it is regarded as unbounded. * @returns {Array} The set of chunks from the buffer within the time ranges. */ function discharge(start, end) { const result = getChunksAt(start, end); if (outstandingInit) { result.push(outstandingInit); outstandingInit = null; } remove(start, end); return result; } function getChunksAt(start, end) { return chunks.filter( a =&gt; ((isNaN(end) || a.start &lt; end) &amp;&amp; (isNaN(start) || a.end &gt; start)) ); } instance = { getAllBufferRanges: getAllBufferRanges, append: append, remove: remove, abort: abort, discharge: discharge, reset: reset, updateTimestampOffset: updateTimestampOffset }; setup(); return instance; } PreBufferSink.__dashjs_factory_name = 'PreBufferSink'; const factory = FactoryMaker.getClassFactory(PreBufferSink); export default factory; × Search results Close "},"streaming_protection_vo_ProtectionData.js.html":{"id":"streaming_protection_vo_ProtectionData.js.html","title":"Source: streaming/protection/vo/ProtectionData.js","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Source: streaming/protection/vo/ProtectionData.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ /** * @classdesc Data provided for a particular piece of content to customize license server URLs, * license server HTTP request headers, clearkeys, or other content-specific data * @ignore */ class ProtectionData { /** * @param {string|Object} serverURL a license server URL to use with this key system. * When specified as a string, a single URL will be used regardless of message type. * When specified as an object, the object will have property names for each message * type ({@link https://w3c.github.io/encrypted-media/#idl-def-MediaKeyMessageType|message * types defined here)} with the corresponding property value being the URL to use for * messages of that type * @param {Object} httpRequestHeaders headers to add to the http request * @param {Object} clearkeys defines a set of clear keys that are available to * the key system. Object properties are base64-encoded keyIDs (with no padding). * Corresponding property values are keys, base64-encoded (no padding). * @class */ constructor(serverURL, httpRequestHeaders, clearkeys) { this.serverURL = serverURL; this.httpRequestHeaders = httpRequestHeaders; this.clearkeys = clearkeys; } } /** * License server URL * * @instance * @type string|Object * @name ProtectionData.serverURL * @readonly * @memberof ProtectionData */ /** * HTTP Request Headers for use in license requests. Each property name * in the object is a header name with its corresponding header value being * the property value * * @instance * @type Object * @name ProtectionData.httpRequestsHeaders * @readonly * @memberof ProtectionData */ /** * ClearKey key-pairs that can be used to decrypt the content * * @instance * @type Object * @name ProtectionData.clearkeys * @readonly * @memberof ProtectionData */ export default ProtectionData; × Search results Close "},"streaming_protection_ProtectionEvents.js.html":{"id":"streaming_protection_ProtectionEvents.js.html","title":"Source: streaming/protection/ProtectionEvents.js","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Source: streaming/protection/ProtectionEvents.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ import EventsBase from '../../core/events/EventsBase'; /** * @class * */ class ProtectionEvents extends EventsBase { /** * @description Public facing external events to be used when including protection package. * All public events will be aggregated into the MediaPlayerEvents Class and can be accessed * via MediaPlayer.events. public_ is the prefix that we use to move event names to MediaPlayerEvents. */ constructor () { super(); /** * Event ID for events delivered when the protection set receives * a key message from the CDM * * @ignore */ this.INTERNAL_KEY_MESSAGE = 'internalKeyMessage'; /** * Event ID for events delivered when a key system selection procedure * completes * @ignore */ this.INTERNAL_KEY_SYSTEM_SELECTED = 'internalKeySystemSelected'; /** * Event ID for events delivered when the status of one decryption keys has changed * @ignore */ this.INTERNAL_KEY_STATUS_CHANGED = 'internalkeyStatusChanged'; /** * Event ID for events delivered when a new key has been added * * @constant * @deprecated The latest versions of the EME specification no longer * use this event. {@MediaPlayer.models.protectionModel.eventList.KEY_STATUSES_CHANGED} * is preferred. * @event ProtectionEvents#KEY_ADDED */ this.KEY_ADDED = 'public_keyAdded'; /** * Event ID for events delivered when an error is encountered by the CDM * while processing a license server response message * @event ProtectionEvents#KEY_ERROR */ this.KEY_ERROR = 'public_keyError'; /** * Event ID for events delivered when the protection set receives * a key message from the CDM * @event ProtectionEvents#KEY_MESSAGE */ this.KEY_MESSAGE = 'public_keyMessage'; /** * Event ID for events delivered when a key session close * process has completed * @event ProtectionEvents#KEY_SESSION_CLOSED */ this.KEY_SESSION_CLOSED = 'public_keySessionClosed'; /** * Event ID for events delivered when a new key sessions creation * process has completed * @event ProtectionEvents#KEY_SESSION_CREATED */ this.KEY_SESSION_CREATED = 'public_keySessionCreated'; /** * Event ID for events delivered when a key session removal * process has completed * @event ProtectionEvents#KEY_SESSION_REMOVED */ this.KEY_SESSION_REMOVED = 'public_keySessionRemoved'; /** * Event ID for events delivered when the status of one or more * decryption keys has changed * @event ProtectionEvents#KEY_STATUSES_CHANGED */ this.KEY_STATUSES_CHANGED = 'public_keyStatusesChanged'; /** * Event ID for events delivered when a key system access procedure * has completed * @ignore */ this.KEY_SYSTEM_ACCESS_COMPLETE = 'public_keySystemAccessComplete'; /** * Event ID for events delivered when a key system selection procedure * completes * @event ProtectionEvents#KEY_SYSTEM_SELECTED */ this.KEY_SYSTEM_SELECTED = 'public_keySystemSelected'; /** * Event ID for events delivered when a license request procedure * has completed * @event ProtectionEvents#LICENSE_REQUEST_COMPLETE */ this.LICENSE_REQUEST_COMPLETE = 'public_licenseRequestComplete'; /** * Event ID for needkey/encrypted events * @ignore */ this.NEED_KEY = 'needkey'; /** * Event ID for events delivered when the Protection system is detected and created. * @event ProtectionEvents#PROTECTION_CREATED */ this.PROTECTION_CREATED = 'public_protectioncreated'; /** * Event ID for events delivered when the Protection system is destroyed. * @event ProtectionEvents#PROTECTION_DESTROYED */ this.PROTECTION_DESTROYED = 'public_protectiondestroyed'; /** * Event ID for events delivered when a new server certificate has * been delivered to the CDM * @ignore */ this.SERVER_CERTIFICATE_UPDATED = 'serverCertificateUpdated'; /** * Event ID for events delivered when the process of shutting down * a protection set has completed * @ignore */ this.TEARDOWN_COMPLETE = 'protectionTeardownComplete'; /** * Event ID for events delivered when a HTMLMediaElement has been * associated with the protection set * @ignore */ this.VIDEO_ELEMENT_SELECTED = 'videoElementSelected'; } } let protectionEvents = new ProtectionEvents(); export default protectionEvents; × Search results Close "},"streaming_protection_models_ProtectionModel.js.html":{"id":"streaming_protection_models_ProtectionModel.js.html","title":"Source: streaming/protection/models/ProtectionModel.js","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Source: streaming/protection/models/ProtectionModel.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ /** * Defines the public interface for all ProtectionModel implementations. * * ProtectionModel implementations provide access to particular versions * of the Encrypted Media Extensions (EME) APIs that have been implemented * in a user agent. Developers wishing to add support for a new EME version * found in a target user-agent should add a new instance of this interface * to the * * Applications should not need direct access to this object. All interactions with * the protection system should be performed with * {@link module:ProtectionController} * * @interface ProtectionModel */ let ProtectionModel = function () { }; /** * Returns an array of all initialization data currently used by * active sessions. * @function * @instance * @name getAllInitData * @memberof ProtectionModel * @returns {Array.&lt;ArrayBuffer&gt;} an array of initialization data buffers */ /** * Determine if the user-agent supports one of the given key systems and * content type configurations. Sends ENAME_KEY_SYSTEM_ACCESS_COMPLETE event * with a KeySystemAccess object as event data * * @function * @instance * @name requestKeySystemAccess * @memberof ProtectionModel * * @param {Array.&lt;Object&gt;} ksConfigurations array of desired key system * configurations in priority order (highest priority first) * @param {MediaPlayer.dependencies.protection.KeySystem} ksConfigurations.ks * the key system * @param {MediaPlayer.vo.protection.KeySystemConfiguration[]} ksConfigurations.configs * array of acceptable key system configurations * for this key system in priority order (highest priority first) */ /** * Selects the key system to use for all future operations on this * ProtectionModel. Sends ENAME_KEY_SYSTEM_SELECTED with no data * * @function * @instance * @name selectKeySystem * @memberof ProtectionModel * @param keySystemAccess {MediaPlayer.vo.protection.KeySystemAccess} the key * system access token representing a supported key system */ /** * Associate this protection model with a HTMLMediaElement * * @function * @instance * @name setMediaElement * @memberof ProtectionModel * @param mediaElement {HTMLMediaElement} the media element to * which we should associate this protection model and all current * key sessions */ /** * Creates a new key session using the given initData and type. Sends * KEY_SESSION_CREATED event with MediaPlayer.vo.protection.SessionToken * as data. * * @function * @instance * @name createKeySession * @memberof ProtectionModel * @param {ArrayBuffer} initData PSSH box for the currently selected * key system. * @param {ProtectionData} protData Protection data for the currently selected * key system. * @param {string} sessionType the desired session type. One of &quot;temporary&quot;, * &quot;persistent-license&quot;, &quot;persistent-release-message&quot;. CDM implementations * are not required to support anything except &quot;temporary&quot; */ /** * Update the given key session with a key (or any other message * intended for the CDM) * * @function * @instance * @name updateKeySession * @memberof ProtectionModel * @param {MediaPlayer.vo.protection.SessionToken} sessionToken the session * token * @param {ArrayBuffer} message the message that should be delivered to the CDM * for this session */ /** * Loads the persisted key session data associated with the given sessionID * into a new session. Sends KEY_SESSION_CREATED event with * {@MediaPlayer.vo.protection.SessionToken} as data. * * @function * @instance * @name loadKeySession * @memberof ProtectionModel * @param {string} sessionID the session ID corresponding to the persisted * session data to be loaded * @param {ArrayBuffer} the corresponding initData PSSH box for the currently * selected key system. */ /** * Removes any persisted key session data associated with the given session. * Also closes the session. Sends KEY_SESSION_REMOVED and * ENAME_KEY_SESSION_CLOSED with sessionID as data * * @function * @instance * @name removeKeySession * @memberof ProtectionModel * @param {SessionToken} sessionToken the session * token */ /** * Close the given session and release all associated keys. Following * this call, the sessionToken becomes invalid. Sends KEY_SESSION_CLOSED * with sessionID as data * * @function * @instance * @name closeKeySession * @memberof ProtectionModel * @param sessionToken the session token */ /** * Sets the certificate to be used by the CDM for encrypting messages * * @function * @instance * @name setServerCertificate * @memberof ProtectionModel * @param {ArrayBuffer} serverCertificate */ /** * Currently selected key system. Will be null or undefined if no key * system has yet been selected * * @instance * @name keySystem * @memberof ProtectionModel * @readonly * @type MediaPlayer.dependencies.protection.KeySystem */ export default ProtectionModel; × Search results Close "},"streaming_protection_models_ProtectionModel_01b.js.html":{"id":"streaming_protection_models_ProtectionModel_01b.js.html","title":"Source: streaming/protection/models/ProtectionModel_01b.js","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Source: streaming/protection/models/ProtectionModel_01b.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ /** * Initial implementation of EME * * Implemented by Google Chrome prior to v36 * * @implements ProtectionModel * @class */ import ProtectionKeyController from '../controllers/ProtectionKeyController'; import NeedKey from '../vo/NeedKey'; import KeyError from '../vo/KeyError'; import KeyMessage from '../vo/KeyMessage'; import KeySystemConfiguration from '../vo/KeySystemConfiguration'; import KeySystemAccess from '../vo/KeySystemAccess'; function ProtectionModel_01b(config) { config = config || {}; const context = this.context; const eventBus = config.eventBus;//Need to pass in here so we can use same instance since this is optional module const events = config.events; const debug = config.debug; const api = config.api; const errHandler = config.errHandler; let instance, logger, videoElement, keySystem, protectionKeyController, // With this version of the EME APIs, sessionIDs are not assigned to // sessions until the first key message is received. We are assuming // that in the case of multiple sessions, key messages will be received // in the order that generateKeyRequest() is called. // Holding spot for newly-created sessions until we determine whether or // not the CDM supports sessionIDs pendingSessions, // List of sessions that have been initialized. Only the first position will // be used in the case that the CDM does not support sessionIDs sessions, // Not all CDMs support the notion of sessionIDs. Without sessionIDs // there is no way for us to differentiate between sessions, therefore // we must only allow a single session. Once we receive the first key // message we can set this flag to determine if more sessions are allowed moreSessionsAllowed, // This is our main event handler for all desired HTMLMediaElement events // related to EME. These events are translated into our API-independent // versions of the same events eventHandler; function setup() { logger = debug.getLogger(instance); videoElement = null; keySystem = null; pendingSessions = []; sessions = []; protectionKeyController = ProtectionKeyController(context).getInstance(); eventHandler = createEventHandler(); } function reset() { if (videoElement) { removeEventListeners(); } for (let i = 0; i &lt; sessions.length; i++) { closeKeySession(sessions[i]); } eventBus.trigger(events.TEARDOWN_COMPLETE); } function getKeySystem() { return keySystem; } function getAllInitData() { const retVal = []; for (let i = 0; i &lt; pendingSessions.length; i++) { retVal.push(pendingSessions[i].initData); } for (let i = 0; i &lt; sessions.length; i++) { retVal.push(sessions[i].initData); } return retVal; } function requestKeySystemAccess(ksConfigurations) { let ve = videoElement; if (!ve) { // Must have a video element to do this capability tests ve = document.createElement('video'); } // Try key systems in order, first one with supported key system configuration // is used let found = false; for (let ksIdx = 0; ksIdx &lt; ksConfigurations.length; ksIdx++) { const systemString = ksConfigurations[ksIdx].ks.systemString; const configs = ksConfigurations[ksIdx].configs; let supportedAudio = null; let supportedVideo = null; // Try key system configs in order, first one with supported audio/video // is used for (let configIdx = 0; configIdx &lt; configs.length; configIdx++) { //let audios = configs[configIdx].audioCapabilities; const videos = configs[configIdx].videoCapabilities; // Look for supported video container/codecs if (videos &amp;&amp; videos.length !== 0) { supportedVideo = []; // Indicates that we have a requested video config for (let videoIdx = 0; videoIdx &lt; videos.length; videoIdx++) { if (ve.canPlayType(videos[videoIdx].contentType, systemString) !== '') { supportedVideo.push(videos[videoIdx]); } } } // No supported audio or video in this configuration OR we have // requested audio or video configuration that is not supported if ((!supportedAudio &amp;&amp; !supportedVideo) || (supportedAudio &amp;&amp; supportedAudio.length === 0) || (supportedVideo &amp;&amp; supportedVideo.length === 0)) { continue; } // This configuration is supported found = true; const ksConfig = new KeySystemConfiguration(supportedAudio, supportedVideo); const ks = protectionKeyController.getKeySystemBySystemString(systemString); eventBus.trigger(events.KEY_SYSTEM_ACCESS_COMPLETE, { data: new KeySystemAccess(ks, ksConfig) }); break; } } if (!found) { eventBus.trigger(events.KEY_SYSTEM_ACCESS_COMPLETE, {error: 'Key system access denied! -- No valid audio/video content configurations detected!'}); } } function selectKeySystem(keySystemAccess) { keySystem = keySystemAccess.keySystem; eventBus.trigger(events.INTERNAL_KEY_SYSTEM_SELECTED); } function setMediaElement(mediaElement) { if (videoElement === mediaElement) { return; } // Replacing the previous element if (videoElement) { removeEventListeners(); } videoElement = mediaElement; // Only if we are not detaching from the existing element if (videoElement) { videoElement.addEventListener(api.keyerror, eventHandler); videoElement.addEventListener(api.needkey, eventHandler); videoElement.addEventListener(api.keymessage, eventHandler); videoElement.addEventListener(api.keyadded, eventHandler); eventBus.trigger(events.VIDEO_ELEMENT_SELECTED); } } function createKeySession(initData /*, protData, keySystemType */) { if (!keySystem) { throw new Error('Can not create sessions until you have selected a key system'); } // Determine if creating a new session is allowed if (moreSessionsAllowed || sessions.length === 0) { const newSession = { // Implements SessionToken sessionID: null, initData: initData, getSessionID: function () { return this.sessionID; }, getExpirationTime: function () { return NaN; }, getSessionType: function () { return 'temporary'; } }; pendingSessions.push(newSession); // Send our request to the CDM videoElement[api.generateKeyRequest](keySystem.systemString, new Uint8Array(initData)); return newSession; } else { throw new Error('Multiple sessions not allowed!'); } } function updateKeySession(sessionToken, message) { const sessionID = sessionToken.sessionID; if (!protectionKeyController.isClearKey(keySystem)) { // Send our request to the CDM videoElement[api.addKey](keySystem.systemString, new Uint8Array(message), new Uint8Array(sessionToken.initData), sessionID); } else { // For clearkey, message is a ClearKeyKeySet for (let i = 0; i &lt; message.keyPairs.length; i++) { videoElement[api.addKey](keySystem.systemString, message.keyPairs[i].key, message.keyPairs[i].keyID, sessionID); } } } function closeKeySession(sessionToken) { // Send our request to the CDM try { videoElement[api.cancelKeyRequest](keySystem.systemString, sessionToken.sessionID); } catch (error) { eventBus.trigger(events.KEY_SESSION_CLOSED, {data: null, error: 'Error closing session (' + sessionToken.sessionID + ') ' + error.message}); } } function setServerCertificate(/*serverCertificate*/) { /* Not supported */ } function loadKeySession(/*sessionID*/) { /* Not supported */ } function removeKeySession(/*sessionToken*/) { /* Not supported */ } function createEventHandler() { return { handleEvent: function (event) { let sessionToken = null; switch (event.type) { case api.needkey: let initData = ArrayBuffer.isView(event.initData) ? event.initData.buffer : event.initData; eventBus.trigger(events.NEED_KEY, {key: new NeedKey(initData, 'cenc')}); break; case api.keyerror: sessionToken = findSessionByID(sessions, event.sessionId); if (!sessionToken) { sessionToken = findSessionByID(pendingSessions, event.sessionId); } if (sessionToken) { let msg = ''; switch (event.errorCode.code) { case 1: msg += 'MEDIA_KEYERR_UNKNOWN - An unspecified error occurred. This value is used for errors that don\\'t match any of the other codes.'; break; case 2: msg += 'MEDIA_KEYERR_CLIENT - The Key System could not be installed or updated.'; break; case 3: msg += 'MEDIA_KEYERR_SERVICE - The message passed into update indicated an error from the license service.'; break; case 4: msg += 'MEDIA_KEYERR_OUTPUT - There is no available output device with the required characteristics for the content protection system.'; break; case 5: msg += 'MEDIA_KEYERR_HARDWARECHANGE - A hardware configuration change caused a content protection error.'; break; case 6: msg += 'MEDIA_KEYERR_DOMAIN - An error occurred in a multi-device domain licensing configuration. The most common error is a failure to join the domain.'; break; } msg += ' System Code = ' + event.systemCode; // TODO: Build error string based on key error eventBus.trigger(events.KEY_ERROR, {data: new KeyError(sessionToken, msg)}); } else { logger.error('No session token found for key error'); } break; case api.keyadded: sessionToken = findSessionByID(sessions, event.sessionId); if (!sessionToken) { sessionToken = findSessionByID(pendingSessions, event.sessionId); } if (sessionToken) { logger.debug('DRM: Key added.'); eventBus.trigger(events.KEY_ADDED, {data: sessionToken});//TODO not sure anything is using sessionToken? why there? } else { logger.debug('No session token found for key added'); } break; case api.keymessage: // If this CDM does not support session IDs, we will be limited // to a single session moreSessionsAllowed = (event.sessionId !== null) &amp;&amp; (event.sessionId !== undefined); // SessionIDs supported if (moreSessionsAllowed) { // Attempt to find an uninitialized token with this sessionID sessionToken = findSessionByID(sessions, event.sessionId); if (!sessionToken &amp;&amp; pendingSessions.length &gt; 0) { // This is the first message for our latest session, so set the // sessionID and add it to our list sessionToken = pendingSessions.shift(); sessions.push(sessionToken); sessionToken.sessionID = event.sessionId; eventBus.trigger(events.KEY_SESSION_CREATED, {data: sessionToken}); } } else if (pendingSessions.length &gt; 0) { // SessionIDs not supported sessionToken = pendingSessions.shift(); sessions.push(sessionToken); if (pendingSessions.length !== 0) { errHandler.mediaKeyMessageError('Multiple key sessions were creates with a user-agent that does not support sessionIDs!! Unpredictable behavior ahead!'); } } if (sessionToken) { let message = ArrayBuffer.isView(event.message) ? event.message.buffer : event.message; // For ClearKey, the spec mandates that you pass this message to the // addKey method, so we always save it to the token since there is no // way to tell which key system is in use sessionToken.keyMessage = message; eventBus.trigger(events.INTERNAL_KEY_MESSAGE, {data: new KeyMessage(sessionToken, message, event.defaultURL)}); } else { logger.warn('No session token found for key message'); } break; } } }; } /** * Helper function to retrieve the stored session token based on a given * sessionID value * * @param {Array} sessionArray - the array of sessions to search * @param {*} sessionID - the sessionID to search for * @returns {*} the session token with the given sessionID */ function findSessionByID(sessionArray, sessionID) { if (!sessionID || !sessionArray) { return null; } else { const len = sessionArray.length; for (let i = 0; i &lt; len; i++) { if (sessionArray[i].sessionID == sessionID) { return sessionArray[i]; } } return null; } } function removeEventListeners() { videoElement.removeEventListener(api.keyerror, eventHandler); videoElement.removeEventListener(api.needkey, eventHandler); videoElement.removeEventListener(api.keymessage, eventHandler); videoElement.removeEventListener(api.keyadded, eventHandler); } instance = { getAllInitData: getAllInitData, requestKeySystemAccess: requestKeySystemAccess, getKeySystem: getKeySystem, selectKeySystem: selectKeySystem, setMediaElement: setMediaElement, createKeySession: createKeySession, updateKeySession: updateKeySession, closeKeySession: closeKeySession, setServerCertificate: setServerCertificate, loadKeySession: loadKeySession, removeKeySession: removeKeySession, reset: reset }; setup(); return instance; } ProtectionModel_01b.__dashjs_factory_name = 'ProtectionModel_01b'; export default dashjs.FactoryMaker.getClassFactory(ProtectionModel_01b); /* jshint ignore:line */ × Search results Close "},"streaming_protection_models_ProtectionModel_3Feb2014.js.html":{"id":"streaming_protection_models_ProtectionModel_3Feb2014.js.html","title":"Source: streaming/protection/models/ProtectionModel_3Feb2014.js","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Source: streaming/protection/models/ProtectionModel_3Feb2014.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ /** * Implementation of the EME APIs as of the 3 Feb 2014 state of the specification. * * Implemented by Internet Explorer 11 (Windows 8.1) * * @implements ProtectionModel * @class */ import ProtectionKeyController from '../controllers/ProtectionKeyController'; import NeedKey from '../vo/NeedKey'; import KeyError from '../vo/KeyError'; import KeyMessage from '../vo/KeyMessage'; import KeySystemConfiguration from '../vo/KeySystemConfiguration'; import KeySystemAccess from '../vo/KeySystemAccess'; function ProtectionModel_3Feb2014(config) { config = config || {}; const context = this.context; const eventBus = config.eventBus;//Need to pass in here so we can use same instance since this is optional module const events = config.events; const debug = config.debug; const api = config.api; let instance, logger, videoElement, keySystem, mediaKeys, keySystemAccess, sessions, eventHandler, protectionKeyController; function setup() { logger = debug.getLogger(instance); videoElement = null; keySystem = null; mediaKeys = null; keySystemAccess = null; sessions = []; protectionKeyController = ProtectionKeyController(context).getInstance(); eventHandler = createEventHandler(); } function reset() { try { for (let i = 0; i &lt; sessions.length; i++) { closeKeySession(sessions[i]); } if (videoElement) { videoElement.removeEventListener(api.needkey, eventHandler); } eventBus.trigger(events.TEARDOWN_COMPLETE); } catch (error) { eventBus.trigger(events.TEARDOWN_COMPLETE, { error: 'Error tearing down key sessions and MediaKeys! -- ' + error.message }); } } function getKeySystem() { return keySystem; } function getAllInitData() { const retVal = []; for (let i = 0; i &lt; sessions.length; i++) { retVal.push(sessions[i].initData); } return retVal; } function requestKeySystemAccess(ksConfigurations) { // Try key systems in order, first one with supported key system configuration // is used let found = false; for (let ksIdx = 0; ksIdx &lt; ksConfigurations.length; ksIdx++) { const systemString = ksConfigurations[ksIdx].ks.systemString; const configs = ksConfigurations[ksIdx].configs; let supportedAudio = null; let supportedVideo = null; // Try key system configs in order, first one with supported audio/video // is used for (let configIdx = 0; configIdx &lt; configs.length; configIdx++) { const audios = configs[configIdx].audioCapabilities; const videos = configs[configIdx].videoCapabilities; // Look for supported audio container/codecs if (audios &amp;&amp; audios.length !== 0) { supportedAudio = []; // Indicates that we have a requested audio config for (let audioIdx = 0; audioIdx &lt; audios.length; audioIdx++) { if (window[api.MediaKeys].isTypeSupported(systemString, audios[audioIdx].contentType)) { supportedAudio.push(audios[audioIdx]); } } } // Look for supported video container/codecs if (videos &amp;&amp; videos.length !== 0) { supportedVideo = []; // Indicates that we have a requested video config for (let videoIdx = 0; videoIdx &lt; videos.length; videoIdx++) { if (window[api.MediaKeys].isTypeSupported(systemString, videos[videoIdx].contentType)) { supportedVideo.push(videos[videoIdx]); } } } // No supported audio or video in this configuration OR we have // requested audio or video configuration that is not supported if ((!supportedAudio &amp;&amp; !supportedVideo) || (supportedAudio &amp;&amp; supportedAudio.length === 0) || (supportedVideo &amp;&amp; supportedVideo.length === 0)) { continue; } // This configuration is supported found = true; const ksConfig = new KeySystemConfiguration(supportedAudio, supportedVideo); const ks = protectionKeyController.getKeySystemBySystemString(systemString); eventBus.trigger(events.KEY_SYSTEM_ACCESS_COMPLETE, { data: new KeySystemAccess(ks, ksConfig) }); break; } } if (!found) { eventBus.trigger(events.KEY_SYSTEM_ACCESS_COMPLETE, { error: 'Key system access denied! -- No valid audio/video content configurations detected!' }); } } function selectKeySystem(ksAccess) { try { mediaKeys = ksAccess.mediaKeys = new window[api.MediaKeys](ksAccess.keySystem.systemString); keySystem = ksAccess.keySystem; keySystemAccess = ksAccess; if (videoElement) { setMediaKeys(); } eventBus.trigger(events.INTERNAL_KEY_SYSTEM_SELECTED); } catch (error) { eventBus.trigger(events.INTERNAL_KEY_SYSTEM_SELECTED, { error: 'Error selecting keys system (' + keySystem.systemString + ')! Could not create MediaKeys -- TODO' }); } } function setMediaElement(mediaElement) { if (videoElement === mediaElement) return; // Replacing the previous element if (videoElement) { videoElement.removeEventListener(api.needkey, eventHandler); } videoElement = mediaElement; // Only if we are not detaching from the existing element if (videoElement) { videoElement.addEventListener(api.needkey, eventHandler); if (mediaKeys) { setMediaKeys(); } } } function createKeySession(initData, protData, sessionType, cdmData) { if (!keySystem || !mediaKeys || !keySystemAccess) { throw new Error('Can not create sessions until you have selected a key system'); } // Use the first video capability for the contentType. // TODO: Not sure if there is a way to concatenate all capability data into a RFC6386-compatible format // If player is trying to playback Audio only stream - don't error out. let capabilities = null; if (keySystemAccess.ksConfiguration.videoCapabilities &amp;&amp; keySystemAccess.ksConfiguration.videoCapabilities.length &gt; 0) { capabilities = keySystemAccess.ksConfiguration.videoCapabilities[0]; } if (capabilities === null &amp;&amp; keySystemAccess.ksConfiguration.audioCapabilities &amp;&amp; keySystemAccess.ksConfiguration.audioCapabilities.length &gt; 0) { capabilities = keySystemAccess.ksConfiguration.audioCapabilities[0]; } if (capabilities === null) { throw new Error('Can not create sessions for unknown content types.'); } const contentType = capabilities.contentType; const session = mediaKeys.createSession(contentType, new Uint8Array(initData), cdmData ? new Uint8Array(cdmData) : null); const sessionToken = createSessionToken(session, initData); // Add all event listeners session.addEventListener(api.error, sessionToken); session.addEventListener(api.message, sessionToken); session.addEventListener(api.ready, sessionToken); session.addEventListener(api.close, sessionToken); // Add to our session list sessions.push(sessionToken); logger.debug('DRM: Session created. SessionID = ' + sessionToken.getSessionID()); eventBus.trigger(events.KEY_SESSION_CREATED, { data: sessionToken }); } function updateKeySession(sessionToken, message) { const session = sessionToken.session; if (!protectionKeyController.isClearKey(keySystem)) { // Send our request to the key session session.update(new Uint8Array(message)); } else { // For clearkey, message is a ClearKeyKeySet session.update(new Uint8Array(message.toJWK())); } } /** * Close the given session and release all associated keys. Following * this call, the sessionToken becomes invalid * * @param {Object} sessionToken - the session token */ function closeKeySession(sessionToken) { const session = sessionToken.session; // Remove event listeners session.removeEventListener(api.error, sessionToken); session.removeEventListener(api.message, sessionToken); session.removeEventListener(api.ready, sessionToken); session.removeEventListener(api.close, sessionToken); // Remove from our session list for (let i = 0; i &lt; sessions.length; i++) { if (sessions[i] === sessionToken) { sessions.splice(i, 1); break; } } // Send our request to the key session session[api.release](); } function setServerCertificate(/*serverCertificate*/) { /* Not supported */ } function loadKeySession(/*sessionID*/) { /* Not supported */ } function removeKeySession(/*sessionToken*/) { /* Not supported */ } function createEventHandler() { return { handleEvent: function (event) { switch (event.type) { case api.needkey: if (event.initData) { const initData = ArrayBuffer.isView(event.initData) ? event.initData.buffer : event.initData; eventBus.trigger(events.NEED_KEY, { key: new NeedKey(initData, 'cenc') }); } break; } } }; } // IE11 does not let you set MediaKeys until it has entered a certain // readyState, so we need this logic to ensure we don't set the keys // too early function setMediaKeys() { let boundDoSetKeys = null; const doSetKeys = function () { videoElement.removeEventListener('loadedmetadata', boundDoSetKeys); videoElement[api.setMediaKeys](mediaKeys); eventBus.trigger(events.VIDEO_ELEMENT_SELECTED); }; if (videoElement.readyState &gt;= 1) { doSetKeys(); } else { boundDoSetKeys = doSetKeys.bind(this); videoElement.addEventListener('loadedmetadata', boundDoSetKeys); } } // Function to create our session token objects which manage the EME // MediaKeySession and session-specific event handler function createSessionToken(keySession, initData) { return { // Implements SessionToken session: keySession, initData: initData, getSessionID: function () { return this.session.sessionId; }, getExpirationTime: function () { return NaN; }, getSessionType: function () { return 'temporary'; }, // This is our main event handler for all desired MediaKeySession events // These events are translated into our API-independent versions of the // same events handleEvent: function (event) { switch (event.type) { case api.error: let errorStr = 'KeyError'; // TODO: Make better string from event eventBus.trigger(events.KEY_ERROR, { data: new KeyError(this, errorStr) }); break; case api.message: let message = ArrayBuffer.isView(event.message) ? event.message.buffer : event.message; eventBus.trigger(events.INTERNAL_KEY_MESSAGE, { data: new KeyMessage(this, message, event.destinationURL) }); break; case api.ready: logger.debug('DRM: Key added.'); eventBus.trigger(events.KEY_ADDED); break; case api.close: logger.debug('DRM: Session closed. SessionID = ' + this.getSessionID()); eventBus.trigger(events.KEY_SESSION_CLOSED, { data: this.getSessionID() }); break; } } }; } instance = { getAllInitData: getAllInitData, requestKeySystemAccess: requestKeySystemAccess, getKeySystem: getKeySystem, selectKeySystem: selectKeySystem, setMediaElement: setMediaElement, createKeySession: createKeySession, updateKeySession: updateKeySession, closeKeySession: closeKeySession, setServerCertificate: setServerCertificate, loadKeySession: loadKeySession, removeKeySession: removeKeySession, reset: reset }; setup(); return instance; } ProtectionModel_3Feb2014.__dashjs_factory_name = 'ProtectionModel_3Feb2014'; export default dashjs.FactoryMaker.getClassFactory(ProtectionModel_3Feb2014); /* jshint ignore:line */ × Search results Close "},"streaming_protection_Protection.js.html":{"id":"streaming_protection_Protection.js.html","title":"Source: streaming/protection/Protection.js","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Source: streaming/protection/Protection.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ import ProtectionController from './controllers/ProtectionController'; import ProtectionKeyController from './controllers/ProtectionKeyController'; import ProtectionEvents from './ProtectionEvents'; import ProtectionModel_21Jan2015 from './models/ProtectionModel_21Jan2015'; import ProtectionModel_3Feb2014 from './models/ProtectionModel_3Feb2014'; import ProtectionModel_01b from './models/ProtectionModel_01b'; const APIS_ProtectionModel_01b = [ // Un-prefixed as per spec { // Video Element generateKeyRequest: 'generateKeyRequest', addKey: 'addKey', cancelKeyRequest: 'cancelKeyRequest', // Events needkey: 'needkey', keyerror: 'keyerror', keyadded: 'keyadded', keymessage: 'keymessage' }, // Webkit-prefixed (early Chrome versions and Chrome with EME disabled in chrome://flags) { // Video Element generateKeyRequest: 'webkitGenerateKeyRequest', addKey: 'webkitAddKey', cancelKeyRequest: 'webkitCancelKeyRequest', // Events needkey: 'webkitneedkey', keyerror: 'webkitkeyerror', keyadded: 'webkitkeyadded', keymessage: 'webkitkeymessage' } ]; const APIS_ProtectionModel_3Feb2014 = [ // Un-prefixed as per spec // Chrome 38-39 (and some earlier versions) with chrome://flags -- Enable Encrypted Media Extensions { // Video Element setMediaKeys: 'setMediaKeys', // MediaKeys MediaKeys: 'MediaKeys', // MediaKeySession release: 'close', // Events needkey: 'needkey', error: 'keyerror', message: 'keymessage', ready: 'keyadded', close: 'keyclose' }, // MS-prefixed (IE11, Windows 8.1) { // Video Element setMediaKeys: 'msSetMediaKeys', // MediaKeys MediaKeys: 'MSMediaKeys', // MediaKeySession release: 'close', // Events needkey: 'msneedkey', error: 'mskeyerror', message: 'mskeymessage', ready: 'mskeyadded', close: 'mskeyclose' } ]; function Protection() { let instance; const context = this.context; /** * Create a ProtectionController and associated ProtectionModel for use with * a single piece of content. * * @param {Object} config * @return {ProtectionController} protection controller * */ function createProtectionSystem(config) { let controller = null; const protectionKeyController = ProtectionKeyController(context).getInstance(); protectionKeyController.setConfig({ debug: config.debug, BASE64: config.BASE64 }); protectionKeyController.initialize(); let protectionModel = getProtectionModel(config); if (!controller &amp;&amp; protectionModel) {//TODO add ability to set external controller if still needed at all? controller = ProtectionController(context).create({ protectionModel: protectionModel, protectionKeyController: protectionKeyController, eventBus: config.eventBus, debug: config.debug, events: config.events, BASE64: config.BASE64, constants: config.constants }); config.capabilities.setEncryptedMediaSupported(true); } return controller; } function getProtectionModel(config) { const debug = config.debug; const logger = debug.getLogger(instance); const eventBus = config.eventBus; const errHandler = config.errHandler; const videoElement = config.videoModel ? config.videoModel.getElement() : null; if ((!videoElement || videoElement.onencrypted !== undefined) &amp;&amp; (!videoElement || videoElement.mediaKeys !== undefined)) { logger.info('EME detected on this user agent! (ProtectionModel_21Jan2015)'); return ProtectionModel_21Jan2015(context).create({ debug: debug, eventBus: eventBus, events: config.events }); } else if (getAPI(videoElement, APIS_ProtectionModel_3Feb2014)) { logger.info('EME detected on this user agent! (ProtectionModel_3Feb2014)'); return ProtectionModel_3Feb2014(context).create({ debug: debug, eventBus: eventBus, events: config.events, api: getAPI(videoElement, APIS_ProtectionModel_3Feb2014) }); } else if (getAPI(videoElement, APIS_ProtectionModel_01b)) { logger.info('EME detected on this user agent! (ProtectionModel_01b)'); return ProtectionModel_01b(context).create({ debug: debug, eventBus: eventBus, errHandler: errHandler, events: config.events, api: getAPI(videoElement, APIS_ProtectionModel_01b) }); } else { logger.warn('No supported version of EME detected on this user agent! - Attempts to play encrypted content will fail!'); return null; } } function getAPI(videoElement, apis) { for (let i = 0; i &lt; apis.length; i++) { const api = apis[i]; // detect if api is supported by browser // check only first function in api -&gt; should be fine if (typeof videoElement[api[Object.keys(api)[0]]] !== 'function') { continue; } return api; } return null; } instance = { createProtectionSystem: createProtectionSystem }; return instance; } Protection.__dashjs_factory_name = 'Protection'; const factory = dashjs.FactoryMaker.getClassFactory(Protection); /* jshint ignore:line */ factory.events = ProtectionEvents; dashjs.FactoryMaker.updateClassFactory(Protection.__dashjs_factory_name, factory); /* jshint ignore:line */ export default factory; × Search results Close "},"streaming_vo_metrics_RepresentationSwitch.js.html":{"id":"streaming_vo_metrics_RepresentationSwitch.js.html","title":"Source: streaming/vo/metrics/RepresentationSwitch.js","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Source: streaming/vo/metrics/RepresentationSwitch.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ /** * @class */ class RepresentationSwitch { /** * @description This Object holds reference to the info at quality switch between two representations. */ constructor() { /** * Time of the switch event. * @public */ this.t = null; /** * The media presentation time of the earliest access unit * (out of all media content components) played out from * the Representation. * * @public */ this.mt = null; /** * Value of Representation@id identifying the switch-to Representation. * @public */ this.to = null; /** * If not present, this metrics concerns the Representation as a whole. * If present, lto indicates the value of SubRepresentation@level within * Representation identifying the switch-to level of the Representation. * * @public */ this.lto = null; } } export default RepresentationSwitch; × Search results Close "},"streaming_vo_metrics_RequestsQueue.js.html":{"id":"streaming_vo_metrics_RequestsQueue.js.html","title":"Source: streaming/vo/metrics/RequestsQueue.js","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Source: streaming/vo/metrics/RequestsQueue.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ /** * @class */ class RequestsQueue { /** * @description This Object holds reference to Fragment Model's request queues */ constructor() { /** * Array of all of the requests that have begun to load * This request may not make it into the executed queue if it is abandon due to ABR rules for example. * @public */ this.loadingRequests = []; /** * Array of the The requests that have completed * @public */ this.executedRequests = []; } } export default RequestsQueue; × Search results Close "},"streaming_metrics_utils_RNG.js.html":{"id":"streaming_metrics_utils_RNG.js.html","title":"Source: streaming/metrics/utils/RNG.js","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Source: streaming/metrics/utils/RNG.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ function RNG() { // check whether secure random numbers are available. if not, revert to // using Math.random let crypto = window.crypto || window.msCrypto; // could just as easily use any other array type by changing line below let ArrayType = Uint32Array; let MAX_VALUE = Math.pow(2, ArrayType.BYTES_PER_ELEMENT * 8) - 1; // currently there is only one client for this code, and that only uses // a single random number per initialisation. may want to increase this // number if more consumers in the future let NUM_RANDOM_NUMBERS = 10; let randomNumbers, index, instance; function initialise() { if (crypto) { if (!randomNumbers) { randomNumbers = new ArrayType(NUM_RANDOM_NUMBERS); } crypto.getRandomValues(randomNumbers); index = 0; } } function rand(min, max) { let r; if (!min) { min = 0; } if (!max) { max = 1; } if (crypto) { if (index === randomNumbers.length) { initialise(); } r = randomNumbers[index] / MAX_VALUE; index += 1; } else { r = Math.random(); } return (r * (max - min)) + min; } instance = { random: rand }; initialise(); return instance; } RNG.__dashjs_factory_name = 'RNG'; export default dashjs.FactoryMaker.getSingletonFactory(RNG); /* jshint ignore:line */ × Search results Close "},"streaming_vo_metrics_SchedulingInfo.js.html":{"id":"streaming_vo_metrics_SchedulingInfo.js.html","title":"Source: streaming/vo/metrics/SchedulingInfo.js","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Source: streaming/vo/metrics/SchedulingInfo.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ /** * @class */ class SchedulingInfo { /** * @description This Object holds reference to the index handling of the current fragment being loaded or executed. */ constructor() { /** * Type of stream Audio | Video | FragmentedText * @public */ this.mediaType = null; /** * Time of the scheduling event. * @public */ this.t = null; /** * Type of fragment (initialization | media) * @public */ this.type = null; /** * Presentation start time of fragment * @public */ this.startTime = null; /** * Availability start time of fragment * @public */ this.availabilityStartTime = null; /** * Duration of fragment * @public */ this.duration = null; /** * Bit Rate Quality of fragment * @public */ this.quality = null; /** * Range of fragment * @public */ this.range = null; /** * Current state of fragment * @public */ this.state = null; } } export default SchedulingInfo; × Search results Close "},"streaming_protection_vo_SessionToken.js.html":{"id":"streaming_protection_vo_SessionToken.js.html","title":"Source: streaming/protection/vo/SessionToken.js","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Source: streaming/protection/vo/SessionToken.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ /** * All session identifiers (tokens) returned by ProtectionController as well as * ProtectionModel implementations are guaranteed to contain certain properties * regardless of the proprietary data each ProtectionModel will need to attach. * This interface defines the common APIs for session tokens available for * applications to access. * * @interface SessionToken */ class SessionToken {} /** * The initialization data used to create this session * * @instance * @name initData * @memberof SessionToken * @type ArrayBuffer * @readonly */ /** * Returns the unique session ID designated to this session * * @function * @name SessionToken#getSessionID * @return {string} the session ID or the empty string if the implementation * does not support session IDs or the sessionID has not yet been established */ /** * The time, in milliseconds since 01 January, 1970 UTC, after which * the key(s) in the session will no longer be usable to decrypt * media data, or NaN if no such time exists * * @function * @name SessionToken#getExpirationTime * @returns {number} the expiration time or NaN if no expiration time exists * for this session */ /** * Returns a read-only map of key IDs known to the session to the * current status of the associated key. * * @function * @name SessionToken#getKeyStatuses * @returns {maplike&lt;BufferSource,MediaKeyStatus&gt;} the map of keys * in this session and their associated status */ /** * Returns the session type. Session types are defined * {@link https://w3c.github.io/encrypted-media/#idl-def-MediaKeySessionType|here} * * @function * @name SessionToken#getSessionType * @returns {string} The session type */ export default SessionToken; × Search results Close "},"streaming_SourceBufferSink.js.html":{"id":"streaming_SourceBufferSink.js.html","title":"Source: streaming/SourceBufferSink.js","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Source: streaming/SourceBufferSink.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ import Debug from '../core/Debug'; import DashJSError from './vo/DashJSError'; import EventBus from '../core/EventBus'; import Events from '../core/events/Events'; import FactoryMaker from '../core/FactoryMaker'; import TextController from './text/TextController'; /** * @class SourceBufferSink * @implements FragmentSink */ function SourceBufferSink(mediaSource, mediaInfo, onAppendedCallback) { const context = this.context; const eventBus = EventBus(context).getInstance(); let instance, logger, buffer, isAppendingInProgress; let appendQueue = []; let onAppended = onAppendedCallback; function setup() { logger = Debug(context).getInstance().getLogger(instance); isAppendingInProgress = false; const codec = mediaInfo.codec; try { // Safari claims to support anything starting 'application/mp4'. // it definitely doesn't understand 'application/mp4;codecs=&quot;stpp&quot;' // - currently no browser does, so check for it and use our own // implementation. The same is true for codecs=&quot;wvtt&quot;. if (codec.match(/application\\/mp4;\\s*codecs=&quot;(stpp|wvtt).*&quot;/i)) { throw new Error('not really supported'); } buffer = mediaSource.addSourceBuffer(codec); } catch (ex) { // Note that in the following, the quotes are open to allow for extra text after stpp and wvtt if ((mediaInfo.isText) || (codec.indexOf('codecs=&quot;stpp') !== -1) || (codec.indexOf('codecs=&quot;wvtt') !== -1)) { const textController = TextController(context).getInstance(); buffer = textController.getTextSourceBuffer(); } else { throw ex; } } } function reset() { if (buffer) { try { if (!buffer.getClassName || buffer.getClassName() !== 'TextSourceBuffer') { mediaSource.removeSourceBuffer(buffer); } } catch (e) { logger.error('Failed to remove source buffer from media source.'); } isAppendingInProgress = false; buffer = null; } appendQueue = []; onAppended = null; } function getBuffer() { return buffer; } function getAllBufferRanges() { return buffer ? buffer.buffered : []; } function append(chunk) { appendQueue.push(chunk); if (!isAppendingInProgress) { waitForUpdateEnd(buffer, appendNextInQueue.bind(this)); } } function updateTimestampOffset(MSETimeOffset) { if (buffer.timestampOffset !== MSETimeOffset &amp;&amp; !isNaN(MSETimeOffset)) { waitForUpdateEnd(buffer, () =&gt; { buffer.timestampOffset = MSETimeOffset; }); } } function remove(start, end, forceRemoval) { const sourceBufferSink = this; // make sure that the given time range is correct. Otherwise we will get InvalidAccessError waitForUpdateEnd(buffer, function () { try { if ((start &gt;= 0) &amp;&amp; (end &gt; start) &amp;&amp; (forceRemoval || mediaSource.readyState !== 'ended')) { buffer.remove(start, end); } // updating is in progress, we should wait for it to complete before signaling that this operation is done waitForUpdateEnd(buffer, function () { eventBus.trigger(Events.SOURCEBUFFER_REMOVE_COMPLETED, { buffer: sourceBufferSink, from: start, to: end, unintended: false }); }); } catch (err) { eventBus.trigger(Events.SOURCEBUFFER_REMOVE_COMPLETED, { buffer: sourceBufferSink, from: start, to: end, unintended: false, error: new DashJSError(err.code, err.message, null) }); } }); } function appendNextInQueue() { const sourceBufferSink = this; if (appendQueue.length &gt; 0) { isAppendingInProgress = true; const nextChunk = appendQueue[0]; appendQueue.splice(0,1); let oldRanges = []; const afterSuccess = function () { // Safari sometimes drops a portion of a buffer after appending. Handle these situations here const newRanges = getAllBufferRanges(); checkBufferGapsAfterAppend(sourceBufferSink, oldRanges, newRanges, nextChunk); if (appendQueue.length &gt; 0) { appendNextInQueue.call(this); } else { isAppendingInProgress = false; if (onAppended) { onAppended({ chunk: nextChunk }); } } }; try { if (nextChunk.bytes.length === 0) { afterSuccess.call(this); } else { oldRanges = getAllBufferRanges(); if (buffer.appendBuffer) { buffer.appendBuffer(nextChunk.bytes); } else { buffer.append(nextChunk.bytes, nextChunk); } // updating is in progress, we should wait for it to complete before signaling that this operation is done waitForUpdateEnd(buffer, afterSuccess.bind(this)); } } catch (err) { logger.fatal('SourceBuffer append failed &quot;' + err + '&quot;'); if (appendQueue.length &gt; 0) { appendNextInQueue(); } else { isAppendingInProgress = false; } if (onAppended) { onAppended({ chunk: nextChunk, error: new DashJSError(err.code, err.message, null) }); } } } } function checkBufferGapsAfterAppend(buffer, oldRanges, newRanges, chunk) { if (oldRanges &amp;&amp; oldRanges.length &gt; 0 &amp;&amp; oldRanges.length &lt; newRanges.length &amp;&amp; isChunkAlignedWithRange(oldRanges, chunk)) { // A split in the range was created while appending eventBus.trigger(Events.SOURCEBUFFER_REMOVE_COMPLETED, { buffer: buffer, from: newRanges.end(newRanges.length - 2), to: newRanges.start(newRanges.length - 1), unintended: true }); } } function isChunkAlignedWithRange(oldRanges, chunk) { for (let i = 0; i &lt; oldRanges.length; i++ ) { const start = Math.round(oldRanges.start(i)); const end = Math.round(oldRanges.end(i)); if (end === chunk.start || start === chunk.end || (chunk.start &gt;= start &amp;&amp; chunk.end &lt;= end) ) { return true; } } return false; } function abort() { try { if (mediaSource.readyState === 'open') { buffer.abort(); } else if (buffer.setTextTrack &amp;&amp; mediaSource.readyState === 'ended') { buffer.abort(); //The cues need to be removed from the TextSourceBuffer via a call to abort() } } catch (ex) { logger.error('SourceBuffer append abort failed: &quot;' + ex + '&quot;'); } appendQueue = []; } function waitForUpdateEnd(buffer, callback) { let intervalId; const CHECK_INTERVAL = 50; const checkIsUpdateEnded = function () { // if updating is still in progress do nothing and wait for the next check again. if (buffer.updating) return; // updating is completed, now we can stop checking and resolve the promise clearInterval(intervalId); callback(); }; const updateEndHandler = function () { if (buffer.updating) return; buffer.removeEventListener('updateend', updateEndHandler, false); callback(); }; if (!buffer.updating) { callback(); return; } // use updateend event if possible if (typeof buffer.addEventListener === 'function') { try { buffer.addEventListener('updateend', updateEndHandler, false); } catch (err) { // use setInterval to periodically check if updating has been completed intervalId = setInterval(checkIsUpdateEnded, CHECK_INTERVAL); } } else { // use setInterval to periodically check if updating has been completed intervalId = setInterval(checkIsUpdateEnded, CHECK_INTERVAL); } } instance = { getAllBufferRanges: getAllBufferRanges, getBuffer: getBuffer, append: append, remove: remove, abort: abort, reset: reset, updateTimestampOffset: updateTimestampOffset }; setup(); return instance; } SourceBufferSink.__dashjs_factory_name = 'SourceBufferSink'; const factory = FactoryMaker.getClassFactory(SourceBufferSink); export default factory; × Search results Close "},"streaming_Stream.js.html":{"id":"streaming_Stream.js.html","title":"Source: streaming/Stream.js","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Source: streaming/Stream.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ import Constants from './constants/Constants'; import StreamProcessor from './StreamProcessor'; import EventController from './controllers/EventController'; import FragmentController from './controllers/FragmentController'; import ThumbnailController from './thumbnail/ThumbnailController'; import EventBus from '../core/EventBus'; import Events from '../core/events/Events'; import Debug from '../core/Debug'; import FactoryMaker from '../core/FactoryMaker'; function Stream(config) { const DATA_UPDATE_FAILED_ERROR_CODE = 1; config = config || {}; const context = this.context; const eventBus = EventBus(context).getInstance(); const manifestModel = config.manifestModel; const dashManifestModel = config.dashManifestModel; const mediaPlayerModel = config.mediaPlayerModel; const manifestUpdater = config.manifestUpdater; const adapter = config.adapter; const capabilities = config.capabilities; const errHandler = config.errHandler; const timelineConverter = config.timelineConverter; const metricsModel = config.metricsModel; const abrController = config.abrController; const playbackController = config.playbackController; const mediaController = config.mediaController; const textController = config.textController; const videoModel = config.videoModel; let instance, logger, streamProcessors, isStreamActivated, isMediaInitialized, streamInfo, updateError, isUpdating, protectionController, fragmentController, thumbnailController, eventController, trackChangedEvent; function setup() { logger = Debug(context).getInstance().getLogger(instance); resetInitialSettings(); fragmentController = FragmentController(context).create({ mediaPlayerModel: mediaPlayerModel, metricsModel: metricsModel, errHandler: errHandler }); eventBus.on(Events.BUFFERING_COMPLETED, onBufferingCompleted, instance); eventBus.on(Events.DATA_UPDATE_COMPLETED, onDataUpdateCompleted, instance); } function initialize(StreamInfo, ProtectionController) { streamInfo = StreamInfo; protectionController = ProtectionController; if (protectionController) { eventBus.on(Events.KEY_ERROR, onProtectionError, instance); eventBus.on(Events.SERVER_CERTIFICATE_UPDATED, onProtectionError, instance); eventBus.on(Events.LICENSE_REQUEST_COMPLETE, onProtectionError, instance); eventBus.on(Events.KEY_SYSTEM_SELECTED, onProtectionError, instance); eventBus.on(Events.KEY_SESSION_CREATED, onProtectionError, instance); eventBus.on(Events.KEY_STATUSES_CHANGED, onProtectionError, instance); } } /** * Activates Stream by re-initializing some of its components * @param {MediaSource} mediaSource * @memberof Stream# */ function activate(mediaSource) { if (!isStreamActivated) { eventBus.on(Events.CURRENT_TRACK_CHANGED, onCurrentTrackChanged, instance); initializeMedia(mediaSource); isStreamActivated = true; } } /** * Partially resets some of the Stream elements * @memberof Stream# */ function deactivate() { let ln = streamProcessors ? streamProcessors.length : 0; for (let i = 0; i &lt; ln; i++) { let fragmentModel = streamProcessors[i].getFragmentModel(); fragmentModel.removeExecutedRequestsBeforeTime(getStartTime() + getDuration()); streamProcessors[i].reset(); } streamProcessors = []; isStreamActivated = false; isMediaInitialized = false; eventBus.off(Events.CURRENT_TRACK_CHANGED, onCurrentTrackChanged, instance); } function setMediaSource(mediaSource) { for (let i = 0; i &lt; streamProcessors.length;) { if (isMediaSupported(streamProcessors[i].getMediaInfo())) { streamProcessors[i].setMediaSource(mediaSource); i++; } else { streamProcessors[i].reset(); streamProcessors.splice(i,1); } } for (let i = 0; i &lt; streamProcessors.length; i++) { //Adding of new tracks to a stream processor isn't guaranteed by the spec after the METADATA_LOADED state //so do this after the buffers are created above. streamProcessors[i].dischargePreBuffer(); } if (streamProcessors.length === 0) { let msg = 'No streams to play.'; errHandler.manifestError(msg, 'nostreams', manifestModel.getValue()); logger.fatal(msg); } } function resetInitialSettings() { deactivate(); streamInfo = null; updateError = {}; isUpdating = false; } function reset() { if (playbackController) { playbackController.pause(); } if (fragmentController) { fragmentController.reset(); fragmentController = null; } resetInitialSettings(); eventBus.off(Events.DATA_UPDATE_COMPLETED, onDataUpdateCompleted, instance); eventBus.off(Events.BUFFERING_COMPLETED, onBufferingCompleted, instance); eventBus.off(Events.KEY_ERROR, onProtectionError, instance); eventBus.off(Events.SERVER_CERTIFICATE_UPDATED, onProtectionError, instance); eventBus.off(Events.LICENSE_REQUEST_COMPLETE, onProtectionError, instance); eventBus.off(Events.KEY_SYSTEM_SELECTED, onProtectionError, instance); eventBus.off(Events.KEY_SESSION_CREATED, onProtectionError, instance); eventBus.off(Events.KEY_STATUSES_CHANGED, onProtectionError, instance); } function getDuration() { return streamInfo ? streamInfo.duration : NaN; } function getStartTime() { return streamInfo ? streamInfo.start : NaN; } function getId() { return streamInfo ? streamInfo.id : NaN; } function getStreamInfo() { return streamInfo; } function getEventController() { return eventController; } function getFragmentController() { return fragmentController; } function getThumbnailController() { return thumbnailController; } function checkConfig() { if (!abrController || !abrController.hasOwnProperty('getBitrateList') || !adapter || !adapter.hasOwnProperty('getAllMediaInfoForType') || !adapter.hasOwnProperty('getEventsFor')) { throw new Error('Missing config parameter(s)'); } } /** * @param {string} type * @returns {Array} * @memberof Stream# */ function getBitrateListFor(type) { checkConfig(); if (type === Constants.IMAGE) { if (!thumbnailController) { return []; } return thumbnailController.getBitrateList(); } const mediaInfo = getMediaInfo(type); return abrController.getBitrateList(mediaInfo); } function startEventController() { if (eventController) { eventController.start(); } } function stopEventController() { if (eventController) { eventController.stop(); } } function onProtectionError(event) { if (event.error) { errHandler.mediaKeySessionError(event.error); logger.fatal(event.error); reset(); } } function isMediaSupported(mediaInfo) { const type = mediaInfo.type; let codec, msg; if (type === Constants.MUXED &amp;&amp; mediaInfo) { msg = 'Multiplexed representations are intentionally not supported, as they are not compliant with the DASH-AVC/264 guidelines'; logger.fatal(msg); errHandler.manifestError(msg, 'multiplexedrep', manifestModel.getValue()); return false; } if (type === Constants.TEXT || type === Constants.FRAGMENTED_TEXT || type === Constants.EMBEDDED_TEXT || type === Constants.IMAGE) { return true; } codec = mediaInfo.codec; logger.debug(type + ' codec: ' + codec); if (!!mediaInfo.contentProtection &amp;&amp; !capabilities.supportsEncryptedMedia()) { errHandler.capabilityError('encryptedmedia'); } else if (!capabilities.supportsCodec(codec)) { msg = type + 'Codec (' + codec + ') is not supported.'; logger.error(msg); return false; } return true; } function onCurrentTrackChanged(e) { if (e.newMediaInfo.streamInfo.id !== streamInfo.id) return; let processor = getProcessorForMediaInfo(e.oldMediaInfo); if (!processor) return; let currentTime = playbackController.getTime(); logger.info('Stream - Process track changed at current time ' + currentTime); let mediaInfo = e.newMediaInfo; let manifest = manifestModel.getValue(); logger.debug('Stream - Update stream controller'); if (manifest.refreshManifestOnSwitchTrack) { logger.debug('Stream - Refreshing manifest for switch track'); trackChangedEvent = e; manifestUpdater.refreshManifest(); } else { processor.selectMediaInfo(mediaInfo); if (mediaInfo.type !== Constants.FRAGMENTED_TEXT) { abrController.updateTopQualityIndex(mediaInfo); processor.switchTrackAsked(); processor.getFragmentModel().abortRequests(); } } } function createStreamProcessor(mediaInfo, allMediaForType, mediaSource, optionalSettings) { let streamProcessor = StreamProcessor(context).create({ type: mediaInfo.type, mimeType: mediaInfo.mimeType, timelineConverter: timelineConverter, adapter: adapter, manifestModel: manifestModel, dashManifestModel: dashManifestModel, mediaPlayerModel: mediaPlayerModel, metricsModel: metricsModel, dashMetrics: config.dashMetrics, baseURLController: config.baseURLController, stream: instance, abrController: abrController, domStorage: config.domStorage, playbackController: playbackController, mediaController: mediaController, streamController: config.streamController, textController: textController, errHandler: errHandler }); streamProcessor.initialize(mediaSource); abrController.updateTopQualityIndex(mediaInfo); if (optionalSettings) { streamProcessor.setBuffer(optionalSettings.buffer); streamProcessor.getIndexHandler().setCurrentTime(optionalSettings.currentTime); streamProcessors[optionalSettings.replaceIdx] = streamProcessor; } else { streamProcessors.push(streamProcessor); } if (optionalSettings &amp;&amp; optionalSettings.ignoreMediaInfo) { return; } if ((mediaInfo.type === Constants.TEXT || mediaInfo.type === Constants.FRAGMENTED_TEXT)) { let idx; for (let i = 0; i &lt; allMediaForType.length; i++) { if (allMediaForType[i].index === mediaInfo.index) { idx = i; } streamProcessor.addMediaInfo(allMediaForType[i]); //creates text tracks for all adaptations in one stream processor } streamProcessor.selectMediaInfo(allMediaForType[idx]); //sets the initial media info } else { streamProcessor.addMediaInfo(mediaInfo, true); } } function initializeMediaForType(type, mediaSource) { const allMediaForType = adapter.getAllMediaInfoForType(streamInfo, type); let mediaInfo = null; let initialMediaInfo; if (!allMediaForType || allMediaForType.length === 0) { logger.info('No ' + type + ' data.'); return; } for (let i = 0, ln = allMediaForType.length; i &lt; ln; i++) { mediaInfo = allMediaForType[i]; if (type === Constants.EMBEDDED_TEXT) { textController.addEmbeddedTrack(mediaInfo); } else { if (!isMediaSupported(mediaInfo)) continue; mediaController.addTrack(mediaInfo); } } if (type === Constants.EMBEDDED_TEXT || mediaController.getTracksFor(type, streamInfo).length === 0) { return; } if (type === Constants.IMAGE) { thumbnailController = ThumbnailController(context).create({ dashManifestModel: dashManifestModel, adapter: adapter, baseURLController: config.baseURLController, stream: instance }); return; } mediaController.checkInitialMediaSettingsForType(type, streamInfo); initialMediaInfo = mediaController.getCurrentTrackFor(type, streamInfo); // TODO : How to tell index handler live/duration? // TODO : Pass to controller and then pass to each method on handler? createStreamProcessor(initialMediaInfo, allMediaForType, mediaSource); } function initializeMedia(mediaSource) { checkConfig(); let events; let element = videoModel.getElement(); //if initializeMedia is called from a switch period, eventController could have been already created. if (!eventController) { eventController = EventController(context).create(); eventController.setConfig({ manifestModel: manifestModel, manifestUpdater: manifestUpdater, playbackController: playbackController }); events = adapter.getEventsFor(streamInfo); eventController.addInlineEvents(events); } isUpdating = true; filterCodecs(Constants.VIDEO); filterCodecs(Constants.AUDIO); if (element === null || (element &amp;&amp; (/^VIDEO$/i).test(element.nodeName))) { initializeMediaForType(Constants.VIDEO, mediaSource); } initializeMediaForType(Constants.AUDIO, mediaSource); initializeMediaForType(Constants.TEXT, mediaSource); initializeMediaForType(Constants.FRAGMENTED_TEXT, mediaSource); initializeMediaForType(Constants.EMBEDDED_TEXT, mediaSource); initializeMediaForType(Constants.MUXED, mediaSource); initializeMediaForType(Constants.IMAGE, mediaSource); createBuffers(); //TODO. Consider initialization of TextSourceBuffer here if embeddedText, but no sideloadedText. isMediaInitialized = true; isUpdating = false; if (streamProcessors.length === 0) { const msg = 'No streams to play.'; errHandler.manifestError(msg, 'nostreams', manifestModel.getValue()); logger.fatal(msg); } else { checkIfInitializationCompleted(); } } function filterCodecs(type) { const realAdaptation = dashManifestModel.getAdaptationForType(manifestModel.getValue(), streamInfo.index, type, streamInfo); if (!realAdaptation || !Array.isArray(realAdaptation.Representation_asArray)) return null; // Filter codecs that are not supported realAdaptation.Representation_asArray = realAdaptation.Representation_asArray.filter((_, i) =&gt; { // keep at least codec from lowest representation if (i === 0) return true; const codec = dashManifestModel.getCodec(realAdaptation, i, true); if (!capabilities.supportsCodec(codec)) { logger.error('[Stream] codec not supported: ' + codec); return false; } return true; }); } function checkIfInitializationCompleted() { const ln = streamProcessors.length; const hasError = !!updateError.audio || !!updateError.video; let error = hasError ? new Error(DATA_UPDATE_FAILED_ERROR_CODE, 'Data update failed', null) : null; for (let i = 0; i &lt; ln; i++) { if (streamProcessors[i].isUpdating() || isUpdating) { return; } } if (!isMediaInitialized) { return; } if (protectionController) { // Need to check if streamProcessors exists because streamProcessors // could be cleared in case an error is detected while initializing DRM keysystem for (let i = 0; i &lt; ln &amp;&amp; streamProcessors[i]; i++) { if (streamProcessors[i].getType() === Constants.AUDIO || streamProcessors[i].getType() === Constants.VIDEO || streamProcessors[i].getType() === Constants.FRAGMENTED_TEXT) { protectionController.initializeForMedia(streamProcessors[i].getMediaInfo()); } } } eventBus.trigger(Events.STREAM_INITIALIZED, { streamInfo: streamInfo, error: error }); } function getMediaInfo(type) { const ln = streamProcessors.length; let streamProcessor = null; for (let i = 0; i &lt; ln; i++) { streamProcessor = streamProcessors[i]; if (streamProcessor.getType() === type) { return streamProcessor.getMediaInfo(); } } return null; } function createBuffers() { for (let i = 0, ln = streamProcessors.length; i &lt; ln; i++) { streamProcessors[i].createBuffer(); } } function onBufferingCompleted(e) { if (e.streamInfo !== streamInfo) { return; } let processors = getProcessors(); const ln = processors.length; if (ln === 0) { logger.warn('onBufferingCompleted - can\\'t trigger STREAM_BUFFERING_COMPLETED because no streamProcessor is defined'); return; } // if there is at least one buffer controller that has not completed buffering yet do nothing for (let i = 0; i &lt; ln; i++) { //if audio or video buffer is not buffering completed state, do not send STREAM_BUFFERING_COMPLETED if (!processors[i].isBufferingCompleted() &amp;&amp; (processors[i].getType() === Constants.AUDIO || processors[i].getType() === Constants.VIDEO)) { logger.warn('onBufferingCompleted - can\\'t trigger STREAM_BUFFERING_COMPLETED because streamProcessor ' + processors[i].getType() + ' is not buffering completed'); return; } } logger.debug('onBufferingCompleted - trigger STREAM_BUFFERING_COMPLETED'); eventBus.trigger(Events.STREAM_BUFFERING_COMPLETED, { streamInfo: streamInfo }); } function onDataUpdateCompleted(e) { let sp = e.sender.getStreamProcessor(); if (sp.getStreamInfo() !== streamInfo) { return; } updateError[sp.getType()] = e.error; checkIfInitializationCompleted(); } function getProcessorForMediaInfo(mediaInfo) { if (!mediaInfo) { return false; } let processors = getProcessors(); return processors.filter(function (processor) { return (processor.getType() === mediaInfo.type); })[0]; } function getProcessors() { const ln = streamProcessors.length; let arr = []; let type, streamProcessor; for (let i = 0; i &lt; ln; i++) { streamProcessor = streamProcessors[i]; type = streamProcessor.getType(); if (type === Constants.AUDIO || type === Constants.VIDEO || type === Constants.FRAGMENTED_TEXT || type === Constants.TEXT) { arr.push(streamProcessor); } } return arr; } function updateData(updatedStreamInfo) { logger.info('Manifest updated... updating data system wide.'); isStreamActivated = false; isUpdating = true; streamInfo = updatedStreamInfo; if (eventController) { let events = adapter.getEventsFor(streamInfo); eventController.addInlineEvents(events); } filterCodecs(Constants.VIDEO); filterCodecs(Constants.AUDIO); for (let i = 0, ln = streamProcessors.length; i &lt; ln; i++) { let streamProcessor = streamProcessors[i]; let mediaInfo = adapter.getMediaInfoForType(streamInfo, streamProcessor.getType()); abrController.updateTopQualityIndex(mediaInfo); streamProcessor.addMediaInfo(mediaInfo, true); } if (trackChangedEvent) { let mediaInfo = trackChangedEvent.newMediaInfo; if (mediaInfo.type !== 'fragmentedText') { let processor = getProcessorForMediaInfo(trackChangedEvent.oldMediaInfo); if (!processor) return; processor.switchTrackAsked(); trackChangedEvent = undefined; } } isUpdating = false; checkIfInitializationCompleted(); } instance = { initialize: initialize, activate: activate, deactivate: deactivate, getDuration: getDuration, getStartTime: getStartTime, getId: getId, getStreamInfo: getStreamInfo, getFragmentController: getFragmentController, getThumbnailController: getThumbnailController, getEventController: getEventController, getBitrateListFor: getBitrateListFor, startEventController: startEventController, stopEventController: stopEventController, updateData: updateData, reset: reset, getProcessors: getProcessors, setMediaSource: setMediaSource }; setup(); return instance; } Stream.__dashjs_factory_name = 'Stream'; export default FactoryMaker.getClassFactory(Stream); × Search results Close "},"streaming_controllers_StreamController.js.html":{"id":"streaming_controllers_StreamController.js.html","title":"Source: streaming/controllers/StreamController.js","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Source: streaming/controllers/StreamController.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ import Constants from '../constants/Constants'; import MetricsConstants from '../constants/MetricsConstants'; import Stream from '../Stream'; import ManifestUpdater from '../ManifestUpdater'; import EventBus from '../../core/EventBus'; import Events from '../../core/events/Events'; import MediaPlayerModel from '../models/MediaPlayerModel'; import FactoryMaker from '../../core/FactoryMaker'; import { PlayList, PlayListTrace } from '../vo/metrics/PlayList'; import Debug from '../../core/Debug'; import InitCache from '../utils/InitCache'; import URLUtils from '../utils/URLUtils'; import MediaPlayerEvents from '../MediaPlayerEvents'; import TimeSyncController from './TimeSyncController'; import BaseURLController from './BaseURLController'; import MediaSourceController from './MediaSourceController'; function StreamController() { // Check whether there is a gap every 40 wallClockUpdateEvent times const STALL_THRESHOLD_TO_CHECK_GAPS = 40; const context = this.context; const eventBus = EventBus(context).getInstance(); let instance, logger, capabilities, manifestUpdater, manifestLoader, manifestModel, dashManifestModel, adapter, metricsModel, dashMetrics, mediaSourceController, timeSyncController, baseURLController, domStorage, abrController, mediaController, textController, initCache, urlUtils, errHandler, timelineConverter, streams, activeStream, protectionController, protectionData, autoPlay, isStreamSwitchingInProgress, hasMediaError, hasInitialisationError, mediaSource, videoModel, playbackController, mediaPlayerModel, isPaused, initialPlayback, playListMetrics, videoTrackDetected, audioTrackDetected, isStreamBufferingCompleted, playbackEndedTimerId, wallclockTicked, lastPlaybackTime; function setup() { logger = Debug(context).getInstance().getLogger(instance); timeSyncController = TimeSyncController(context).getInstance(); baseURLController = BaseURLController(context).getInstance(); mediaSourceController = MediaSourceController(context).getInstance(); initCache = InitCache(context).getInstance(); urlUtils = URLUtils(context).getInstance(); resetInitialSettings(); } function initialize(autoPl, protData) { checkSetConfigCall(); autoPlay = autoPl; protectionData = protData; timelineConverter.initialize(); manifestUpdater = ManifestUpdater(context).create(); manifestUpdater.setConfig({ manifestModel: manifestModel, dashManifestModel: dashManifestModel, mediaPlayerModel: mediaPlayerModel, manifestLoader: manifestLoader, errHandler: errHandler }); manifestUpdater.initialize(); baseURLController.setConfig({ dashManifestModel: dashManifestModel }); eventBus.on(Events.TIME_SYNCHRONIZATION_COMPLETED, onTimeSyncCompleted, this); eventBus.on(Events.PLAYBACK_SEEKING, onPlaybackSeeking, this); eventBus.on(Events.PLAYBACK_TIME_UPDATED, onPlaybackTimeUpdated, this); eventBus.on(Events.PLAYBACK_ENDED, onEnded, this); eventBus.on(Events.PLAYBACK_ERROR, onPlaybackError, this); eventBus.on(Events.PLAYBACK_STARTED, onPlaybackStarted, this); eventBus.on(Events.PLAYBACK_PAUSED, onPlaybackPaused, this); eventBus.on(Events.MANIFEST_UPDATED, onManifestUpdated, this); eventBus.on(Events.STREAM_BUFFERING_COMPLETED, onStreamBufferingCompleted, this); eventBus.on(Events.MANIFEST_VALIDITY_CHANGED, onManifestValidityChanged, this); eventBus.on(Events.WALLCLOCK_TIME_UPDATED, onWallclockTimeUpdated, this); eventBus.on(MediaPlayerEvents.METRIC_ADDED, onMetricAdded, this); } /* * Called when current playback position is changed. * Used to determine the time current stream is finished and we should switch to the next stream. */ function onPlaybackTimeUpdated(/*e*/) { if (isVideoTrackPresent()) { const playbackQuality = videoModel.getPlaybackQuality(); if (playbackQuality) { metricsModel.addDroppedFrames(Constants.VIDEO, playbackQuality); } } } function onWallclockTimeUpdated(/*e*/) { if (!mediaPlayerModel.getJumpGaps() || !activeStream || activeStream.getProcessors().length === 0 || playbackController.isSeeking() || isPaused || isStreamSwitchingInProgress || hasMediaError || hasInitialisationError) { return; } wallclockTicked++; if (wallclockTicked &gt;= STALL_THRESHOLD_TO_CHECK_GAPS) { const currentTime = playbackController.getTime(); if (lastPlaybackTime === currentTime) { jumpGap(currentTime); } else { lastPlaybackTime = currentTime; } wallclockTicked = 0; } } function jumpGap(time) { const streamProcessors = activeStream.getProcessors(); const smallGapLimit = mediaPlayerModel.getSmallGapLimit(); let seekToPosition; // Find out what is the right time position to jump to taking // into account state of buffer for (let i = 0; i &lt; streamProcessors.length; i ++) { const mediaBuffer = streamProcessors[i].getBuffer(); const ranges = mediaBuffer.getAllBufferRanges(); let nextRangeStartTime; if (!ranges || ranges.length &lt;= 1) continue; // Get the range just after current time position for (let j = 0; j &lt; ranges.length; j++) { if (time &lt; ranges.start(j)) { nextRangeStartTime = ranges.start(j); break; } } if (nextRangeStartTime &gt; 0) { const gap = nextRangeStartTime - time; if (gap &gt; 0 &amp;&amp; gap &lt;= smallGapLimit) { if (seekToPosition === undefined || nextRangeStartTime &gt; seekToPosition) { seekToPosition = nextRangeStartTime; } } } } const timeToStreamEnd = playbackController.getTimeToStreamEnd(); if (seekToPosition === undefined &amp;&amp; !isNaN(timeToStreamEnd) &amp;&amp; timeToStreamEnd &lt; smallGapLimit) { seekToPosition = time + timeToStreamEnd; } // If there is a safe position to jump to, do the seeking if (seekToPosition &gt; 0) { if (!isNaN(timeToStreamEnd) &amp;&amp; seekToPosition &gt;= time + timeToStreamEnd) { logger.info('Jumping media gap (discontinuity) at time ', time, '. Jumping to end of the stream'); eventBus.trigger(Events.PLAYBACK_ENDED); } else { logger.info('Jumping media gap (discontinuity) at time ', time, '. Jumping to time position', seekToPosition); playbackController.seek(seekToPosition); } } } function onPlaybackSeeking(e) { const seekingStream = getStreamForTime(e.seekTime); //if end period has been detected, stop timer and reset isStreamBufferingCompleted if (playbackEndedTimerId) { stopEndPeriodTimer(); isStreamBufferingCompleted = false; } if (seekingStream &amp;&amp; seekingStream !== activeStream) { flushPlaylistMetrics(PlayListTrace.END_OF_PERIOD_STOP_REASON); switchStream(activeStream, seekingStream, e.seekTime); } else { flushPlaylistMetrics(PlayListTrace.USER_REQUEST_STOP_REASON); } addPlaylistMetrics(PlayList.SEEK_START_REASON); } function onPlaybackStarted( /*e*/ ) { logger.debug('[onPlaybackStarted]'); if (initialPlayback) { initialPlayback = false; addPlaylistMetrics(PlayList.INITIAL_PLAYOUT_START_REASON); } else { if (isPaused) { isPaused = false; addPlaylistMetrics(PlayList.RESUME_FROM_PAUSE_START_REASON); toggleEndPeriodTimer(); } } } function onPlaybackPaused(e) { logger.debug('[onPlaybackPaused]'); if (!e.ended) { isPaused = true; flushPlaylistMetrics(PlayListTrace.USER_REQUEST_STOP_REASON); toggleEndPeriodTimer(); } } function stopEndPeriodTimer() { logger.debug('[toggleEndPeriodTimer] stop end period timer.'); clearTimeout(playbackEndedTimerId); playbackEndedTimerId = undefined; } function toggleEndPeriodTimer() { //stream buffering completed has not been detected, nothing to do.... if (isStreamBufferingCompleted) { //stream buffering completed has been detected, if end period timer is running, stop it, otherwise start it.... if (playbackEndedTimerId) { stopEndPeriodTimer(); } else { const timeToEnd = playbackController.getTimeToStreamEnd(); const delayPlaybackEnded = timeToEnd &gt; 0 ? timeToEnd * 1000 : 0; logger.debug('[toggleEndPeriodTimer] start-up of timer to notify PLAYBACK_ENDED event. It will be triggered in ' + delayPlaybackEnded + ' milliseconds'); playbackEndedTimerId = setTimeout(function () {eventBus.trigger(Events.PLAYBACK_ENDED);}, delayPlaybackEnded); } } } function onStreamBufferingCompleted() { const isLast = getActiveStreamInfo().isLast; if (mediaSource &amp;&amp; isLast) { logger.info('[onStreamBufferingCompleted] calls signalEndOfStream of mediaSourceController.'); mediaSourceController.signalEndOfStream(mediaSource); } else if (mediaSource &amp;&amp; playbackEndedTimerId === undefined) { //send PLAYBACK_ENDED in order to switch to a new period, wait until the end of playing logger.info('[StreamController][onStreamBufferingCompleted] end of period detected'); isStreamBufferingCompleted = true; if (isPaused === false) { toggleEndPeriodTimer(); } } } function getStreamForTime(time) { let duration = 0; let stream = null; const ln = streams.length; if (ln &gt; 0) { duration += streams[0].getStartTime(); } for (let i = 0; i &lt; ln; i++) { stream = streams[i]; duration = parseFloat((duration + stream.getDuration()).toFixed(5)); if (time &lt; duration) { return stream; } } return null; } /** * Returns a playhead time, in seconds, converted to be relative * to the start of an identified stream/period or null if no such stream * @param {number} time * @param {string} id * @returns {number|null} */ function getTimeRelativeToStreamId(time, id) { let stream = null; let baseStart = 0; let streamStart = 0; let streamDur = null; const ln = streams.length; for (let i = 0; i &lt; ln; i++) { stream = streams[i]; streamStart = stream.getStartTime(); streamDur = stream.getDuration(); // use start time, if not undefined or NaN or similar if (Number.isFinite(streamStart)) { baseStart = streamStart; } if (stream.getId() === id) { return time - baseStart; } else { // use duration if not undefined or NaN or similar if (Number.isFinite(streamDur)) { baseStart += streamDur; } } } return null; } function getActiveStreamProcessors() { return activeStream ? activeStream.getProcessors() : []; } function onEnded() { const nextStream = getNextStream(); if (nextStream) { audioTrackDetected = undefined; videoTrackDetected = undefined; switchStream(activeStream, nextStream, NaN); } else { logger.debug('StreamController no next stream found'); } flushPlaylistMetrics(nextStream ? PlayListTrace.END_OF_PERIOD_STOP_REASON : PlayListTrace.END_OF_CONTENT_STOP_REASON); playbackEndedTimerId = undefined; isStreamBufferingCompleted = false; } function getNextStream() { if (activeStream) { const start = activeStream.getStreamInfo().start; const duration = activeStream.getStreamInfo().duration; return streams.filter(function (stream) { return (stream.getStreamInfo().start === parseFloat((start + duration).toFixed(5))); })[0]; } } function switchStream(oldStream, newStream, seekTime) { if (isStreamSwitchingInProgress || !newStream || oldStream === newStream) return; isStreamSwitchingInProgress = true; eventBus.trigger(Events.PERIOD_SWITCH_STARTED, { fromStreamInfo: oldStream ? oldStream.getStreamInfo() : null, toStreamInfo: newStream.getStreamInfo() }); if (oldStream) { oldStream.stopEventController(); oldStream.deactivate(); } activeStream = newStream; playbackController.initialize(activeStream.getStreamInfo()); if (videoModel.getElement()) { //TODO detect if we should close jump to activateStream. openMediaSource(seekTime, oldStream, false); } else { preloadStream(seekTime); } } function preloadStream(seekTime) { activateStream(seekTime); } function switchToVideoElement(seekTime) { playbackController.initialize(activeStream.getStreamInfo()); openMediaSource(seekTime, null, true); } function openMediaSource(seekTime, oldStream, streamActivated) { let sourceUrl; function onMediaSourceOpen() { // Manage situations in which a call to reset happens while MediaSource is being opened if (!mediaSource) return; logger.debug('MediaSource is open!'); window.URL.revokeObjectURL(sourceUrl); mediaSource.removeEventListener('sourceopen', onMediaSourceOpen); mediaSource.removeEventListener('webkitsourceopen', onMediaSourceOpen); setMediaDuration(); if (!oldStream) { eventBus.trigger(Events.SOURCE_INITIALIZED); } if (streamActivated) { activeStream.setMediaSource(mediaSource); } else { activateStream(seekTime); } } if (!mediaSource) { mediaSource = mediaSourceController.createMediaSource(); } else { mediaSourceController.detachMediaSource(videoModel); } mediaSource.addEventListener('sourceopen', onMediaSourceOpen, false); mediaSource.addEventListener('webkitsourceopen', onMediaSourceOpen, false); sourceUrl = mediaSourceController.attachMediaSource(mediaSource, videoModel); logger.debug('MediaSource attached to element. Waiting on open...'); } function activateStream(seekTime) { activeStream.activate(mediaSource); audioTrackDetected = checkTrackPresence(Constants.AUDIO); videoTrackDetected = checkTrackPresence(Constants.VIDEO); if (!initialPlayback) { if (!isNaN(seekTime)) { playbackController.seek(seekTime); //we only need to call seek here, IndexHandlerTime was set from seeking event } else { let startTime = playbackController.getStreamStartTime(true); activeStream.getProcessors().forEach(p =&gt; { adapter.setIndexHandlerTime(p, startTime); }); } } activeStream.startEventController(); if (autoPlay || !initialPlayback) { playbackController.play(); } isStreamSwitchingInProgress = false; eventBus.trigger(Events.PERIOD_SWITCH_COMPLETED, { toStreamInfo: activeStream.getStreamInfo() }); } function setMediaDuration() { const manifestDuration = activeStream.getStreamInfo().manifestInfo.duration; const mediaDuration = mediaSourceController.setDuration(mediaSource, manifestDuration); logger.debug('Duration successfully set to: ' + mediaDuration); } function getComposedStream(streamInfo) { for (let i = 0, ln = streams.length; i &lt; ln; i++) { if (streams[i].getId() === streamInfo.id) { return streams[i]; } } return null; } function composeStreams() { try { const streamsInfo = adapter.getStreamsInfo(); if (streamsInfo.length === 0) { throw new Error('There are no streams'); } const manifestUpdateInfo = dashMetrics.getCurrentManifestUpdate(metricsModel.getMetricsFor(Constants.STREAM)); metricsModel.updateManifestUpdateInfo(manifestUpdateInfo, { currentTime: playbackController.getTime(), buffered: videoModel.getBufferRange(), presentationStartTime: streamsInfo[0].start, clientTimeOffset: timelineConverter.getClientTimeOffset() }); for (let i = 0, ln = streamsInfo.length; i &lt; ln; i++) { // If the Stream object does not exist we probably loaded the manifest the first time or it was // introduced in the updated manifest, so we need to create a new Stream and perform all the initialization operations const streamInfo = streamsInfo[i]; let stream = getComposedStream(streamInfo); if (!stream) { stream = Stream(context).create({ manifestModel: manifestModel, dashManifestModel: dashManifestModel, mediaPlayerModel: mediaPlayerModel, metricsModel: metricsModel, dashMetrics: dashMetrics, manifestUpdater: manifestUpdater, adapter: adapter, timelineConverter: timelineConverter, capabilities: capabilities, errHandler: errHandler, baseURLController: baseURLController, domStorage: domStorage, abrController: abrController, playbackController: playbackController, mediaController: mediaController, textController: textController, videoModel: videoModel, streamController: instance }); streams.push(stream); stream.initialize(streamInfo, protectionController); } else { stream.updateData(streamInfo); } metricsModel.addManifestUpdateStreamInfo(manifestUpdateInfo, streamInfo.id, streamInfo.index, streamInfo.start, streamInfo.duration); } if (!activeStream) { // we need to figure out what the correct starting period is const startTimeFormUriParameters = playbackController.getStartTimeFromUriParameters(); let initialStream = null; if (startTimeFormUriParameters) { const initialTime = !isNaN(startTimeFormUriParameters.fragS) ? startTimeFormUriParameters.fragS : startTimeFormUriParameters.fragT; initialStream = getStreamForTime(initialTime); } switchStream(null, initialStream !== null ? initialStream : streams[0], NaN); } eventBus.trigger(Events.STREAMS_COMPOSED); } catch (e) { errHandler.manifestError(e.message, 'nostreamscomposed', manifestModel.getValue()); hasInitialisationError = true; reset(); } } function onTimeSyncCompleted( /*e*/ ) { const manifest = manifestModel.getValue(); //TODO check if we can move this to initialize?? if (protectionController) { eventBus.trigger(Events.PROTECTION_CREATED, { controller: protectionController, manifest: manifest }); protectionController.setMediaElement(videoModel.getElement()); if (protectionData) { protectionController.setProtectionData(protectionData); } } composeStreams(); } function onManifestUpdated(e) { if (!e.error) { //Since streams are not composed yet , need to manually look up useCalculatedLiveEdgeTime to detect if stream //is SegmentTimeline to avoid using time source const manifest = e.manifest; adapter.updatePeriods(manifest); const streamInfo = adapter.getStreamsInfo(undefined, 1)[0]; const mediaInfo = ( adapter.getMediaInfoForType(streamInfo, Constants.VIDEO) || adapter.getMediaInfoForType(streamInfo, Constants.AUDIO) ); let useCalculatedLiveEdgeTime; if (mediaInfo) { useCalculatedLiveEdgeTime = dashManifestModel.getUseCalculatedLiveEdgeTimeForAdaptation(adapter.getDataForMedia(mediaInfo)); if (useCalculatedLiveEdgeTime) { logger.debug('SegmentTimeline detected using calculated Live Edge Time'); mediaPlayerModel.setUseManifestDateHeaderTimeSource(false); } } let manifestUTCTimingSources = dashManifestModel.getUTCTimingSources(e.manifest); let allUTCTimingSources = (!dashManifestModel.getIsDynamic(manifest) || useCalculatedLiveEdgeTime) ? manifestUTCTimingSources : manifestUTCTimingSources.concat(mediaPlayerModel.getUTCTimingSources()); const isHTTPS = urlUtils.isHTTPS(e.manifest.url); //If https is detected on manifest then lets apply that protocol to only the default time source(s). In the future we may find the need to apply this to more then just default so left code at this level instead of in MediaPlayer. allUTCTimingSources.forEach(function (item) { if (item.value.replace(/.*?:\\/\\//g, '') === MediaPlayerModel.DEFAULT_UTC_TIMING_SOURCE.value.replace(/.*?:\\/\\//g, '')) { item.value = item.value.replace(isHTTPS ? new RegExp(/^(http:)?\\/\\//i) : new RegExp(/^(https:)?\\/\\//i), isHTTPS ? 'https://' : 'http://'); logger.debug('Matching default timing source protocol to manifest protocol: ', item.value); } }); baseURLController.initialize(manifest); timeSyncController.setConfig({ metricsModel: metricsModel, dashMetrics: dashMetrics, baseURLController: baseURLController }); timeSyncController.initialize(allUTCTimingSources, mediaPlayerModel.getUseManifestDateHeaderTimeSource()); } else { hasInitialisationError = true; reset(); } } function isAudioTrackPresent() { return audioTrackDetected; } function isVideoTrackPresent() { return videoTrackDetected; } function checkTrackPresence(type) { let isDetected = false; if (activeStream) { activeStream.getProcessors().forEach(p =&gt; { if (p.getMediaInfo().type === type) { isDetected = true; } }); } return isDetected; } function flushPlaylistMetrics(reason, time) { time = time || new Date(); if (playListMetrics) { if (activeStream) { activeStream.getProcessors().forEach(p =&gt; { const ctrlr = p.getScheduleController(); if (ctrlr) { ctrlr.finalisePlayList(time, reason); } }); } metricsModel.addPlayList(playListMetrics); playListMetrics = null; } } function addPlaylistMetrics(startReason) { playListMetrics = new PlayList(); playListMetrics.start = new Date(); playListMetrics.mstart = playbackController.getTime() * 1000; playListMetrics.starttype = startReason; if (activeStream) { activeStream.getProcessors().forEach(p =&gt; { let ctrlr = p.getScheduleController(); if (ctrlr) { ctrlr.setPlayList(playListMetrics); } }); } } function onPlaybackError(e) { if (!e.error) return; let msg = ''; switch (e.error.code) { case 1: msg = 'MEDIA_ERR_ABORTED'; break; case 2: msg = 'MEDIA_ERR_NETWORK'; break; case 3: msg = 'MEDIA_ERR_DECODE'; break; case 4: msg = 'MEDIA_ERR_SRC_NOT_SUPPORTED'; break; case 5: msg = 'MEDIA_ERR_ENCRYPTED'; break; default: msg = 'UNKNOWN'; break; } hasMediaError = true; if (e.error.message) { msg += ' (' + e.error.message + ')'; } if (e.error.msExtendedCode) { msg += ' (0x' + (e.error.msExtendedCode &gt;&gt;&gt; 0).toString(16).toUpperCase() + ')'; } logger.fatal('Video Element Error: ' + msg); if (e.error) { logger.fatal(e.error); } errHandler.mediaSourceError(msg); reset(); } function getActiveStreamInfo() { return activeStream ? activeStream.getStreamInfo() : null; } function getStreamById(id) { return streams.filter(function (item) { return item.getId() === id; })[0]; } function checkSetConfigCall() { if (!manifestLoader || !manifestLoader.hasOwnProperty('load') || !timelineConverter || !timelineConverter.hasOwnProperty('initialize') || !timelineConverter.hasOwnProperty('reset') || !timelineConverter.hasOwnProperty('getClientTimeOffset')) { throw new Error('setConfig function has to be called previously'); } } function checkInitializeCall() { if (!manifestUpdater || !manifestUpdater.hasOwnProperty('setManifest')) { throw new Error('initialize function has to be called previously'); } } function load(url) { checkSetConfigCall(); manifestLoader.load(url); } function loadWithManifest(manifest) { checkInitializeCall(); manifestUpdater.setManifest(manifest); } function onManifestValidityChanged(e) { if (!isNaN(e.newDuration)) { setMediaDuration(e.newDuration); } } function setConfig(config) { if (!config) return; if (config.capabilities) { capabilities = config.capabilities; } if (config.manifestLoader) { manifestLoader = config.manifestLoader; } if (config.manifestModel) { manifestModel = config.manifestModel; } if (config.dashManifestModel) { dashManifestModel = config.dashManifestModel; } if (config.mediaPlayerModel) { mediaPlayerModel = config.mediaPlayerModel; } if (config.protectionController) { protectionController = config.protectionController; } if (config.adapter) { adapter = config.adapter; } if (config.metricsModel) { metricsModel = config.metricsModel; } if (config.dashMetrics) { dashMetrics = config.dashMetrics; } if (config.errHandler) { errHandler = config.errHandler; } if (config.timelineConverter) { timelineConverter = config.timelineConverter; } if (config.videoModel) { videoModel = config.videoModel; } if (config.playbackController) { playbackController = config.playbackController; } if (config.domStorage) { domStorage = config.domStorage; } if (config.abrController) { abrController = config.abrController; } if (config.mediaController) { mediaController = config.mediaController; } if (config.textController) { textController = config.textController; } } function setProtectionData(protData) { protectionData = protData; } function resetInitialSettings() { streams = []; protectionController = null; isStreamSwitchingInProgress = false; activeStream = null; hasMediaError = false; hasInitialisationError = false; videoTrackDetected = undefined; audioTrackDetected = undefined; initialPlayback = true; isPaused = false; autoPlay = true; playListMetrics = null; playbackEndedTimerId = undefined; isStreamBufferingCompleted = false; wallclockTicked = 0; } function reset() { checkSetConfigCall(); timeSyncController.reset(); flushPlaylistMetrics( hasMediaError || hasInitialisationError ? PlayListTrace.FAILURE_STOP_REASON : PlayListTrace.USER_REQUEST_STOP_REASON ); for (let i = 0, ln = streams ? streams.length : 0; i &lt; ln; i++) { const stream = streams[i]; stream.reset(hasMediaError); } eventBus.off(Events.PLAYBACK_TIME_UPDATED, onPlaybackTimeUpdated, this); eventBus.off(Events.PLAYBACK_SEEKING, onPlaybackSeeking, this); eventBus.off(Events.PLAYBACK_ERROR, onPlaybackError, this); eventBus.off(Events.PLAYBACK_STARTED, onPlaybackStarted, this); eventBus.off(Events.PLAYBACK_PAUSED, onPlaybackPaused, this); eventBus.off(Events.PLAYBACK_ENDED, onEnded, this); eventBus.off(Events.MANIFEST_UPDATED, onManifestUpdated, this); eventBus.off(Events.STREAM_BUFFERING_COMPLETED, onStreamBufferingCompleted, this); eventBus.off(MediaPlayerEvents.METRIC_ADDED, onMetricAdded, this); eventBus.off(Events.MANIFEST_VALIDITY_CHANGED, onManifestValidityChanged, this); baseURLController.reset(); manifestUpdater.reset(); metricsModel.clearAllCurrentMetrics(); manifestModel.setValue(null); manifestLoader.reset(); timelineConverter.reset(); initCache.reset(); if (mediaSource) { mediaSourceController.detachMediaSource(videoModel); mediaSource = null; } videoModel = null; if (protectionController) { protectionController.setMediaElement(null); protectionController = null; protectionData = null; if (manifestModel.getValue()) { eventBus.trigger(Events.PROTECTION_DESTROYED, { data: manifestModel.getValue().url }); } } eventBus.trigger(Events.STREAM_TEARDOWN_COMPLETE); resetInitialSettings(); } function onMetricAdded(e) { if (e.metric === MetricsConstants.DVR_INFO) { //Match media type? How can DVR window be different for media types? //Should we normalize and union the two? if (e.mediaType === Constants.AUDIO) { mediaSourceController.setSeekable(mediaSource, e.value.range.start, e.value.range.end); } } } instance = { initialize: initialize, getActiveStreamInfo: getActiveStreamInfo, isVideoTrackPresent: isVideoTrackPresent, isAudioTrackPresent: isAudioTrackPresent, switchToVideoElement: switchToVideoElement, getStreamById: getStreamById, getStreamForTime: getStreamForTime, getTimeRelativeToStreamId: getTimeRelativeToStreamId, load: load, loadWithManifest: loadWithManifest, getActiveStreamProcessors: getActiveStreamProcessors, setConfig: setConfig, setProtectionData: setProtectionData, reset: reset }; setup(); return instance; } StreamController.__dashjs_factory_name = 'StreamController'; export default FactoryMaker.getSingletonFactory(StreamController); × Search results Close "},"streaming_vo_metrics_TCPConnection.js.html":{"id":"streaming_vo_metrics_TCPConnection.js.html","title":"Source: streaming/vo/metrics/TCPConnection.js","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Source: streaming/vo/metrics/TCPConnection.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ /** * @class */ class TCPConnection { /** * @description This Object holds reference to the current tcp connection */ constructor() { /** * Identifier of the TCP connection on which the HTTP request was sent. * @public */ this.tcpid = null; /** * IP Address of the interface over which the client is receiving the TCP data. * @public */ this.dest = null; /** * Real-Time | The time at which the connection was opened (sending time of the initial SYN or connect socket operation). * @public */ this.topen = null; /** * Real-Time | The time at which the connection was closed (sending or reception time of FIN or RST or close socket operation). * @public */ this.tclose = null; /** * Connect time in ms (time from sending the initial SYN to receiving the ACK or completion of the connect socket operation). * @public */ this.tconnect = null; } } export default TCPConnection; × Search results Close "},"streaming_text_TextSourceBuffer.js.html":{"id":"streaming_text_TextSourceBuffer.js.html","title":"Source: streaming/text/TextSourceBuffer.js","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Source: streaming/text/TextSourceBuffer.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ import Constants from '../constants/Constants'; import {HTTPRequest} from '../vo/metrics/HTTPRequest'; import TextTrackInfo from '../vo/TextTrackInfo'; import FragmentedTextBoxParser from '../../dash/utils/FragmentedTextBoxParser'; import BoxParser from '../utils/BoxParser'; import CustomTimeRanges from '../utils/CustomTimeRanges'; import FactoryMaker from '../../core/FactoryMaker'; import Debug from '../../core/Debug'; import TextTracks from './TextTracks'; import EmbeddedTextHtmlRender from './EmbeddedTextHtmlRender'; import ISOBoxer from 'codem-isoboxer'; import cea608parser from '../../../externals/cea608-parser'; import EventBus from '../../core/EventBus'; import Events from '../../core/events/Events'; function TextSourceBuffer() { const context = this.context; const eventBus = EventBus(context).getInstance(); let embeddedInitialized = false; let instance, logger, boxParser, errHandler, dashManifestModel, manifestModel, mediaController, parser, vttParser, ttmlParser, fragmentedTextBoxParser, mediaInfos, textTracks, isFragmented, fragmentModel, initializationSegmentReceived, timescale, fragmentedTracks, videoModel, streamController, firstSubtitleStart, currFragmentedTrackIdx, embeddedTracks, embeddedInitializationSegmentReceived, embeddedTimescale, embeddedLastSequenceNumber, embeddedSequenceNumbers, embeddedCea608FieldParsers, embeddedTextHtmlRender, mseTimeOffset; function setup() { logger = Debug(context).getInstance().getLogger(instance); } function initialize(mimeType, streamProcessor) { parser = null; fragmentModel = null; initializationSegmentReceived = false; timescale = NaN; fragmentedTracks = []; firstSubtitleStart = null; if (!embeddedInitialized) { initEmbedded(); } mediaInfos = streamProcessor.getMediaInfoArr(); textTracks.setConfig({ videoModel: videoModel }); textTracks.initialize(); isFragmented = !dashManifestModel.getIsTextTrack(mimeType); boxParser = BoxParser(context).getInstance(); fragmentedTextBoxParser = FragmentedTextBoxParser(context).getInstance(); fragmentedTextBoxParser.setConfig({ boxParser: boxParser }); if (isFragmented) { fragmentModel = streamProcessor.getFragmentModel(); this.buffered = CustomTimeRanges(context).create(); fragmentedTracks = mediaController.getTracksFor(Constants.FRAGMENTED_TEXT, streamController.getActiveStreamInfo()); const currFragTrack = mediaController.getCurrentTrackFor(Constants.FRAGMENTED_TEXT, streamController.getActiveStreamInfo()); for (let i = 0; i &lt; fragmentedTracks.length; i++) { if (fragmentedTracks[i] === currFragTrack) { currFragmentedTrackIdx = i; break; } } } } function abort() { textTracks.deleteAllTextTracks(); fragmentedTextBoxParser = null; boxParser = null; mediaInfos = null; isFragmented = false; fragmentModel = null; initializationSegmentReceived = false; fragmentedTracks = []; } function reset() { parser = null; streamController = null; videoModel = null; timescale = NaN; textTracks = null; } function onVideoChunkReceived(e) { const chunk = e.chunk; if (chunk.mediaInfo.embeddedCaptions) { append(chunk.bytes, chunk); } } function initEmbedded() { embeddedTracks = []; mediaInfos = []; textTracks = TextTracks(context).getInstance(); textTracks.setConfig({ videoModel: videoModel }); textTracks.initialize(); boxParser = BoxParser(context).getInstance(); fragmentedTextBoxParser = FragmentedTextBoxParser(context).getInstance(); fragmentedTextBoxParser.setConfig({ boxParser: boxParser }); isFragmented = false; currFragmentedTrackIdx = null; embeddedInitializationSegmentReceived = false; embeddedTimescale = 0; embeddedCea608FieldParsers = []; embeddedSequenceNumbers = []; embeddedLastSequenceNumber = null; embeddedInitialized = true; embeddedTextHtmlRender = EmbeddedTextHtmlRender(context).getInstance(); const streamProcessors = streamController.getActiveStreamProcessors(); for (const i in streamProcessors) { if (streamProcessors[i].getType() === 'video') { mseTimeOffset = streamProcessors[i].getCurrentRepresentationInfo().MSETimeOffset; break; } } eventBus.on(Events.VIDEO_CHUNK_RECEIVED, onVideoChunkReceived, this); } function resetEmbedded() { eventBus.off(Events.VIDEO_CHUNK_RECEIVED, onVideoChunkReceived, this); if (textTracks) { textTracks.deleteAllTextTracks(); } embeddedInitialized = false; embeddedTracks = []; embeddedCea608FieldParsers = [null, null]; embeddedSequenceNumbers = []; embeddedLastSequenceNumber = null; } function addEmbeddedTrack(mediaInfo) { if (!embeddedInitialized) { initEmbedded(); } if (mediaInfo.id === Constants.CC1 || mediaInfo.id === Constants.CC3) { for (let i = 0; i &lt; embeddedTracks.length; i++) { if (embeddedTracks[i].id === mediaInfo.id) { return; } } embeddedTracks.push(mediaInfo); } else { logger.warn('Embedded track ' + mediaInfo.id + ' not supported!'); } } function setConfig(config) { if (!config) { return; } if (config.errHandler) { errHandler = config.errHandler; } if (config.dashManifestModel) { dashManifestModel = config.dashManifestModel; } if (config.manifestModel) { manifestModel = config.manifestModel; } if (config.mediaController) { mediaController = config.mediaController; } if (config.videoModel) { videoModel = config.videoModel; } if (config.streamController) { streamController = config.streamController; } if (config.textTracks) { textTracks = config.textTracks; } if (config.vttParser) { vttParser = config.vttParser; } if (config.ttmlParser) { ttmlParser = config.ttmlParser; } } function getConfig() { const config = { errHandler: errHandler, dashManifestModel: dashManifestModel, mediaController: mediaController, videoModel: videoModel, fragmentModel: fragmentModel, streamController: streamController, textTracks: textTracks, isFragmented: isFragmented, embeddedTracks: embeddedTracks, fragmentedTracks: fragmentedTracks }; return config; } function setCurrentFragmentedTrackIdx(idx) { currFragmentedTrackIdx = idx; } function append(bytes, chunk) { let result, sampleList, i, j, k, samplesInfo, ccContent; const mediaInfo = chunk.mediaInfo; const mediaType = mediaInfo.type; const mimeType = mediaInfo.mimeType; const codecType = mediaInfo.codec || mimeType; if (!codecType) { logger.error('No text type defined'); return; } function createTextTrackFromMediaInfo(captionData, mediaInfo) { const textTrackInfo = new TextTrackInfo(); const trackKindMap = { subtitle: 'subtitles', caption: 'captions' }; //Dash Spec has no &quot;s&quot; on end of KIND but HTML needs plural. const getKind = function () { let kind = (mediaInfo.roles.length &gt; 0) ? trackKindMap[mediaInfo.roles[0]] : trackKindMap.caption; kind = (kind === trackKindMap.caption || kind === trackKindMap.subtitle) ? kind : trackKindMap.caption; return kind; }; const checkTTML = function () { let ttml = false; if (mediaInfo.codec &amp;&amp; mediaInfo.codec.search(Constants.STPP) &gt;= 0) { ttml = true; } if (mediaInfo.mimeType &amp;&amp; mediaInfo.mimeType.search(Constants.TTML) &gt;= 0) { ttml = true; } return ttml; }; textTrackInfo.captionData = captionData; textTrackInfo.lang = mediaInfo.lang; textTrackInfo.label = mediaInfo.id ? mediaInfo.id : mediaInfo.index; // AdaptationSet id (an unsigned int) as it's optionnal parameter, use mediaInfo.index textTrackInfo.index = mediaInfo.index; // AdaptationSet index in manifest textTrackInfo.isTTML = checkTTML(); textTrackInfo.defaultTrack = getIsDefault(mediaInfo); textTrackInfo.isFragmented = isFragmented; textTrackInfo.isEmbedded = mediaInfo.isEmbedded ? true : false; textTrackInfo.kind = getKind(); textTrackInfo.roles = mediaInfo.roles; textTrackInfo.accessibility = mediaInfo.accessibility; const totalNrTracks = (mediaInfos ? mediaInfos.length : 0) + embeddedTracks.length; textTracks.addTextTrack(textTrackInfo, totalNrTracks); } if (mediaType === Constants.FRAGMENTED_TEXT) { if (!initializationSegmentReceived) { initializationSegmentReceived = true; for (i = 0; i &lt; mediaInfos.length; i++) { createTextTrackFromMediaInfo(null, mediaInfos[i]); } timescale = fragmentedTextBoxParser.getMediaTimescaleFromMoov(bytes); } else { samplesInfo = fragmentedTextBoxParser.getSamplesInfo(bytes); sampleList = samplesInfo.sampleList; if (!firstSubtitleStart &amp;&amp; sampleList.length &gt; 0) { firstSubtitleStart = sampleList[0].cts - chunk.start * timescale; } if (codecType.search(Constants.STPP) &gt;= 0) { parser = parser !== null ? parser : getParser(codecType); for (i = 0; i &lt; sampleList.length; i++) { const sample = sampleList[i]; const sampleStart = sample.cts; const sampleRelStart = sampleStart - firstSubtitleStart; this.buffered.add(sampleRelStart / timescale, (sampleRelStart + sample.duration) / timescale); const dataView = new DataView(bytes, sample.offset, sample.subSizes[0]); ccContent = ISOBoxer.Utils.dataViewToString(dataView, Constants.UTF8); const images = []; let subOffset = sample.offset + sample.subSizes[0]; for (j = 1; j &lt; sample.subSizes.length; j++) { const inData = new Uint8Array(bytes, subOffset, sample.subSizes[j]); const raw = String.fromCharCode.apply(null, inData); images.push(raw); subOffset += sample.subSizes[j]; } try { // Only used for Miscrosoft Smooth Streaming support - caption time is relative to sample time. In this case, we apply an offset. const manifest = manifestModel.getValue(); const offsetTime = manifest.ttmlTimeIsRelative ? sampleStart / timescale : 0; result = parser.parse(ccContent, offsetTime, sampleStart / timescale, (sampleStart + sample.duration) / timescale, images); textTracks.addCaptions(currFragmentedTrackIdx, firstSubtitleStart / timescale, result); } catch (e) { fragmentModel.removeExecutedRequestsBeforeTime(); this.remove(); logger.error('TTML parser error: ' + e.message); } } } else { // WebVTT case const captionArray = []; for (i = 0 ; i &lt; sampleList.length; i++) { const sample = sampleList[i]; sample.cts -= firstSubtitleStart; this.buffered.add(sample.cts / timescale, (sample.cts + sample.duration) / timescale); const sampleData = bytes.slice(sample.offset, sample.offset + sample.size); // There are boxes inside the sampleData, so we need a ISOBoxer to get at it. const sampleBoxes = ISOBoxer.parseBuffer(sampleData); for (j = 0 ; j &lt; sampleBoxes.boxes.length; j++) { const box1 = sampleBoxes.boxes[j]; logger.debug('VTT box1: ' + box1.type); if (box1.type === 'vtte') { continue; //Empty box } if (box1.type === 'vttc') { logger.debug('VTT vttc boxes.length = ' + box1.boxes.length); for (k = 0 ; k &lt; box1.boxes.length; k++) { const box2 = box1.boxes[k]; logger.debug('VTT box2: ' + box2.type); if (box2.type === 'payl') { const cue_text = box2.cue_text; logger.debug('VTT cue_text = ' + cue_text); const start_time = sample.cts / timescale; const end_time = (sample.cts + sample.duration) / timescale; captionArray.push({ start: start_time, end: end_time, data: cue_text, styles: {} }); logger.debug('VTT ' + start_time + '-' + end_time + ' : ' + cue_text); } } } } } if (captionArray.length &gt; 0) { textTracks.addCaptions(currFragmentedTrackIdx, 0, captionArray); } } } } else if (mediaType === Constants.TEXT) { const dataView = new DataView(bytes, 0, bytes.byteLength); ccContent = ISOBoxer.Utils.dataViewToString(dataView, Constants.UTF8); try { result = getParser(codecType).parse(ccContent, 0); for (i = 0; i &lt; mediaInfos.length; i++) { createTextTrackFromMediaInfo(null, mediaInfos[i]); } textTracks.addCaptions(textTracks.getCurrentTrackIdx(), 0, result); } catch (e) { errHandler.timedTextError(e, 'parse', ccContent); } } else if (mediaType === Constants.VIDEO) { //embedded text if (chunk.segmentType === HTTPRequest.INIT_SEGMENT_TYPE) { if (embeddedTimescale === 0) { embeddedTimescale = fragmentedTextBoxParser.getMediaTimescaleFromMoov(bytes); for (i = 0; i &lt; embeddedTracks.length; i++) { createTextTrackFromMediaInfo(null, embeddedTracks[i]); } } } else { // MediaSegment if (embeddedTimescale === 0) { logger.warn('CEA-608: No timescale for embeddedTextTrack yet'); return; } const makeCueAdderForIndex = function (self, trackIndex) { function newCue(startTime, endTime, captionScreen) { let captionsArray = null; if (videoModel.getTTMLRenderingDiv()) { captionsArray = embeddedTextHtmlRender.createHTMLCaptionsFromScreen(videoModel.getElement(), startTime, endTime, captionScreen); } else { const text = captionScreen.getDisplayText(); captionsArray = [{ start: startTime, end: endTime, data: text, styles: {} }]; } if (captionsArray) { textTracks.addCaptions(trackIndex, 0, captionsArray); } } return newCue; }; samplesInfo = fragmentedTextBoxParser.getSamplesInfo(bytes); const sequenceNumber = samplesInfo.lastSequenceNumber; if (!embeddedCea608FieldParsers[0] &amp;&amp; !embeddedCea608FieldParsers[1]) { // Time to setup the CEA-608 parsing let field, handler, trackIdx; for (i = 0; i &lt; embeddedTracks.length; i++) { if (embeddedTracks[i].id === Constants.CC1) { field = 0; trackIdx = textTracks.getTrackIdxForId(Constants.CC1); } else if (embeddedTracks[i].id === Constants.CC3) { field = 1; trackIdx = textTracks.getTrackIdxForId(Constants.CC3); } if (trackIdx === -1) { logger.warn('CEA-608: data before track is ready.'); return; } handler = makeCueAdderForIndex(this, trackIdx); embeddedCea608FieldParsers[i] = new cea608parser.Cea608Parser(i, { 'newCue': handler }, null); } } if (embeddedTimescale &amp;&amp; embeddedSequenceNumbers.indexOf(sequenceNumber) == -1) { if (embeddedLastSequenceNumber !== null &amp;&amp; sequenceNumber !== embeddedLastSequenceNumber + samplesInfo.numSequences) { for (i = 0; i &lt; embeddedCea608FieldParsers.length; i++) { if (embeddedCea608FieldParsers[i]) { embeddedCea608FieldParsers[i].reset(); } } } const allCcData = extractCea608Data(bytes, samplesInfo.sampleList); for (let fieldNr = 0; fieldNr &lt; embeddedCea608FieldParsers.length; fieldNr++) { const ccData = allCcData.fields[fieldNr]; const fieldParser = embeddedCea608FieldParsers[fieldNr]; if (fieldParser) { for (i = 0; i &lt; ccData.length; i++) { fieldParser.addData(ccData[i][0] / embeddedTimescale, ccData[i][1]); } } } embeddedLastSequenceNumber = sequenceNumber; embeddedSequenceNumbers.push(sequenceNumber); } } } } /** * Extract CEA-608 data from a buffer of data. * @param {ArrayBuffer} data * @param {Array} samples cue information * @returns {Object|null} ccData corresponding to one segment. */ function extractCea608Data(data, samples) { if (samples.length === 0) { return null; } const allCcData = { splits: [], fields: [[], []] }; const raw = new DataView(data); for (let i = 0; i &lt; samples.length; i++) { const sample = samples[i]; const cea608Ranges = cea608parser.findCea608Nalus(raw, sample.offset, sample.size); let lastSampleTime = null; let idx = 0; for (let j = 0; j &lt; cea608Ranges.length; j++) { const ccData = cea608parser.extractCea608DataFromRange(raw, cea608Ranges[j]); for (let k = 0; k &lt; 2; k++) { if (ccData[k].length &gt; 0) { if (sample.cts !== lastSampleTime) { idx = 0; } else { idx += 1; } allCcData.fields[k].push([sample.cts + (mseTimeOffset * embeddedTimescale), ccData[k], idx]); lastSampleTime = sample.cts; } } } } // Sort by sampleTime ascending order // If two packets have the same sampleTime, use them in the order // they were received allCcData.fields.forEach(function sortField(field) { field.sort(function (a, b) { if (a[0] === b[0]) { return a[2] - b[2]; } return a[0] - b[0]; }); }); return allCcData; } function getIsDefault(mediaInfo) { //TODO How to tag default. currently same order as listed in manifest. // Is there a way to mark a text adaptation set as the default one? DASHIF meeting talk about using role which is being used for track KIND // Eg subtitles etc. You can have multiple role tags per adaptation Not defined in the spec yet. let isDefault = false; if (embeddedTracks.length &gt; 1 &amp;&amp; mediaInfo.isEmbedded) { isDefault = (mediaInfo.id &amp;&amp; mediaInfo.id === Constants.CC1); // CC1 if both CC1 and CC3 exist } else if (embeddedTracks.length === 1) { if (mediaInfo.id &amp;&amp; mediaInfo.id.substring(0, 2) === 'CC') { // Either CC1 or CC3 isDefault = true; } } else if (embeddedTracks.length === 0) { isDefault = (mediaInfo.index === mediaInfos[0].index); } return isDefault; } function getParser(codecType) { let parser; if (codecType.search(Constants.VTT) &gt;= 0) { parser = vttParser; } else if (codecType.search(Constants.TTML) &gt;= 0 || codecType.search(Constants.STPP) &gt;= 0) { parser = ttmlParser; } return parser; } function remove(start, end) { //if start and end are not defined, remove all if ((start === undefined) &amp;&amp; (start === end)) { start = this.buffered.start(0); end = this.buffered.end(this.buffered.length - 1); } this.buffered.remove(start, end); } instance = { initialize: initialize, append: append, abort: abort, addEmbeddedTrack: addEmbeddedTrack, resetEmbedded: resetEmbedded, setConfig: setConfig, getConfig: getConfig, setCurrentFragmentedTrackIdx: setCurrentFragmentedTrackIdx, remove: remove, reset: reset }; setup(); return instance; } TextSourceBuffer.__dashjs_factory_name = 'TextSourceBuffer'; export default FactoryMaker.getSingletonFactory(TextSourceBuffer); × Search results Close "},"streaming_utils_TTMLParser.js.html":{"id":"streaming_utils_TTMLParser.js.html","title":"Source: streaming/utils/TTMLParser.js","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Source: streaming/utils/TTMLParser.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ import FactoryMaker from '../../core/FactoryMaker'; import Debug from '../../core/Debug'; import EventBus from '../../core/EventBus'; import Events from '../../core/events/Events'; import { fromXML, generateISD } from 'imsc'; function TTMLParser() { const context = this.context; const eventBus = EventBus(context).getInstance(); /* * This TTML parser follows &quot;EBU-TT-D SUBTITLING DISTRIBUTION FORMAT - tech3380&quot; spec - https://tech.ebu.ch/docs/tech/tech3380.pdf. * */ let instance, logger; let cueCounter = 0; // Used to give every cue a unique ID. function setup() { logger = Debug(context).getInstance().getLogger(instance); } function getCueID() { const id = 'cue_TTML_' + cueCounter; cueCounter++; return id; } /** * Parse the raw data and process it to return the HTML element representing the cue. * Return the region to be processed and controlled (hide/show) by the caption controller. * @param {string} data - raw data received from the TextSourceBuffer * @param {number} offsetTime - offset time to apply to cue time * @param {integer} startTimeSegment - startTime for the current segment * @param {integer} endTimeSegment - endTime for the current segment * @param {Array} images - images array referenced by subs MP4 box */ function parse(data, offsetTime, startTimeSegment, endTimeSegment, images) { let i; let errorMsg = ''; const captionArray = []; let startTime, endTime; const content = {}; const embeddedImages = {}; let currentImageId = ''; let accumulated_image_data = ''; let metadataHandler = { onOpenTag: function (ns, name, attrs) { if (name === 'image' &amp;&amp; ns === 'http://www.smpte-ra.org/schemas/2052-1/2010/smpte-tt') { if (!attrs[' imagetype'] || attrs[' imagetype'].value !== 'PNG') { logger.warn('smpte-tt imagetype != PNG. Discarded'); return; } currentImageId = attrs['http://www.w3.org/XML/1998/namespace id'].value; } }, onCloseTag: function () { if (currentImageId) { embeddedImages[currentImageId] = accumulated_image_data.trim(); } accumulated_image_data = ''; currentImageId = ''; }, onText: function (contents) { if (currentImageId) { accumulated_image_data = accumulated_image_data + contents; } } }; if (!data) { errorMsg = 'no ttml data to parse'; throw new Error(errorMsg); } content.data = data; eventBus.trigger(Events.TTML_TO_PARSE, content); const imsc1doc = fromXML(content.data, function (msg) { errorMsg = msg; }, metadataHandler); eventBus.trigger(Events.TTML_PARSED, {ttmlString: content.data, ttmlDoc: imsc1doc}); const mediaTimeEvents = imsc1doc.getMediaTimeEvents(); for (i = 0; i &lt; mediaTimeEvents.length; i++) { let isd = generateISD(imsc1doc, mediaTimeEvents[i], function (error) { errorMsg = error; }); if (isd.contents.some(topLevelContents =&gt; topLevelContents.contents.length)) { //be sure that mediaTimeEvents values are in the mp4 segment time ranges. startTime = (mediaTimeEvents[i] + offsetTime) &lt; startTimeSegment ? startTimeSegment : (mediaTimeEvents[i] + offsetTime); endTime = (mediaTimeEvents[i + 1] + offsetTime) &gt; endTimeSegment ? endTimeSegment : (mediaTimeEvents[i + 1] + offsetTime); if (startTime &lt; endTime) { captionArray.push({ start: startTime, end: endTime, type: 'html', cueID: getCueID(), isd: isd, images: images, embeddedImages: embeddedImages }); } } } if (errorMsg !== '') { logger.error(errorMsg); throw new Error(errorMsg); } return captionArray; } instance = { parse: parse }; setup(); return instance; } TTMLParser.__dashjs_factory_name = 'TTMLParser'; export default FactoryMaker.getSingletonFactory(TTMLParser); × Search results Close "},"streaming_protection_servers_Widevine.js.html":{"id":"streaming_protection_servers_Widevine.js.html","title":"Source: streaming/protection/servers/Widevine.js","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Source: streaming/protection/servers/Widevine.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ function Widevine() { let instance; function getServerURLFromMessage(url /*, message, messageType*/) { return url; } function getHTTPMethod(/*messageType*/) { return 'POST'; } function getResponseType(/*keySystemStr, messageType*/) { return 'arraybuffer'; } function getLicenseMessage(serverResponse/*, keySystemStr, messageType*/) { return serverResponse; } function getErrorResponse(serverResponse/*, keySystemStr, messageType*/) { return String.fromCharCode.apply(null, new Uint8Array(serverResponse)); } instance = { getServerURLFromMessage: getServerURLFromMessage, getHTTPMethod: getHTTPMethod, getResponseType: getResponseType, getLicenseMessage: getLicenseMessage, getErrorResponse: getErrorResponse }; return instance; } Widevine.__dashjs_factory_name = 'Widevine'; export default dashjs.FactoryMaker.getSingletonFactory(Widevine); /* jshint ignore:line */ × Search results Close "},"streaming_controllers_XlinkController.js.html":{"id":"streaming_controllers_XlinkController.js.html","title":"Source: streaming/controllers/XlinkController.js","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Source: streaming/controllers/XlinkController.js /** * The copyright in this software is being made available under the BSD License, * included below. This software may be subject to other third party and contributor * rights, including patent rights, and no such rights are granted under this license. * * Copyright (c) 2013, Dash Industry Forum. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation and/or * other materials provided with the distribution. * * Neither the name of Dash Industry Forum nor the names of its * contributors may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */ import XlinkLoader from '../XlinkLoader'; import EventBus from '../../core/EventBus'; import Events from '../../core/events/Events'; import FactoryMaker from '../../core/FactoryMaker'; import X2JS from '../../../externals/xml2json'; import URLUtils from '../utils/URLUtils'; const RESOLVE_TYPE_ONLOAD = 'onLoad'; const RESOLVE_TYPE_ONACTUATE = 'onActuate'; const ELEMENT_TYPE_PERIOD = 'Period'; const ELEMENT_TYPE_ADAPTATIONSET = 'AdaptationSet'; const ELEMENT_TYPE_EVENTSTREAM = 'EventStream'; const RESOLVE_TO_ZERO = 'urn:mpeg:dash:resolve-to-zero:2013'; function XlinkController(config) { config = config || {}; let context = this.context; let eventBus = EventBus(context).getInstance(); const urlUtils = URLUtils(context).getInstance(); let instance, matchers, iron, manifest, converter, xlinkLoader; function setup() { eventBus.on(Events.XLINK_ELEMENT_LOADED, onXlinkElementLoaded, instance); xlinkLoader = XlinkLoader(context).create({ errHandler: config.errHandler, metricsModel: config.metricsModel, mediaPlayerModel: config.mediaPlayerModel, requestModifier: config.requestModifier }); } function setMatchers(value) { if (value) { matchers = value; } } function setIron(value) { if (value) { iron = value; } } /** * &lt;p&gt;Triggers the resolution of the xlink.onLoad attributes in the manifest file &lt;/p&gt; * @param {Object} mpd - the manifest */ function resolveManifestOnLoad(mpd) { let elements; // First resolve all periods, so unnecessary requests inside onLoad Periods with Default content are avoided converter = new X2JS({ escapeMode: false, attributePrefix: '', arrayAccessForm: 'property', emptyNodeForm: 'object', stripWhitespaces: false, enableToStringFunc: false, ignoreRoot: true, matchers: matchers }); manifest = mpd; elements = getElementsToResolve(manifest.Period_asArray, manifest, ELEMENT_TYPE_PERIOD, RESOLVE_TYPE_ONLOAD); resolve(elements, ELEMENT_TYPE_PERIOD, RESOLVE_TYPE_ONLOAD); } function reset() { eventBus.off(Events.XLINK_ELEMENT_LOADED, onXlinkElementLoaded, instance); if (xlinkLoader) { xlinkLoader.reset(); xlinkLoader = null; } } function resolve(elements, type, resolveType) { let resolveObject = {}; let element, url; resolveObject.elements = elements; resolveObject.type = type; resolveObject.resolveType = resolveType; // If nothing to resolve, directly call allElementsLoaded if (resolveObject.elements.length === 0) { onXlinkAllElementsLoaded(resolveObject); } for (let i = 0; i &lt; resolveObject.elements.length; i++) { element = resolveObject.elements[i]; if (urlUtils.isHTTPURL(element.url)) { url = element.url; } else { url = element.originalContent.BaseURL + element.url; } xlinkLoader.load(url, element, resolveObject); } } function onXlinkElementLoaded(event) { let element, resolveObject; const openingTag = '&lt;response&gt;'; const closingTag = '&lt;/response&gt;'; let mergedContent = ''; element = event.element; resolveObject = event.resolveObject; // if the element resolved into content parse the content if (element.resolvedContent) { let index = 0; // we add a parent elements so the converter is able to parse multiple elements of the same type which are not wrapped inside a container if (element.resolvedContent.indexOf('&lt;?xml') === 0) { index = element.resolvedContent.indexOf('?&gt;') + 2; //find the closing position of the xml declaration, if it exists. } mergedContent = element.resolvedContent.substr(0,index) + openingTag + element.resolvedContent.substr(index) + closingTag; element.resolvedContent = converter.xml_str2json(mergedContent); } if (isResolvingFinished(resolveObject)) { onXlinkAllElementsLoaded(resolveObject); } } // We got to wait till all elements of the current queue are resolved before merging back function onXlinkAllElementsLoaded (resolveObject) { let elements = []; let i, obj; mergeElementsBack(resolveObject); if (resolveObject.resolveType === RESOLVE_TYPE_ONACTUATE) { eventBus.trigger(Events.XLINK_READY, {manifest: manifest}); } if (resolveObject.resolveType === RESOLVE_TYPE_ONLOAD) { switch (resolveObject.type) { // Start resolving the other elements. We can do Adaptation Set and EventStream in parallel case ELEMENT_TYPE_PERIOD: for (i = 0; i &lt; manifest[ELEMENT_TYPE_PERIOD + '_asArray'].length; i++) { obj = manifest[ELEMENT_TYPE_PERIOD + '_asArray'][i]; if (obj.hasOwnProperty(ELEMENT_TYPE_ADAPTATIONSET + '_asArray')) { elements = elements.concat(getElementsToResolve(obj[ELEMENT_TYPE_ADAPTATIONSET + '_asArray'], obj, ELEMENT_TYPE_ADAPTATIONSET, RESOLVE_TYPE_ONLOAD)); } if (obj.hasOwnProperty(ELEMENT_TYPE_EVENTSTREAM + '_asArray')) { elements = elements.concat(getElementsToResolve(obj[ELEMENT_TYPE_EVENTSTREAM + '_asArray'], obj, ELEMENT_TYPE_EVENTSTREAM, RESOLVE_TYPE_ONLOAD)); } } resolve(elements, ELEMENT_TYPE_ADAPTATIONSET, RESOLVE_TYPE_ONLOAD); break; case ELEMENT_TYPE_ADAPTATIONSET: // TODO: Resolve SegmentList here eventBus.trigger(Events.XLINK_READY, {manifest: manifest}); break; } } } // Returns the elements with the specific resolve Type function getElementsToResolve(elements, parentElement, type, resolveType) { let toResolve = []; let element, i, xlinkObject; // first remove all the resolve-to-zero elements for (i = elements.length - 1; i &gt;= 0; i--) { element = elements[i]; if (element.hasOwnProperty('xlink:href') &amp;&amp; element['xlink:href'] === RESOLVE_TO_ZERO) { elements.splice(i, 1); } } // now get the elements with the right resolve type for (i = 0; i &lt; elements.length; i++) { element = elements[i]; if (element.hasOwnProperty('xlink:href') &amp;&amp; element.hasOwnProperty('xlink:actuate') &amp;&amp; element['xlink:actuate'] === resolveType) { xlinkObject = createXlinkObject(element['xlink:href'], parentElement, type, i, resolveType, element); toResolve.push(xlinkObject); } } return toResolve; } function mergeElementsBack(resolveObject) { let resolvedElements = []; let element, type, obj, i, j, k; // Start merging back from the end because of index shifting. Note that the elements with the same parent have to be ordered by index ascending for (i = resolveObject.elements.length - 1; i &gt;= 0; i --) { element = resolveObject.elements[i]; type = element.type + '_asArray'; // Element couldn't be resolved or is TODO Inappropriate target: Remove all Xlink attributes if (!element.resolvedContent || isInappropriateTarget()) { delete element.originalContent['xlink:actuate']; delete element.originalContent['xlink:href']; resolvedElements.push(element.originalContent); } // Element was successfully resolved else if (element.resolvedContent) { for (j = 0; j &lt; element.resolvedContent[type].length; j++) { //TODO Contains another Xlink attribute with xlink:actuate set to onload. Remove all xLink attributes obj = element.resolvedContent[type][j]; resolvedElements.push(obj); } } // Replace the old elements in the parent with the resolved ones element.parentElement[type].splice(element.index, 1); for (k = 0; k &lt; resolvedElements.length; k++) { element.parentElement[type].splice(element.index + k, 0, resolvedElements[k]); } resolvedElements = []; } if (resolveObject.elements.length &gt; 0) { iron.run(manifest); } } function createXlinkObject(url, parentElement, type, index, resolveType, originalContent) { return { url: url, parentElement: parentElement, type: type, index: index, resolveType: resolveType, originalContent: originalContent, resolvedContent: null, resolved: false }; } // Check if all pending requests are finished function isResolvingFinished(elementsToResolve) { let i, obj; for (i = 0; i &lt; elementsToResolve.elements.length; i++) { obj = elementsToResolve.elements[i]; if (obj.resolved === false) { return false; } } return true; } // TODO : Do some syntax check here if the target is valid or not function isInappropriateTarget() { return false; } instance = { resolveManifestOnLoad: resolveManifestOnLoad, setMatchers: setMatchers, setIron: setIron, reset: reset }; setup(); return instance; } XlinkController.__dashjs_factory_name = 'XlinkController'; export default FactoryMaker.getClassFactory(XlinkController); × Search results Close "},"global.html":{"id":"global.html","title":"Global","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Global Methods _decimalAdjust(type, value, exp) Decimal adjustment of a number. Parameters: Name Type Description type String The type of adjustment. value Number The number. exp Integer The exponent (the 10 logarithm of the adjustment base). Source: dash/utils/Round10.js, line 62 Returns: The adjusted value. Type Number EBMLParser(config) Creates an instance of an EBMLParser class which implements a large subset of the functionality required to parse Matroska EBML Parameters: Name Type Description config Object object with data member which is the buffer to parse Source: streaming/utils/EBMLParser.js, line 9 GenericMetricHandler() The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license. Copyright (c) 2013, Dash Industry Forum. All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. Neither the name of Dash Industry Forum nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. Source: streaming/metrics/metrics/handlers/GenericMetricHandler.js, line 32 HandlerHelpers() The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license. Copyright (c) 2013, Dash Industry Forum. All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. Neither the name of Dash Industry Forum nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. Source: streaming/metrics/utils/HandlerHelpers.js, line 32 MetricSerialiser() The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license. Copyright (c) 2013, Dash Industry Forum. All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. Neither the name of Dash Industry Forum nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. Source: streaming/metrics/utils/MetricSerialiser.js, line 32 RNG() The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license. Copyright (c) 2013, Dash Industry Forum. All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. Neither the name of Dash Industry Forum nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. Source: streaming/metrics/utils/RNG.js, line 32 round10(value, exp) Decimal round. Parameters: Name Type Description value Number The number. exp Integer The exponent (the 10 logarithm of the adjustment base). Source: dash/utils/Round10.js, line 49 Returns: The adjusted value. Type Number URIFragmentModel() Model class managing URI fragments. Source: streaming/models/URIFragmentModel.js, line 38 Widevine() The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license. Copyright (c) 2013, Dash Industry Forum. All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. Neither the name of Dash Industry Forum nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. Source: streaming/protection/servers/Widevine.js, line 32 × Search results Close "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Modules Classes BaseMatcher BufferLevel BufferState CommonEncryption CommonProperty DroppedFrames DVRInfo HTTPRequest HTTPRequestTrace LiveEdgeFinder ManifestUpdate ManifestUpdateRepresentationInfo ManifestUpdateStreamInfo MediaPlayerEvents PlayList PlayListTrace PlayReady PreBufferSink ProtectionEvents RepresentationSwitch RequestsQueue Round10 SchedulingInfo SourceBufferSink TCPConnection Events BUFFER_EMPTY Triggered when the video element's buffer state changes to stalled. Check mediaType in payload to determine type (Video, Audio, FragmentedText). Source: streaming/MediaPlayerEvents.js, line 50 BUFFER_LEVEL_STATE_CHANGED Triggered when the video element's buffer state changes, either stalled or loaded. Check payload for state. Source: streaming/MediaPlayerEvents.js, line 64 BUFFER_LOADED Triggered when the video element's buffer state changes to loaded. Check mediaType in payload to determine type (Video, Audio, FragmentedText). Source: streaming/MediaPlayerEvents.js, line 57 CAN_PLAY Sent when enough data is available that the media can be played, at least for a couple of frames. This corresponds to the HAVE_ENOUGH_DATA readyState. Source: streaming/MediaPlayerEvents.js, line 209 ERROR Triggered when there is an error from the element or MSE source buffer. Source: streaming/MediaPlayerEvents.js, line 70 FRAGMENT_LOADING_ABANDONED Triggered when a fragment download is abandoned due to detection of slow download base on the ABR abandon rule.. Source: streaming/MediaPlayerEvents.js, line 93 FRAGMENT_LOADING_COMPLETED Triggered when a fragment download has completed. Source: streaming/MediaPlayerEvents.js, line 76 FRAGMENT_LOADING_PROGRESS Triggered when a partial fragment download has completed. Source: streaming/MediaPlayerEvents.js, line 82 FRAGMENT_LOADING_STARTED Triggered when a fragment download has started. Source: streaming/MediaPlayerEvents.js, line 87 LOG Triggered when module:Debug logger methods are called. Deprecated: Yes Source: streaming/MediaPlayerEvents.js, line 99 MANIFEST_LOADED Triggered when the manifest load is complete Source: streaming/MediaPlayerEvents.js, line 107 MANIFEST_VALIDITY_CHANGED Manifest validity changed - As a result of an MPD validity expiration event. Source: streaming/MediaPlayerEvents.js, line 327 METRIC_ADDED Triggered every time a new metric is added. Source: streaming/MediaPlayerEvents.js, line 125 METRIC_CHANGED Triggered when an individual metric is added, updated or cleared. Source: streaming/MediaPlayerEvents.js, line 119 METRIC_UPDATED Triggered every time a metric is updated. Source: streaming/MediaPlayerEvents.js, line 131 METRICS_CHANGED Triggered anytime there is a change to the overall metrics. Source: streaming/MediaPlayerEvents.js, line 113 PERIOD_SWITCH_COMPLETED Triggered at the stream end of a period. Source: streaming/MediaPlayerEvents.js, line 137 PERIOD_SWITCH_STARTED Triggered when a new period starts. Source: streaming/MediaPlayerEvents.js, line 143 PLAYBACK_CATCHUP_END Sent live catch up mechanism has been deactivated. Source: streaming/MediaPlayerEvents.js, line 226 See: setCatchUpPlaybackRate() setLiveDelay() PLAYBACK_CATCHUP_START Sent when live catch mechanism has been activated, which implies the measured latency of the low latency stream that is been played has gone beyond the target one. Source: streaming/MediaPlayerEvents.js, line 217 See: setCatchUpPlaybackRate() setLiveDelay() PLAYBACK_ENDED Sent when playback completes. Source: streaming/MediaPlayerEvents.js, line 234 PLAYBACK_ERROR Sent when an error occurs. The element's error attribute contains more information. Source: streaming/MediaPlayerEvents.js, line 240 PLAYBACK_METADATA_LOADED The media's metadata has finished loading; all attributes now contain as much useful information as they're going to. Source: streaming/MediaPlayerEvents.js, line 253 PLAYBACK_NOT_ALLOWED Sent when playback is not allowed (for example if user gesture is needed). Source: streaming/MediaPlayerEvents.js, line 247 PLAYBACK_PAUSED Sent when playback is paused. Source: streaming/MediaPlayerEvents.js, line 260 PLAYBACK_PLAYING Sent when the media begins to play (either for the first time, after having been paused, or after ending and then restarting). Source: streaming/MediaPlayerEvents.js, line 266 PLAYBACK_PROGRESS Sent periodically to inform interested parties of progress downloading the media. Information about the current amount of the media that has been downloaded is available in the media element's buffered attribute. Source: streaming/MediaPlayerEvents.js, line 274 PLAYBACK_RATE_CHANGED Sent when the playback speed changes. Source: streaming/MediaPlayerEvents.js, line 282 PLAYBACK_SEEK_ASKED Sent when a seek operation has been asked. Source: streaming/MediaPlayerEvents.js, line 300 PLAYBACK_SEEKED Sent when a seek operation completes. Source: streaming/MediaPlayerEvents.js, line 288 PLAYBACK_SEEKING Sent when a seek operation begins. Source: streaming/MediaPlayerEvents.js, line 294 PLAYBACK_STARTED Sent when playback of the media starts after having been paused; that is, when playback is resumed after a prior pause event. Source: streaming/MediaPlayerEvents.js, line 306 PLAYBACK_TIME_UPDATED The time indicated by the element's currentTime attribute has changed. Source: streaming/MediaPlayerEvents.js, line 314 PLAYBACK_WAITING Sent when the media playback has stopped because of a temporary lack of data. Source: streaming/MediaPlayerEvents.js, line 320 QUALITY_CHANGE_RENDERED Triggered when the new ABR quality is being rendered on-screen. Source: streaming/MediaPlayerEvents.js, line 155 QUALITY_CHANGE_REQUESTED Triggered when an ABR up /down switch is initiated; either by user in manual mode or auto mode via ABR rules. Source: streaming/MediaPlayerEvents.js, line 149 SOURCE_INITIALIZED Triggered when the source is setup and ready. Source: streaming/MediaPlayerEvents.js, line 167 STREAM_INITIALIZED Triggered when a stream (period) is loaded Source: streaming/MediaPlayerEvents.js, line 173 STREAM_TEARDOWN_COMPLETE Triggered when the player has been reset. Source: streaming/MediaPlayerEvents.js, line 179 TEXT_TRACK_ADDED Triggered when a text track is added to the video element's TextTrackList Source: streaming/MediaPlayerEvents.js, line 191 TEXT_TRACKS_ADDED Triggered once all text tracks detected in the MPD are added to the video element. Source: streaming/MediaPlayerEvents.js, line 185 TRACK_CHANGE_RENDERED Triggered when the new track is being rendered. Source: streaming/MediaPlayerEvents.js, line 161 TTML_PARSED Triggered when a ttml chunk has to be parsed. Source: streaming/MediaPlayerEvents.js, line 203 TTML_PARSED Triggered when a ttml chunk is parsed. Source: streaming/MediaPlayerEvents.js, line 197 KEY_ADDED Event ID for events delivered when a new key has been added Deprecated: The latest versions of the EME specification no longer use this event. {@MediaPlayer.models.protectionModel.eventList.KEY_STATUSES_CHANGED} is preferred. Source: streaming/protection/ProtectionEvents.js, line 66 KEY_ERROR Event ID for events delivered when an error is encountered by the CDM while processing a license server response message Source: streaming/protection/ProtectionEvents.js, line 76 KEY_MESSAGE Event ID for events delivered when the protection set receives a key message from the CDM Source: streaming/protection/ProtectionEvents.js, line 83 KEY_SESSION_CLOSED Event ID for events delivered when a key session close process has completed Source: streaming/protection/ProtectionEvents.js, line 90 KEY_SESSION_CREATED Event ID for events delivered when a new key sessions creation process has completed Source: streaming/protection/ProtectionEvents.js, line 97 KEY_SESSION_REMOVED Event ID for events delivered when a key session removal process has completed Source: streaming/protection/ProtectionEvents.js, line 104 KEY_STATUSES_CHANGED Event ID for events delivered when the status of one or more decryption keys has changed Source: streaming/protection/ProtectionEvents.js, line 111 KEY_SYSTEM_SELECTED Event ID for events delivered when a key system selection procedure completes Source: streaming/protection/ProtectionEvents.js, line 125 LICENSE_REQUEST_COMPLETE Event ID for events delivered when a license request procedure has completed Source: streaming/protection/ProtectionEvents.js, line 132 PROTECTION_CREATED Event ID for events delivered when the Protection system is detected and created. Source: streaming/protection/ProtectionEvents.js, line 145 PROTECTION_DESTROYED Event ID for events delivered when the Protection system is destroyed. Source: streaming/protection/ProtectionEvents.js, line 151 × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Classes Classes BaseMatcher BufferLevel BufferState CommonEncryption CommonProperty DroppedFrames DVRInfo HTTPRequest HTTPRequestTrace LiveEdgeFinder ManifestUpdate ManifestUpdateRepresentationInfo ManifestUpdateStreamInfo MediaPlayerEvents PlayList PlayListTrace PlayReady PreBufferSink ProtectionEvents RepresentationSwitch RequestsQueue Round10 SchedulingInfo SourceBufferSink TCPConnection Events BUFFER_EMPTY Triggered when the video element's buffer state changes to stalled. Check mediaType in payload to determine type (Video, Audio, FragmentedText). Source: streaming/MediaPlayerEvents.js, line 50 BUFFER_LEVEL_STATE_CHANGED Triggered when the video element's buffer state changes, either stalled or loaded. Check payload for state. Source: streaming/MediaPlayerEvents.js, line 64 BUFFER_LOADED Triggered when the video element's buffer state changes to loaded. Check mediaType in payload to determine type (Video, Audio, FragmentedText). Source: streaming/MediaPlayerEvents.js, line 57 CAN_PLAY Sent when enough data is available that the media can be played, at least for a couple of frames. This corresponds to the HAVE_ENOUGH_DATA readyState. Source: streaming/MediaPlayerEvents.js, line 209 ERROR Triggered when there is an error from the element or MSE source buffer. Source: streaming/MediaPlayerEvents.js, line 70 FRAGMENT_LOADING_ABANDONED Triggered when a fragment download is abandoned due to detection of slow download base on the ABR abandon rule.. Source: streaming/MediaPlayerEvents.js, line 93 FRAGMENT_LOADING_COMPLETED Triggered when a fragment download has completed. Source: streaming/MediaPlayerEvents.js, line 76 FRAGMENT_LOADING_PROGRESS Triggered when a partial fragment download has completed. Source: streaming/MediaPlayerEvents.js, line 82 FRAGMENT_LOADING_STARTED Triggered when a fragment download has started. Source: streaming/MediaPlayerEvents.js, line 87 LOG Triggered when module:Debug logger methods are called. Deprecated: Yes Source: streaming/MediaPlayerEvents.js, line 99 MANIFEST_LOADED Triggered when the manifest load is complete Source: streaming/MediaPlayerEvents.js, line 107 MANIFEST_VALIDITY_CHANGED Manifest validity changed - As a result of an MPD validity expiration event. Source: streaming/MediaPlayerEvents.js, line 327 METRIC_ADDED Triggered every time a new metric is added. Source: streaming/MediaPlayerEvents.js, line 125 METRIC_CHANGED Triggered when an individual metric is added, updated or cleared. Source: streaming/MediaPlayerEvents.js, line 119 METRIC_UPDATED Triggered every time a metric is updated. Source: streaming/MediaPlayerEvents.js, line 131 METRICS_CHANGED Triggered anytime there is a change to the overall metrics. Source: streaming/MediaPlayerEvents.js, line 113 PERIOD_SWITCH_COMPLETED Triggered at the stream end of a period. Source: streaming/MediaPlayerEvents.js, line 137 PERIOD_SWITCH_STARTED Triggered when a new period starts. Source: streaming/MediaPlayerEvents.js, line 143 PLAYBACK_CATCHUP_END Sent live catch up mechanism has been deactivated. Source: streaming/MediaPlayerEvents.js, line 226 See: setCatchUpPlaybackRate() setLiveDelay() PLAYBACK_CATCHUP_START Sent when live catch mechanism has been activated, which implies the measured latency of the low latency stream that is been played has gone beyond the target one. Source: streaming/MediaPlayerEvents.js, line 217 See: setCatchUpPlaybackRate() setLiveDelay() PLAYBACK_ENDED Sent when playback completes. Source: streaming/MediaPlayerEvents.js, line 234 PLAYBACK_ERROR Sent when an error occurs. The element's error attribute contains more information. Source: streaming/MediaPlayerEvents.js, line 240 PLAYBACK_METADATA_LOADED The media's metadata has finished loading; all attributes now contain as much useful information as they're going to. Source: streaming/MediaPlayerEvents.js, line 253 PLAYBACK_NOT_ALLOWED Sent when playback is not allowed (for example if user gesture is needed). Source: streaming/MediaPlayerEvents.js, line 247 PLAYBACK_PAUSED Sent when playback is paused. Source: streaming/MediaPlayerEvents.js, line 260 PLAYBACK_PLAYING Sent when the media begins to play (either for the first time, after having been paused, or after ending and then restarting). Source: streaming/MediaPlayerEvents.js, line 266 PLAYBACK_PROGRESS Sent periodically to inform interested parties of progress downloading the media. Information about the current amount of the media that has been downloaded is available in the media element's buffered attribute. Source: streaming/MediaPlayerEvents.js, line 274 PLAYBACK_RATE_CHANGED Sent when the playback speed changes. Source: streaming/MediaPlayerEvents.js, line 282 PLAYBACK_SEEK_ASKED Sent when a seek operation has been asked. Source: streaming/MediaPlayerEvents.js, line 300 PLAYBACK_SEEKED Sent when a seek operation completes. Source: streaming/MediaPlayerEvents.js, line 288 PLAYBACK_SEEKING Sent when a seek operation begins. Source: streaming/MediaPlayerEvents.js, line 294 PLAYBACK_STARTED Sent when playback of the media starts after having been paused; that is, when playback is resumed after a prior pause event. Source: streaming/MediaPlayerEvents.js, line 306 PLAYBACK_TIME_UPDATED The time indicated by the element's currentTime attribute has changed. Source: streaming/MediaPlayerEvents.js, line 314 PLAYBACK_WAITING Sent when the media playback has stopped because of a temporary lack of data. Source: streaming/MediaPlayerEvents.js, line 320 QUALITY_CHANGE_RENDERED Triggered when the new ABR quality is being rendered on-screen. Source: streaming/MediaPlayerEvents.js, line 155 QUALITY_CHANGE_REQUESTED Triggered when an ABR up /down switch is initiated; either by user in manual mode or auto mode via ABR rules. Source: streaming/MediaPlayerEvents.js, line 149 SOURCE_INITIALIZED Triggered when the source is setup and ready. Source: streaming/MediaPlayerEvents.js, line 167 STREAM_INITIALIZED Triggered when a stream (period) is loaded Source: streaming/MediaPlayerEvents.js, line 173 STREAM_TEARDOWN_COMPLETE Triggered when the player has been reset. Source: streaming/MediaPlayerEvents.js, line 179 TEXT_TRACK_ADDED Triggered when a text track is added to the video element's TextTrackList Source: streaming/MediaPlayerEvents.js, line 191 TEXT_TRACKS_ADDED Triggered once all text tracks detected in the MPD are added to the video element. Source: streaming/MediaPlayerEvents.js, line 185 TRACK_CHANGE_RENDERED Triggered when the new track is being rendered. Source: streaming/MediaPlayerEvents.js, line 161 TTML_PARSED Triggered when a ttml chunk has to be parsed. Source: streaming/MediaPlayerEvents.js, line 203 TTML_PARSED Triggered when a ttml chunk is parsed. Source: streaming/MediaPlayerEvents.js, line 197 KEY_ADDED Event ID for events delivered when a new key has been added Deprecated: The latest versions of the EME specification no longer use this event. {@MediaPlayer.models.protectionModel.eventList.KEY_STATUSES_CHANGED} is preferred. Source: streaming/protection/ProtectionEvents.js, line 66 KEY_ERROR Event ID for events delivered when an error is encountered by the CDM while processing a license server response message Source: streaming/protection/ProtectionEvents.js, line 76 KEY_MESSAGE Event ID for events delivered when the protection set receives a key message from the CDM Source: streaming/protection/ProtectionEvents.js, line 83 KEY_SESSION_CLOSED Event ID for events delivered when a key session close process has completed Source: streaming/protection/ProtectionEvents.js, line 90 KEY_SESSION_CREATED Event ID for events delivered when a new key sessions creation process has completed Source: streaming/protection/ProtectionEvents.js, line 97 KEY_SESSION_REMOVED Event ID for events delivered when a key session removal process has completed Source: streaming/protection/ProtectionEvents.js, line 104 KEY_STATUSES_CHANGED Event ID for events delivered when the status of one or more decryption keys has changed Source: streaming/protection/ProtectionEvents.js, line 111 KEY_SYSTEM_SELECTED Event ID for events delivered when a key system selection procedure completes Source: streaming/protection/ProtectionEvents.js, line 125 LICENSE_REQUEST_COMPLETE Event ID for events delivered when a license request procedure has completed Source: streaming/protection/ProtectionEvents.js, line 132 PROTECTION_CREATED Event ID for events delivered when the Protection system is detected and created. Source: streaming/protection/ProtectionEvents.js, line 145 PROTECTION_DESTROYED Event ID for events delivered when the Protection system is destroyed. Source: streaming/protection/ProtectionEvents.js, line 151 × Search results Close "},"interfaces.list.html":{"id":"interfaces.list.html","title":"Interfaces","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Interfaces Classes BaseMatcher BufferLevel BufferState CommonEncryption CommonProperty DroppedFrames DVRInfo HTTPRequest HTTPRequestTrace LiveEdgeFinder ManifestUpdate ManifestUpdateRepresentationInfo ManifestUpdateStreamInfo MediaPlayerEvents PlayList PlayListTrace PlayReady PreBufferSink ProtectionEvents RepresentationSwitch RequestsQueue Round10 SchedulingInfo SourceBufferSink TCPConnection Events BUFFER_EMPTY Triggered when the video element's buffer state changes to stalled. Check mediaType in payload to determine type (Video, Audio, FragmentedText). Source: streaming/MediaPlayerEvents.js, line 50 BUFFER_LEVEL_STATE_CHANGED Triggered when the video element's buffer state changes, either stalled or loaded. Check payload for state. Source: streaming/MediaPlayerEvents.js, line 64 BUFFER_LOADED Triggered when the video element's buffer state changes to loaded. Check mediaType in payload to determine type (Video, Audio, FragmentedText). Source: streaming/MediaPlayerEvents.js, line 57 CAN_PLAY Sent when enough data is available that the media can be played, at least for a couple of frames. This corresponds to the HAVE_ENOUGH_DATA readyState. Source: streaming/MediaPlayerEvents.js, line 209 ERROR Triggered when there is an error from the element or MSE source buffer. Source: streaming/MediaPlayerEvents.js, line 70 FRAGMENT_LOADING_ABANDONED Triggered when a fragment download is abandoned due to detection of slow download base on the ABR abandon rule.. Source: streaming/MediaPlayerEvents.js, line 93 FRAGMENT_LOADING_COMPLETED Triggered when a fragment download has completed. Source: streaming/MediaPlayerEvents.js, line 76 FRAGMENT_LOADING_PROGRESS Triggered when a partial fragment download has completed. Source: streaming/MediaPlayerEvents.js, line 82 FRAGMENT_LOADING_STARTED Triggered when a fragment download has started. Source: streaming/MediaPlayerEvents.js, line 87 LOG Triggered when module:Debug logger methods are called. Deprecated: Yes Source: streaming/MediaPlayerEvents.js, line 99 MANIFEST_LOADED Triggered when the manifest load is complete Source: streaming/MediaPlayerEvents.js, line 107 MANIFEST_VALIDITY_CHANGED Manifest validity changed - As a result of an MPD validity expiration event. Source: streaming/MediaPlayerEvents.js, line 327 METRIC_ADDED Triggered every time a new metric is added. Source: streaming/MediaPlayerEvents.js, line 125 METRIC_CHANGED Triggered when an individual metric is added, updated or cleared. Source: streaming/MediaPlayerEvents.js, line 119 METRIC_UPDATED Triggered every time a metric is updated. Source: streaming/MediaPlayerEvents.js, line 131 METRICS_CHANGED Triggered anytime there is a change to the overall metrics. Source: streaming/MediaPlayerEvents.js, line 113 PERIOD_SWITCH_COMPLETED Triggered at the stream end of a period. Source: streaming/MediaPlayerEvents.js, line 137 PERIOD_SWITCH_STARTED Triggered when a new period starts. Source: streaming/MediaPlayerEvents.js, line 143 PLAYBACK_CATCHUP_END Sent live catch up mechanism has been deactivated. Source: streaming/MediaPlayerEvents.js, line 226 See: setCatchUpPlaybackRate() setLiveDelay() PLAYBACK_CATCHUP_START Sent when live catch mechanism has been activated, which implies the measured latency of the low latency stream that is been played has gone beyond the target one. Source: streaming/MediaPlayerEvents.js, line 217 See: setCatchUpPlaybackRate() setLiveDelay() PLAYBACK_ENDED Sent when playback completes. Source: streaming/MediaPlayerEvents.js, line 234 PLAYBACK_ERROR Sent when an error occurs. The element's error attribute contains more information. Source: streaming/MediaPlayerEvents.js, line 240 PLAYBACK_METADATA_LOADED The media's metadata has finished loading; all attributes now contain as much useful information as they're going to. Source: streaming/MediaPlayerEvents.js, line 253 PLAYBACK_NOT_ALLOWED Sent when playback is not allowed (for example if user gesture is needed). Source: streaming/MediaPlayerEvents.js, line 247 PLAYBACK_PAUSED Sent when playback is paused. Source: streaming/MediaPlayerEvents.js, line 260 PLAYBACK_PLAYING Sent when the media begins to play (either for the first time, after having been paused, or after ending and then restarting). Source: streaming/MediaPlayerEvents.js, line 266 PLAYBACK_PROGRESS Sent periodically to inform interested parties of progress downloading the media. Information about the current amount of the media that has been downloaded is available in the media element's buffered attribute. Source: streaming/MediaPlayerEvents.js, line 274 PLAYBACK_RATE_CHANGED Sent when the playback speed changes. Source: streaming/MediaPlayerEvents.js, line 282 PLAYBACK_SEEK_ASKED Sent when a seek operation has been asked. Source: streaming/MediaPlayerEvents.js, line 300 PLAYBACK_SEEKED Sent when a seek operation completes. Source: streaming/MediaPlayerEvents.js, line 288 PLAYBACK_SEEKING Sent when a seek operation begins. Source: streaming/MediaPlayerEvents.js, line 294 PLAYBACK_STARTED Sent when playback of the media starts after having been paused; that is, when playback is resumed after a prior pause event. Source: streaming/MediaPlayerEvents.js, line 306 PLAYBACK_TIME_UPDATED The time indicated by the element's currentTime attribute has changed. Source: streaming/MediaPlayerEvents.js, line 314 PLAYBACK_WAITING Sent when the media playback has stopped because of a temporary lack of data. Source: streaming/MediaPlayerEvents.js, line 320 QUALITY_CHANGE_RENDERED Triggered when the new ABR quality is being rendered on-screen. Source: streaming/MediaPlayerEvents.js, line 155 QUALITY_CHANGE_REQUESTED Triggered when an ABR up /down switch is initiated; either by user in manual mode or auto mode via ABR rules. Source: streaming/MediaPlayerEvents.js, line 149 SOURCE_INITIALIZED Triggered when the source is setup and ready. Source: streaming/MediaPlayerEvents.js, line 167 STREAM_INITIALIZED Triggered when a stream (period) is loaded Source: streaming/MediaPlayerEvents.js, line 173 STREAM_TEARDOWN_COMPLETE Triggered when the player has been reset. Source: streaming/MediaPlayerEvents.js, line 179 TEXT_TRACK_ADDED Triggered when a text track is added to the video element's TextTrackList Source: streaming/MediaPlayerEvents.js, line 191 TEXT_TRACKS_ADDED Triggered once all text tracks detected in the MPD are added to the video element. Source: streaming/MediaPlayerEvents.js, line 185 TRACK_CHANGE_RENDERED Triggered when the new track is being rendered. Source: streaming/MediaPlayerEvents.js, line 161 TTML_PARSED Triggered when a ttml chunk has to be parsed. Source: streaming/MediaPlayerEvents.js, line 203 TTML_PARSED Triggered when a ttml chunk is parsed. Source: streaming/MediaPlayerEvents.js, line 197 KEY_ADDED Event ID for events delivered when a new key has been added Deprecated: The latest versions of the EME specification no longer use this event. {@MediaPlayer.models.protectionModel.eventList.KEY_STATUSES_CHANGED} is preferred. Source: streaming/protection/ProtectionEvents.js, line 66 KEY_ERROR Event ID for events delivered when an error is encountered by the CDM while processing a license server response message Source: streaming/protection/ProtectionEvents.js, line 76 KEY_MESSAGE Event ID for events delivered when the protection set receives a key message from the CDM Source: streaming/protection/ProtectionEvents.js, line 83 KEY_SESSION_CLOSED Event ID for events delivered when a key session close process has completed Source: streaming/protection/ProtectionEvents.js, line 90 KEY_SESSION_CREATED Event ID for events delivered when a new key sessions creation process has completed Source: streaming/protection/ProtectionEvents.js, line 97 KEY_SESSION_REMOVED Event ID for events delivered when a key session removal process has completed Source: streaming/protection/ProtectionEvents.js, line 104 KEY_STATUSES_CHANGED Event ID for events delivered when the status of one or more decryption keys has changed Source: streaming/protection/ProtectionEvents.js, line 111 KEY_SYSTEM_SELECTED Event ID for events delivered when a key system selection procedure completes Source: streaming/protection/ProtectionEvents.js, line 125 LICENSE_REQUEST_COMPLETE Event ID for events delivered when a license request procedure has completed Source: streaming/protection/ProtectionEvents.js, line 132 PROTECTION_CREATED Event ID for events delivered when the Protection system is detected and created. Source: streaming/protection/ProtectionEvents.js, line 145 PROTECTION_DESTROYED Event ID for events delivered when the Protection system is destroyed. Source: streaming/protection/ProtectionEvents.js, line 151 × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Travis CI Status: Join the discussion: OverviewA reference client implementation for the playback of MPEG DASH via JavaScript and compliant browsers. Learn more about DASH IF Reference Client on our wiki. If your intent is to use the player code without contributing back to this project, then use the MASTER branch which holds the approved and stable public releases. If your goal is to improve or extend the code and contribute back to this project, then you should make your changes in, and submit a pull request against, the DEVELOPMENT branch. Read our CONTRIBUTION.md file for a walk-through of the contribution process. All new work should be in the development branch. Master is now reserved for tagged builds. DocumentationBefore you get started, please read the Dash.js v2.0 Migration Document found here Full API Documentation is available describing all public methods, interfaces, properties, and events. For help, join our Slack channel, our email list and read our wiki. Reference playersThe released pre-built reference players are publicly accessible if you want direct access without writing any Javascript. The nightly build of the /dev branch reference player, is pre-release but contains the latest fixes. It is a good place to start if you are debugging playback problems. A nightly build of the latest minified files are also available: dash.all.min.js and its debug version dash.all.debug.js. All these reference builds and minified files are available under both http and https. Quick Start for UsersIf you just want a DASH player to use and don't need to see the code or commit to this project, then follow the instructions below. If you are a developer and want to work with this code base, then skip down to the &quot;Quick Start for Developers&quot; section. Put the following code in your web page &lt;script src=&quot;https://cdn.dashjs.org/latest/dash.all.min.js&quot;&gt;&lt;/script&gt; ... &lt;style&gt; video { width: 640px; height: 360px; } &lt;/style&gt; ... &lt;body&gt; &lt;div&gt; &lt;video data-dashjs-player autoplay src=&quot;https://dash.akamaized.net/envivio/EnvivioDash3/manifest.mpd&quot; controls&gt;&lt;/video&gt; &lt;/div&gt; &lt;/body&gt;Then place your page under a web server (do not try to run from the file system) and load it via http in a MSE-enabled browser. The video will start automatically. Switch out the manifest URL to your own manifest once you have everything working. If you prefer to use the latest code from this project (versus the last tagged release) then see the &quot;Quick Start for Developers&quot; section below. View the /samples folder for many other examples of embedding and using the player. If you are interested in captioning support, which requires some additional UI elements, then please view the captioning examples. Quick Start for Developers Install Core Dependencies install nodejs install grunt npm install -g grunt-cli Checkout project repository (default branch: development) git clone https://github.com/Dash-Industry-Forum/dash.js.git Install dependencies npm install Build, watch file changes and launch samples page, which has links that point to reference player and to other examples (basic examples, captioning, ads, live, etc). grunt dev Other Grunt Tasks to Build / Run Tests on Commandline. Individual tasks: Quickest build grunt debug Lint grunt lint Run unit tests grunt test Build distribution files (minification included) grunt dist Build distribution files, lint, run unit tests and generate documentation grunt release GruntFile.js default task (equivalent to grunt dist &amp;&amp; grunt test) grunt Getting StartedThe standard setup method uses javascript to initialize and provide video details to dash.js. MediaPlayerFactory provides an alternative declarative setup syntax. Standard SetupCreate a video element somewhere in your html. For our purposes, make sure the controls attribute is present. &lt;video id=&quot;videoPlayer&quot; controls&gt;&lt;/video&gt;Add dash.all.min.js to the end of the body. &lt;body&gt; ... &lt;script src=&quot;yourPathToDash/dash.all.min.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;Now comes the good stuff. We need to create a MediaPlayer and initialize it. var url = &quot;https://dash.akamaized.net/envivio/EnvivioDash3/manifest.mpd&quot;; var player = dashjs.MediaPlayer().create(); player.initialize(document.querySelector(&quot;#videoPlayer&quot;), url, true); When it is all done, it should look similar to this: &lt;!doctype html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Dash.js Rocks&lt;/title&gt; &lt;style&gt; video { width: 640px; height: 360px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;video id=&quot;videoPlayer&quot; controls&gt;&lt;/video&gt; &lt;/div&gt; &lt;script src=&quot;yourPathToDash/dash.all.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; (function(){ var url = &quot;https://dash.akamaized.net/envivio/EnvivioDash3/manifest.mpd&quot;; var player = dashjs.MediaPlayer().create(); player.initialize(document.querySelector(&quot;#videoPlayer&quot;), url, true); })(); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;Module SetupWe publish dash.js to npm. Examples of how to use dash.js in different module bundlers can be found in the samples/modules directory. MediaPlayerFactory SetupAn alternative way to build a Dash.js player in your web page is to use the MediaPlayerFactory. The MediaPlayerFactory will automatically instantiate and initialize the MediaPlayer module on appropriately tagged video elements. Create a video element somewhere in your html and provide the path to your mpd file as src. Also ensure that your video element has the data-dashjs-player attribute on it. &lt;video data-dashjs-player autoplay src=&quot;https://dash.akamaized.net/envivio/EnvivioDash3/manifest.mpd&quot; controls&gt; &lt;/video&gt; Add dash.all.min.js to the end of the body. &lt;body&gt; ... &lt;script src=&quot;yourPathToDash/dash.all.min.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;When it is all done, it should look similar to this: &lt;!doctype html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Dash.js Rocks&lt;/title&gt; &lt;style&gt; video { width: 640px; height: 360px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;video data-dashjs-player autoplay src=&quot;https://dash.akamaized.net/envivio/EnvivioDash3/manifest.mpd&quot; controls&gt; &lt;/video&gt; &lt;/div&gt; &lt;script src=&quot;yourPathToDash/dash.all.min.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt;Tested With × Search results Close "},"BaseMatcher.html":{"id":"BaseMatcher.html","title":"Class: BaseMatcher","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Class: BaseMatcher BaseMatcher a base type for matching and converting types in manifest to something more useful new BaseMatcher() Source: dash/parser/matchers/BaseMatcher.js, line 36 × Search results Close "},"BufferLevel.html":{"id":"BufferLevel.html","title":"Class: BufferLevel","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Class: BufferLevel BufferLevel new BufferLevel() This Object holds reference to the current buffer level and the time it was recorded. Source: streaming/vo/metrics/BufferLevel.js, line 35 Members level Level of the buffer in milliseconds. Indicates the playout duration for which media data of all active media components is available starting from the current playout time. Source: streaming/vo/metrics/BufferLevel.js, line 51 t Real-Time | Time of the measurement of the buffer level. Source: streaming/vo/metrics/BufferLevel.js, line 44 × Search results Close "},"BufferState.html":{"id":"BufferState.html","title":"Class: BufferState","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Class: BufferState BufferState new BufferState() This Object holds reference to the current buffer state of the video element. Source: streaming/vo/metrics/BufferState.js, line 35 Members state Current buffer state. Will be BufferController.BUFFER_EMPTY or BufferController.BUFFER_LOADED. Source: streaming/vo/metrics/BufferState.js, line 49 target The Buffer Level Target determined by the BufferLevelRule. Source: streaming/vo/metrics/BufferState.js, line 44 × Search results Close "},"CommonEncryption.html":{"id":"CommonEncryption.html","title":"Class: CommonEncryption","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Class: CommonEncryption CommonEncryption The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license. Copyright (c) 2013, Dash Industry Forum. All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. Neither the name of Dash Industry Forum nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. new CommonEncryption() Source: streaming/protection/CommonEncryption.js, line 32 Methods &lt;static&gt; findCencContentProtection(cpArray) Find and return the ContentProtection element in the given array that indicates support for MPEG Common Encryption Parameters: Name Type Description cpArray Array array of content protection elements Source: streaming/protection/CommonEncryption.js, line 41 Returns: the Common Encryption content protection element or null if one was not found Type Object | null &lt;static&gt; getPSSHData(pssh) Returns just the data portion of a single PSSH Parameters: Name Type Description pssh ArrayBuffer the PSSH Source: streaming/protection/CommonEncryption.js, line 58 Returns: data portion of the PSSH Type ArrayBuffer &lt;static&gt; getPSSHForKeySystem(keySystem, initData) Returns the PSSH associated with the given key system from the concatenated list of PSSH boxes in the given initData Parameters: Name Type Description keySystem KeySystem the desired key system initData ArrayBuffer 'cenc' initialization data. Concatenated list of PSSH. Source: streaming/protection/CommonEncryption.js, line 85 Returns: The PSSH box data corresponding to the given key system, null if not found or null if a valid association could not be found. Type ArrayBuffer | null &lt;static&gt; parseInitDataFromContentProtection(cpData, BASE64) Parse a standard common encryption PSSH which contains a simple base64-encoding of the init data Parameters: Name Type Description cpData Object the ContentProtection element BASE64 BASE64 reference Source: streaming/protection/CommonEncryption.js, line 101 Returns: the init data or null if not found Type ArrayBuffer | null &lt;static&gt; parsePSSHList(data) Parses list of PSSH boxes into keysystem-specific PSSH data Parameters: Name Type Description data ArrayBuffer the concatenated list of PSSH boxes as provided by CDM as initialization data when CommonEncryption content is detected Source: streaming/protection/CommonEncryption.js, line 117 Returns: an object that has a property named according to each of the detected key system UUIDs (e.g. 00000000-0000-0000-0000-0000000000) and a ArrayBuffer (the entire PSSH box) as the property value Type Object | Array × Search results Close "},"CommonProperty.html":{"id":"CommonProperty.html","title":"Class: CommonProperty","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Class: CommonProperty CommonProperty a property belonging to a MapNode new CommonProperty() Source: dash/parser/maps/CommonProperty.js, line 35 × Search results Close "},"DroppedFrames.html":{"id":"DroppedFrames.html","title":"Class: DroppedFrames","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Class: DroppedFrames DroppedFrames new DroppedFrames() This Object holds reference to DroppedFrames count and the time it was recorded. Source: streaming/vo/metrics/DroppedFrames.js, line 34 Members droppedFrames Number of dropped frames Source: streaming/vo/metrics/DroppedFrames.js, line 49 time Real-Time | Time of the measurement of the dropped frames. Source: streaming/vo/metrics/DroppedFrames.js, line 44 × Search results Close "},"DVRInfo.html":{"id":"DVRInfo.html","title":"Class: DVRInfo","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Class: DVRInfo DVRInfo new DVRInfo() This Object holds reference to DVR availability window information. Source: streaming/vo/metrics/DVRInfo.js, line 34 Members manifestInfo Reference to the internal ManifestInfo.js VO. Source: streaming/vo/metrics/DVRInfo.js, line 55 range The current Segment Availability Range as an object with start and end properties. It's delta defined by the timeShiftBufferDepth MPD attribute. Source: streaming/vo/metrics/DVRInfo.js, line 50 time The current time of the video element when this was created. Source: streaming/vo/metrics/DVRInfo.js, line 44 × Search results Close "},"FragmentSink.html":{"id":"FragmentSink.html","title":"Interface: FragmentSink","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Interface: FragmentSink FragmentSink The an end place to put fragments after they have been fetched. Source: streaming/FragmentSink.js, line 32 Methods abort() Abort an append operation currently ongoing. Source: streaming/FragmentSink.js, line 47 append(chunk) Append a chunk to the internal buffer. You should assume that the effects of this are asynchronous. Parameters: Name Type Description chunk Object A loaded chunk like that generated by the FragmentController Source: streaming/FragmentSink.js, line 36 getAllBufferRanges() Source: streaming/FragmentSink.js, line 51 Returns: A TimeRanges-like object representing all the buffer ranges that are present in the sink. Type Array remove(start, end) Remove data from within the specified time ranges. Parameters: Name Type Argument Description start Number &lt;nullable&gt; The beginning of the range that should be removed from the sink's internal buffer. If NaN, it is regarded as unbounded. end Number &lt;nullable&gt; The end of the range that should be removed from the sink's internal buffer. If NaN, it is regarded as unbounded. Source: streaming/FragmentSink.js, line 41 reset() Remove all the data in the sink's internal buffer. Source: streaming/FragmentSink.js, line 55 × Search results Close "},"HTTPRequest.html":{"id":"HTTPRequest.html","title":"Class: HTTPRequest","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Class: HTTPRequest HTTPRequest This Object holds reference to the HTTPRequest for manifest, fragment and xlink loading. Members which are not defined in ISO23009-1 Annex D should be prefixed by a _ so that they are ignored by Metrics Reporting code. new HTTPRequest() Source: streaming/vo/metrics/HTTPRequest.js, line 36 Members _mediaduration The duration of the media requests, if available, in milliseconds. Source: streaming/vo/metrics/HTTPRequest.js, line 114 _responseHeaders all the response headers from request. Source: streaming/vo/metrics/HTTPRequest.js, line 119 _serviceLocation The selected service location for the request. string. Source: streaming/vo/metrics/HTTPRequest.js, line 124 _stream Type of stream (&quot;audio&quot; | &quot;video&quot; etc..) Source: streaming/vo/metrics/HTTPRequest.js, line 104 _tfinish Real-Time | The real time at which the request finished. Source: streaming/vo/metrics/HTTPRequest.js, line 109 actualurl The actual URL requested, if different from above Source: streaming/vo/metrics/HTTPRequest.js, line 68 interval The duration of the throughput trace intervals (ms), for successful requests only. Source: streaming/vo/metrics/HTTPRequest.js, line 93 range The contents of the byte-range-spec part of the HTTP Range header. Source: streaming/vo/metrics/HTTPRequest.js, line 73 responsecode The HTTP response code. Source: streaming/vo/metrics/HTTPRequest.js, line 88 tcpid Identifier of the TCP connection on which the HTTP request was sent. Source: streaming/vo/metrics/HTTPRequest.js, line 45 trace Throughput traces, for successful requests only. Source: streaming/vo/metrics/HTTPRequest.js, line 98 trequest Real-Time | The real time at which the request was sent. Source: streaming/vo/metrics/HTTPRequest.js, line 78 tresponse Real-Time | The real time at which the first byte of the response was received. Source: streaming/vo/metrics/HTTPRequest.js, line 83 type This is an optional parameter and should not be included in HTTP request/response transactions for progressive download. The type of the request: MPD XLink expansion Initialization Fragment Index Fragment Media Fragment Bitstream Switching Fragment other Source: streaming/vo/metrics/HTTPRequest.js, line 58 url The original URL (before any redirects or failures) Source: streaming/vo/metrics/HTTPRequest.js, line 63 × Search results Close "},"HTTPRequestTrace.html":{"id":"HTTPRequestTrace.html","title":"Class: HTTPRequestTrace","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Class: HTTPRequestTrace HTTPRequestTrace This Object holds reference to the progress of the HTTPRequest. new HTTPRequestTrace() Source: streaming/vo/metrics/HTTPRequest.js, line 131 Members b List of integers counting the bytes received in each trace interval within the measurement stream. Source: streaming/vo/metrics/HTTPRequest.js, line 150 d Measurement stream duration (ms). Source: streaming/vo/metrics/HTTPRequest.js, line 145 s Real-Time | Measurement stream start. Source: streaming/vo/metrics/HTTPRequest.js, line 140 × Search results Close "},"KeySystem.html":{"id":"KeySystem.html","title":"Interface: KeySystem","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Interface: KeySystem KeySystem Defines the public interface for all Key Systems (DRMs) supported by the player. Source: streaming/protection/drm/KeySystem.js, line 32 Members &lt;readonly&gt; schemeIdURI :String The scheme ID URI for this key system in the form 'urn:uuid:01234567-89ab-cdef-0123-456789abcdef' as used in DASH ContentProtection elements Type: String Source: streaming/protection/drm/KeySystem.js, line 59 &lt;readonly&gt; systemString :String Key system name string (e.g. 'org.w3.clearkey') Type: String Source: streaming/protection/drm/KeySystem.js, line 39 &lt;readonly&gt; uuid :String Key system UUID in the form '01234567-89ab-cdef-0123-456789abcdef' Type: String Source: streaming/protection/drm/KeySystem.js, line 49 Methods getInitData(contentProtection) Parse DRM-specific init data from the ContentProtection element. Parameters: Name Type Description contentProtection Object the json-style contentProtection object representing the ContentProtection element parsed from the MPD XML document. Source: streaming/protection/drm/KeySystem.js, line 71 Returns: EME initialization data Type ArrayBuffer getLicenseRequestFromMessage(message) For some key systems, the CDM message contains more than just the license request data. This method will pull the license request from the CDM message, if necessary. Parameters: Name Type Description message ArrayBuffer the CDM message Source: streaming/protection/drm/KeySystem.js, line 97 Returns: the license request message as will be passed to XMLHttpRequest.send() Type Uint8Array getLicenseServerURLFromInitData(initData) Returns a license server URL as parsed from key system initialization data (PSSH). Parameters: Name Type Description initData ArrayBuffer the initialization data. This is just the &quot;Data&quot; field from the PSSH box definition Source: streaming/protection/drm/KeySystem.js, line 109 Returns: The license server URL or null if URL is not available in initData Type string getRequestHeadersFromMessage(message) For some key systems, the CDM message contains HTTP headers that can be parsed by the application and attached to the license request. Returns a header object with key/value pairs as object properties/values Parameters: Name Type Description message ArrayBuffer the CDM message Source: streaming/protection/drm/KeySystem.js, line 83 Returns: headers object with header names as the object property names and header values as the corresponding object property values. Return null if no such headers were found or if the mechanism is not supported by this key system Type Object × Search results Close "},"LiveEdgeFinder.html":{"id":"LiveEdgeFinder.html","title":"Class: LiveEdgeFinder","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Class: LiveEdgeFinder LiveEdgeFinder new LiveEdgeFinder(config) Parameters: Name Type Description config Object Source: streaming/utils/LiveEdgeFinder.js, line 38 Returns: Type Object | * × Search results Close "},"Logger.html":{"id":"Logger.html","title":"Interface: Logger","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Interface: Logger Logger The an end place to put fragments after they have been fetched. Source: core/Logger.js, line 32 Methods debug(arguments) This method allows you to send debug messages to the browser's console. Parameters: Name Type Argument Description arguments * &lt;repeatable&gt; The message you want to debug. The Arguments object is supported for this method so you can send in comma separated logging items. Source: core/Logger.js, line 61 error(arguments) This method allows you to send error messages to the browser's console. Parameters: Name Type Argument Description arguments * &lt;repeatable&gt; The message you want to debug. The Arguments object is supported for this method so you can send in comma separated logging items. Source: core/Logger.js, line 43 fatal(arguments) This method allows you to send fatal error messages (fatal errors implies playback interruption) to the browser's console. Parameters: Name Type Argument Description arguments * &lt;repeatable&gt; The message you want to debug. The Arguments object is supported for this method so you can send in comma separated logging items. Source: core/Logger.js, line 37 info(arguments) This method allows you to send info messages to the browser's console. Parameters: Name Type Argument Description arguments * &lt;repeatable&gt; The message you want to debug. The Arguments object is supported for this method so you can send in comma separated logging items. Source: core/Logger.js, line 55 warning(arguments) This method allows you to send warning messages to the browser's console. Parameters: Name Type Argument Description arguments * &lt;repeatable&gt; The message you want to debug. The Arguments object is supported for this method so you can send in comma separated logging items. Source: core/Logger.js, line 49 × Search results Close "},"ManifestUpdate.html":{"id":"ManifestUpdate.html","title":"Class: ManifestUpdate","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Class: ManifestUpdate ManifestUpdate This Object holds reference to the manifest update information. new ManifestUpdate() Source: streaming/vo/metrics/ManifestUpdate.js, line 34 Members availabilityStartTime Calculated Availability Start time of the stream. Source: streaming/vo/metrics/ManifestUpdate.js, line 64 buffered Actual element.ranges Source: streaming/vo/metrics/ManifestUpdate.js, line 84 clientTimeOffset The calculated difference between the server and client wall clock time Source: streaming/vo/metrics/ManifestUpdate.js, line 74 currentTime Actual element.currentTime Source: streaming/vo/metrics/ManifestUpdate.js, line 79 fetchTime When this manifest update was received Source: streaming/vo/metrics/ManifestUpdate.js, line 59 latency Static is fixed value of zero. dynamic should be ((Now-@availabilityStartTime) - elementCurrentTime) Source: streaming/vo/metrics/ManifestUpdate.js, line 89 mediaType Media Type Video | Audio | FragmentedText Source: streaming/vo/metrics/ManifestUpdate.js, line 44 presentationStartTime the seek point (liveEdge for dynamic, Stream[0].startTime for static) Source: streaming/vo/metrics/ManifestUpdate.js, line 69 representationInfo Array holding list of RepresentationInfo VO Objects Source: streaming/vo/metrics/ManifestUpdate.js, line 99 requestTime When this manifest update was requested Source: streaming/vo/metrics/ManifestUpdate.js, line 54 streamInfo Array holding list of StreamInfo VO Objects Source: streaming/vo/metrics/ManifestUpdate.js, line 94 type MPD Type static | dynamic Source: streaming/vo/metrics/ManifestUpdate.js, line 49 × Search results Close "},"ManifestUpdateRepresentationInfo.html":{"id":"ManifestUpdateRepresentationInfo.html","title":"Class: ManifestUpdateRepresentationInfo","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Class: ManifestUpdateRepresentationInfo ManifestUpdateRepresentationInfo This Object holds reference to the current representation's info when the manifest was updated. new ManifestUpdateRepresentationInfo() Source: streaming/vo/metrics/ManifestUpdate.js, line 138 Members fragmentInfoType list|template|timeline Source: streaming/vo/metrics/ManifestUpdate.js, line 177 id Track@id Source: streaming/vo/metrics/ManifestUpdate.js, line 147 index Representation Index Source: streaming/vo/metrics/ManifestUpdate.js, line 152 mediaType Media Type Video | Audio | FragmentedText Source: streaming/vo/metrics/ManifestUpdate.js, line 157 presentationTimeOffset Holds reference to @presentationTimeOffset Source: streaming/vo/metrics/ManifestUpdate.js, line 167 startNumber Holds reference to @startNumber Source: streaming/vo/metrics/ManifestUpdate.js, line 172 streamIndex Which representation Source: streaming/vo/metrics/ManifestUpdate.js, line 162 × Search results Close "},"ManifestUpdateStreamInfo.html":{"id":"ManifestUpdateStreamInfo.html","title":"Class: ManifestUpdateStreamInfo","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Class: ManifestUpdateStreamInfo ManifestUpdateStreamInfo This Object holds reference to the current period's stream information when the manifest was updated. new ManifestUpdateStreamInfo() Source: streaming/vo/metrics/ManifestUpdate.js, line 107 Members duration Stream@duration Source: streaming/vo/metrics/ManifestUpdate.js, line 131 id Stream@id Source: streaming/vo/metrics/ManifestUpdate.js, line 116 index Period Index Source: streaming/vo/metrics/ManifestUpdate.js, line 121 start Stream@start Source: streaming/vo/metrics/ManifestUpdate.js, line 126 × Search results Close "},"MediaPlayerEvents.html":{"id":"MediaPlayerEvents.html","title":"Class: MediaPlayerEvents","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Class: MediaPlayerEvents MediaPlayerEvents new MediaPlayerEvents() Public facing external events to be used when developing a player that implements dash.js. Source: streaming/MediaPlayerEvents.js, line 36 Members AST_IN_FUTURE Triggered when playback will not start yet as the MPD's availabilityStartTime is in the future. Check delay property in payload to determine time before playback will start. Source: streaming/MediaPlayerEvents.js, line 48 Events BUFFER_EMPTY Triggered when the video element's buffer state changes to stalled. Check mediaType in payload to determine type (Video, Audio, FragmentedText). Source: streaming/MediaPlayerEvents.js, line 50 BUFFER_LEVEL_STATE_CHANGED Triggered when the video element's buffer state changes, either stalled or loaded. Check payload for state. Source: streaming/MediaPlayerEvents.js, line 64 BUFFER_LOADED Triggered when the video element's buffer state changes to loaded. Check mediaType in payload to determine type (Video, Audio, FragmentedText). Source: streaming/MediaPlayerEvents.js, line 57 CAN_PLAY Sent when enough data is available that the media can be played, at least for a couple of frames. This corresponds to the HAVE_ENOUGH_DATA readyState. Source: streaming/MediaPlayerEvents.js, line 209 ERROR Triggered when there is an error from the element or MSE source buffer. Source: streaming/MediaPlayerEvents.js, line 70 FRAGMENT_LOADING_ABANDONED Triggered when a fragment download is abandoned due to detection of slow download base on the ABR abandon rule.. Source: streaming/MediaPlayerEvents.js, line 93 FRAGMENT_LOADING_COMPLETED Triggered when a fragment download has completed. Source: streaming/MediaPlayerEvents.js, line 76 FRAGMENT_LOADING_PROGRESS Triggered when a partial fragment download has completed. Source: streaming/MediaPlayerEvents.js, line 82 FRAGMENT_LOADING_STARTED Triggered when a fragment download has started. Source: streaming/MediaPlayerEvents.js, line 87 LOG Triggered when module:Debug logger methods are called. Deprecated: Yes Source: streaming/MediaPlayerEvents.js, line 99 MANIFEST_LOADED Triggered when the manifest load is complete Source: streaming/MediaPlayerEvents.js, line 107 MANIFEST_VALIDITY_CHANGED Manifest validity changed - As a result of an MPD validity expiration event. Source: streaming/MediaPlayerEvents.js, line 327 METRIC_ADDED Triggered every time a new metric is added. Source: streaming/MediaPlayerEvents.js, line 125 METRIC_CHANGED Triggered when an individual metric is added, updated or cleared. Source: streaming/MediaPlayerEvents.js, line 119 METRIC_UPDATED Triggered every time a metric is updated. Source: streaming/MediaPlayerEvents.js, line 131 METRICS_CHANGED Triggered anytime there is a change to the overall metrics. Source: streaming/MediaPlayerEvents.js, line 113 PERIOD_SWITCH_COMPLETED Triggered at the stream end of a period. Source: streaming/MediaPlayerEvents.js, line 137 PERIOD_SWITCH_STARTED Triggered when a new period starts. Source: streaming/MediaPlayerEvents.js, line 143 PLAYBACK_CATCHUP_END Sent live catch up mechanism has been deactivated. Source: streaming/MediaPlayerEvents.js, line 226 See: setCatchUpPlaybackRate() setLiveDelay() PLAYBACK_CATCHUP_START Sent when live catch mechanism has been activated, which implies the measured latency of the low latency stream that is been played has gone beyond the target one. Source: streaming/MediaPlayerEvents.js, line 217 See: setCatchUpPlaybackRate() setLiveDelay() PLAYBACK_ENDED Sent when playback completes. Source: streaming/MediaPlayerEvents.js, line 234 PLAYBACK_ERROR Sent when an error occurs. The element's error attribute contains more information. Source: streaming/MediaPlayerEvents.js, line 240 PLAYBACK_METADATA_LOADED The media's metadata has finished loading; all attributes now contain as much useful information as they're going to. Source: streaming/MediaPlayerEvents.js, line 253 PLAYBACK_NOT_ALLOWED Sent when playback is not allowed (for example if user gesture is needed). Source: streaming/MediaPlayerEvents.js, line 247 PLAYBACK_PAUSED Sent when playback is paused. Source: streaming/MediaPlayerEvents.js, line 260 PLAYBACK_PLAYING Sent when the media begins to play (either for the first time, after having been paused, or after ending and then restarting). Source: streaming/MediaPlayerEvents.js, line 266 PLAYBACK_PROGRESS Sent periodically to inform interested parties of progress downloading the media. Information about the current amount of the media that has been downloaded is available in the media element's buffered attribute. Source: streaming/MediaPlayerEvents.js, line 274 PLAYBACK_RATE_CHANGED Sent when the playback speed changes. Source: streaming/MediaPlayerEvents.js, line 282 PLAYBACK_SEEK_ASKED Sent when a seek operation has been asked. Source: streaming/MediaPlayerEvents.js, line 300 PLAYBACK_SEEKED Sent when a seek operation completes. Source: streaming/MediaPlayerEvents.js, line 288 PLAYBACK_SEEKING Sent when a seek operation begins. Source: streaming/MediaPlayerEvents.js, line 294 PLAYBACK_STARTED Sent when playback of the media starts after having been paused; that is, when playback is resumed after a prior pause event. Source: streaming/MediaPlayerEvents.js, line 306 PLAYBACK_TIME_UPDATED The time indicated by the element's currentTime attribute has changed. Source: streaming/MediaPlayerEvents.js, line 314 PLAYBACK_WAITING Sent when the media playback has stopped because of a temporary lack of data. Source: streaming/MediaPlayerEvents.js, line 320 QUALITY_CHANGE_RENDERED Triggered when the new ABR quality is being rendered on-screen. Source: streaming/MediaPlayerEvents.js, line 155 QUALITY_CHANGE_REQUESTED Triggered when an ABR up /down switch is initiated; either by user in manual mode or auto mode via ABR rules. Source: streaming/MediaPlayerEvents.js, line 149 SOURCE_INITIALIZED Triggered when the source is setup and ready. Source: streaming/MediaPlayerEvents.js, line 167 STREAM_INITIALIZED Triggered when a stream (period) is loaded Source: streaming/MediaPlayerEvents.js, line 173 STREAM_TEARDOWN_COMPLETE Triggered when the player has been reset. Source: streaming/MediaPlayerEvents.js, line 179 TEXT_TRACK_ADDED Triggered when a text track is added to the video element's TextTrackList Source: streaming/MediaPlayerEvents.js, line 191 TEXT_TRACKS_ADDED Triggered once all text tracks detected in the MPD are added to the video element. Source: streaming/MediaPlayerEvents.js, line 185 TRACK_CHANGE_RENDERED Triggered when the new track is being rendered. Source: streaming/MediaPlayerEvents.js, line 161 TTML_PARSED Triggered when a ttml chunk has to be parsed. Source: streaming/MediaPlayerEvents.js, line 203 TTML_PARSED Triggered when a ttml chunk is parsed. Source: streaming/MediaPlayerEvents.js, line 197 × Search results Close "},"module-DashMetrics.html":{"id":"module-DashMetrics.html","title":"Module: DashMetrics","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Module: DashMetrics Source: dash/DashMetrics.js, line 36 Methods getCurrent(metrics, metricName) Parameters: Name Type Description metrics MetricsList metricName string Source: dash/DashMetrics.js, line 199 Returns: Type * getCurrentBufferLevel(metrics) Parameters: Name Type Description metrics MetricsList Source: dash/DashMetrics.js, line 124 Returns: Type number getCurrentDroppedFrames(metrics) Parameters: Name Type Description metrics MetricsList Source: dash/DashMetrics.js, line 225 Returns: Type * getCurrentDVRInfo(metrics) Parameters: Name Type Description metrics MetricsList Source: dash/DashMetrics.js, line 255 Returns: Type * getCurrentHttpRequest(metrics) Parameters: Name Type Description metrics MetricsList Source: dash/DashMetrics.js, line 150 Returns: Type * getCurrentManifestUpdate(metrics) Parameters: Name Type Description metrics MetricsList Source: dash/DashMetrics.js, line 245 Returns: Type * getCurrentRepresentationSwitch(metrics) Parameters: Name Type Description metrics MetricsList Source: dash/DashMetrics.js, line 104 Returns: Type * getCurrentSchedulingInfo(metrics) Parameters: Name Type Description metrics MetricsList Source: dash/DashMetrics.js, line 235 Returns: Type * getHttpRequests(metrics) Parameters: Name Type Description metrics MetricsList Source: dash/DashMetrics.js, line 184 Returns: Type * getLatestBufferLevelVO(metrics) Parameters: Name Type Description metrics MetricsList Source: dash/DashMetrics.js, line 114 Returns: Type * getLatestFragmentRequestHeaderValueByID(metrics, id) Parameters: Name Type Description metrics MetricsList id string Source: dash/DashMetrics.js, line 293 Returns: Type * getLatestMPDRequestHeaderValueByID(metrics, id) Parameters: Name Type Description metrics MetricsList id string Source: dash/DashMetrics.js, line 266 Returns: Type * getMaxIndexForBufferType(bufferType, periodIdx) This method returns the current max index based on what is defined in the MPD. Parameters: Name Type Description bufferType string String 'audio' or 'video', periodIdx number Make sure this is the period index not id Source: dash/DashMetrics.js, line 86 Returns: Type number getRequestsQueue(metrics) Parameters: Name Type Description metrics MetricsList Source: dash/DashMetrics.js, line 140 Returns: Type null | * | vo × Search results Close "},"module-Debug.html":{"id":"module-Debug.html","title":"Module: Debug","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Module: Debug Source: core/Debug.js, line 42 Methods getLogger(instance) Retrieves a logger which can be used to write logging information in browser console. Parameters: Name Type Description instance object Object for which the logger is created. It is used to include calle object information in log messages. Source: core/Debug.js, line 89 Returns: Type Logger getLogLevel() Use this method to get the current log level. Source: core/Debug.js, line 136 getLogToBrowserConsole() Use this method to get the state of logToBrowserConsole. Deprecated: Yes Source: core/Debug.js, line 183 Returns: The current value of logToBrowserConsole Type boolean setCalleeNameVisible(value) Prepends the callee object name, and media type if available, to each log message. Parameters: Name Type Description value boolean Set to true if you want to see the callee object name and media type in each log message. Default Value: true Source: core/Debug.js, line 157 setLogLevel(value) Sets up the log level. The levels are cumulative. For example, if you set the log level to dashjs.Debug.LOG_LEVEL_WARNING all warnings, errors and fatals will be logged. Possible values dashjs.Debug.LOG_LEVEL_NONE No message is written in the browser console. dashjs.Debug.LOG_LEVEL_FATAL Log fatal errors. An error is considered fatal when it causes playback to fail completely. dashjs.Debug.LOG_LEVEL_ERROR Log error messages. dashjs.Debug.LOG_LEVEL_WARNING Log warning messages. dashjs.Debug.LOG_LEVEL_INFO Log info messages. dashjs.Debug.LOG_LEVEL_DEBUG Log debug messages. Parameters: Name Type Description value number Log level Default Value: true Source: core/Debug.js, line 127 setLogTimestampVisible(value) Prepends a timestamp in milliseconds to each log message. Parameters: Name Type Description value boolean Set to true if you want to see a timestamp in each log message. Default Value: LOG_LEVEL_WARNING Source: core/Debug.js, line 147 setLogToBrowserConsole(value) Toggles logging to the browser's javascript console. If you set to false you will still receive a log event with the same message. Parameters: Name Type Description value boolean Set to false if you want to turn off logging to the browser's console. Deprecated: Yes Default Value: true Source: core/Debug.js, line 168 × Search results Close "},"module-FactoryMaker.html":{"id":"module-FactoryMaker.html","title":"Module: FactoryMaker","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Module: FactoryMaker Source: core/FactoryMaker.js, line 31 Methods getSingletonInstance(context, className) Use this method from your extended object. this.factory is injected into your object. this.factory.getSingletonInstance(this.context, 'VideoModel') will return the video model for use in the extended object. Parameters: Name Type Description context Object injected into extended object as this.context className string string name found in all dash.js objects with name __dashjs_factory_name Will be at the bottom. Will be the same as the object's name. Source: core/FactoryMaker.js, line 62 Returns: Context aware instance of specified singleton name. Type * setSingletonInstance(context, className, instance) Use this method to add an singleton instance to the system. Useful for unit testing to mock objects etc. Parameters: Name Type Description context Object className string instance Object Source: core/FactoryMaker.js, line 81 × Search results Close "},"module-FetchLoader.html":{"id":"module-FetchLoader.html","title":"Module: FetchLoader","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Module: FetchLoader Manages download of resources via HTTP using fetch. Source: streaming/net/FetchLoader.js, line 35 × Search results Close "},"module-HTTPLoader.html":{"id":"module-HTTPLoader.html","title":"Module: HTTPLoader","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Module: HTTPLoader Manages download of resources via HTTP. Source: streaming/net/HTTPLoader.js, line 37 Methods abort() Aborts any inflight downloads Source: streaming/net/HTTPLoader.js, line 281 load(config) Initiates a download of the resource described by config.request Parameters: Name Type Description config Object contains request (FragmentRequest or derived type), and callbacks Source: streaming/net/HTTPLoader.js, line 265 × Search results Close "},"module-MediaPlayer.html":{"id":"module-MediaPlayer.html","title":"Module: MediaPlayer","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Module: MediaPlayer The MediaPlayer is the primary dash.js Module and a Facade to build your player around. It will allow you access to all the important dash.js properties/methods via the public API and all the events to build a robust DASH media player. Source: streaming/MediaPlayer.js, line 71 Methods addABRCustomRule(type, rulename, rule) Add a custom ABR Rule Rule will be apply on next stream if a stream is being played Parameters: Name Type Description type string rule type (one of ['qualitySwitchRules','abandonFragmentRules']) rulename string name of rule (used to identify custom rule). If one rule of same name has been added, then existing rule will be updated rule object the rule object instance Source: streaming/MediaPlayer.js, line 1312 addUTCTimingSource(schemeIdUri, value) Allows you to set a scheme and server source for UTC live edge detection for dynamic streams. If UTCTiming is defined in the manifest, it will take precedence over any time source manually added. If you have exposed the Date header, use the method clearDefaultUTCTimingSources(). This will allow the date header on the manifest to be used instead of a time server Parameters: Name Type Description schemeIdUri string urn:mpeg:dash:utc:http-head:2014 urn:mpeg:dash:utc:http-xsdate:2014 urn:mpeg:dash:utc:http-iso:2014 urn:mpeg:dash:utc:direct:2014 Some specs referencing early ISO23009-1 drafts incorrectly use 2012 in the URI, rather than 2014. support these for now. urn:mpeg:dash:utc:http-head:2012 urn:mpeg:dash:utc:http-xsdate:2012 urn:mpeg:dash:utc:http-iso:2012 urn:mpeg:dash:utc:direct:2012 value string Path to a time source. Default Value: schemeIdUri:urn:mpeg:dash:utc:http-xsdate:2014 value:http://time.akamai.com Source: streaming/MediaPlayer.js, line 1425 See: removeUTCTimingSource() attachProtectionController(value) Will override dash.js protection controller. Parameters: Name Type Description value ProtectionController valid protection controller instance. Source: streaming/MediaPlayer.js, line 2417 attachSource(urlOrManifest) Use this method to set a source URL to a valid MPD manifest file OR a previously downloaded and parsed manifest object. Optionally, can also provide protection information Parameters: Name Type Description urlOrManifest string | Object A URL to a valid MPD manifest file, or a parsed manifest object. Source: streaming/MediaPlayer.js, line 2541 Throws: &quot;MediaPlayer not initialized!&quot; attachTTMLRenderingDiv(div) Use this method to attach an HTML5 div for dash.js to render rich TTML subtitles. Parameters: Name Type Description div HTMLDivElement An unstyled div placed after the video element. It will be styled to match the video size and overlay z-order. Source: streaming/MediaPlayer.js, line 2175 attachVideoContainer(container) Use this method to attach an HTML5 element that wraps the video element. Parameters: Name Type Description container HTMLElement The HTML5 element containing the video element. Source: streaming/MediaPlayer.js, line 2120 attachView(element) Use this method to attach an HTML5 VideoElement for dash.js to operate upon. Parameters: Name Type Description element Object An HTMLMediaElement that has already been defined in the DOM (or equivalent stub). Source: streaming/MediaPlayer.js, line 2134 clearDefaultUTCTimingSources() Allows you to clear the stored array of time sources. Example use: If you have exposed the Date header, calling this method will allow the date header on the manifest to be used instead of the time server. Example use: Calling this method, assuming there is not an exposed date header on the manifest, will default back to using a binary search to discover the live edge Source: streaming/MediaPlayer.js, line 1462 See: restoreDefaultUTCTimingSources() convertToTimeCode(value) A utility method which converts seconds into TimeCode (i.e. 300 --&gt; 05:00). Parameters: Name Type Description value number A number in seconds to be converted into a formatted time code. Source: streaming/MediaPlayer.js, line 2589 Returns: A formatted time code string. Type string displayCaptionsOnTop(value) This method serves to control captions z-index value. If 'true' is passed, the captions will have the highest z-index and be displayed on top of other html elements. Default value is 'false' (z-index is not set). Parameters: Name Type Description value boolean Source: streaming/MediaPlayer.js, line 2073 duration() Duration of the media's playback, in seconds. Source: streaming/MediaPlayer.js, line 683 Returns: The current duration of the media. Type number durationAsUTC() Use this method to get the current duration as an absolute value, the time in seconds since midnight UTC, Jan 1 1970. Note - this property only has meaning for live streams. Source: streaming/MediaPlayer.js, line 730 Returns: The current duration as UTC timestamp. Type number enableForcedTextStreaming(enable) Enable/disable text When enabling dash will keep downloading and process fragmented text tracks even if all tracks are in mode &quot;hidden&quot; Parameters: Name Type Description enable boolean true to enable text streaming even if all text tracks are hidden. Source: streaming/MediaPlayer.js, line 2013 enableLastBitrateCaching(enable [, ttl]) Set to false if you would like to disable the last known bit rate from being stored during playback and used to set the initial bit rate for subsequent playback within the expiration window. The default expiration is one hour, defined in milliseconds. If expired, the default initial bit rate (closest to 1000 kbps) will be used for that session and a new bit rate will be stored during that session. Parameters: Name Type Argument Description enable boolean Will toggle if feature is enabled. True to enable, False to disable. ttl number &lt;optional&gt; (Optional) A value defined in milliseconds representing how long to cache the bit rate for. Time to live. Default Value: enable = True, ttl = 360000 (1 hour) Source: streaming/MediaPlayer.js, line 1174 enableLastMediaSettingsCaching(enable [, ttl]) Set to false if you would like to disable the last known lang for audio (or camera angle for video) from being stored during playback and used to set the initial settings for subsequent playback within the expiration window. The default expiration is one hour, defined in milliseconds. If expired, the default settings will be used for that session and a new settings will be stored during that session. Parameters: Name Type Argument Description enable boolean Will toggle if feature is enabled. True to enable, False to disable. ttl number &lt;optional&gt; (Optional) A value defined in milliseconds representing how long to cache the settings for. Time to live. Default Value: enable = True, ttl = 360000 (1 hour) Source: streaming/MediaPlayer.js, line 1192 enableManifestDateHeaderTimeSource(value) Allows you to enable the use of the Date Header, if exposed with CORS, as a timing source for live edge detection. The use of the date header will happen only after the other timing source that take precedence fail or are omitted as described. clearDefaultUTCTimingSources() Parameters: Name Type Description value boolean true to enable Default Value: {boolean} True Source: streaming/MediaPlayer.js, line 1495 See: addUTCTimingSource() enableText(enable) Enable/disable text When enabling text, dash will choose the previous selected text track Parameters: Name Type Description enable boolean true to enable text, false otherwise (same as setTextTrack(-1)) Source: streaming/MediaPlayer.js, line 1996 extend(parentNameString, childInstance, override) This method should be used to extend or replace internal dash.js objects. There are two ways to extend dash.js (determined by the override argument): If you set override to true any public method or property in your custom object will override the dash.js parent object's property(ies) and will be used instead but the dash.js parent module will still be created. If you set override to false your object will completely replace the dash.js object. (Note: This is how it was in 1.x of Dash.js with Dijon). When you extend you get access to this.context, this.factory and this.parent to operate with in your custom object. this.context - can be used to pass context for singleton access. this.factory - can be used to call factory.getSingletonInstance(). this.parent - is the reference of the parent object to call other public methods. (this.parent is excluded if you extend with override set to false or option 2) You must call extend before you call initialize Parameters: Name Type Description parentNameString string name of parent module childInstance Object overriding object override boolean replace only some methods (true) or the whole object (false) Source: streaming/MediaPlayer.js, line 2623 See: initialize() formatUTC(time, locales, hour12, withDate) A utility methods which converts UTC timestamp value into a valid time and date string. Parameters: Name Type Default Description time number UTC timestamp to be converted into date and time. locales string a region identifier (i.e. en_US). hour12 boolean 12 vs 24 hour. Set to true for 12 hour time formatting. withDate boolean false default is false. Set to true to append current date to UTC time format. Source: streaming/MediaPlayer.js, line 2572 Returns: A formatted time and date string. Type string getABRStrategy() Returns the current ABR strategy being used. Source: streaming/MediaPlayer.js, line 1287 See: setABRStrategy() Returns: &quot;abrDynamic&quot;, &quot;abrBola&quot; or &quot;abrThroughput&quot; Type string getAutoPlay() Source: streaming/MediaPlayer.js, line 1086 Returns: The current autoPlay state. Type boolean getAutoSwitchQualityFor(type) Parameters: Name Type Description type string 'audio' | 'video' Source: streaming/MediaPlayer.js, line 1016 Returns: Current state of adaptive bitrate switching Type boolean getAverageThroughput(type) Returns the average throughput computed in the ABR logic Parameters: Name Type Description type string Source: streaming/MediaPlayer.js, line 1718 Returns: value Type number getBandwidthSafetyFactor() Returns the number of the current BandwidthSafetyFactor Source: streaming/MediaPlayer.js, line 1706 See: setBandwidthSafetyFactor() Returns: value Type number getBitrateInfoListFor(type) Parameters: Name Type Description type string Source: streaming/MediaPlayer.js, line 2195 Returns: Type Array getBufferLength(type) The length of the buffer for a given media type, in seconds. Valid media types are &quot;video&quot;, &quot;audio&quot; and &quot;fragmentedText&quot;. If no type is passed in, then the minimum of video, audio and fragmentedText buffer length is returned. NaN is returned if an invalid type is requested, the presentation does not contain that type, or if no arguments are passed and the presentation does not include any adaption sets of valid media type. Parameters: Name Type Description type string the media type of the buffer Source: streaming/MediaPlayer.js, line 586 Returns: The length of the buffer for the given media type, in seconds, or NaN Type number getBufferTimeAtTopQuality() The time that the internal buffer target will be set to once playing the top quality. If there are multiple bitrates in your adaptation, and the media is playing at the highest bitrate, then we try to build a larger buffer at the top quality to increase stability and to maintain media quality. Default Value: 30 seconds. Source: streaming/MediaPlayer.js, line 1604 getBufferTimeAtTopQualityLongForm() The time that the internal buffer target will be set to once playing the top quality for long form content. Default Value: 60 seconds. Source: streaming/MediaPlayer.js, line 1631 See: setLongFormContentDurationThreshold() setBufferTimeAtTopQuality() getCatchUpPlaybackRate() Returns the current catchup playback rate. Source: streaming/MediaPlayer.js, line 515 See: setCatchUpPlaybackRate() Returns: Type number getCurrentLiveLatency() Source: streaming/MediaPlayer.js, line 1136 Returns: Current live stream latency in seconds. It is the difference between current time and time position at the playback head. Type number | NaN getCurrentTrackFor(type) Parameters: Name Type Description type string Source: streaming/MediaPlayer.js, line 2259 Returns: MediaInfo Type Object | null getDashMetrics() Returns the DashMetrics.js Module. You use this Module to get access to all the public metrics stored in dash.js Source: streaming/MediaPlayer.js, line 1905 See: module:DashMetrics Returns: Type Object getDebug() Use this method to access the dash.js logging class. Source: streaming/MediaPlayer.js, line 334 Returns: Type Debug getDVRSeekOffset(value) This method should only be used with a live stream that has a valid timeShiftBufferLength (DVR Window). NOTE - If you do not need the raw offset value (i.e. media analytics, tracking, etc) consider using the seek() method which will calculate this value for you and set the video element's currentTime property all in one simple call. Parameters: Name Type Description value number A relative time, in seconds, based on the return value of the duration() method is expected. Source: streaming/MediaPlayer.js, line 632 See: seek() Returns: A value that is relative the available range within the timeShiftBufferLength (DVR Window). Type number getDVRWindowSize() The timeShiftBufferLength (DVR Window), in seconds. Source: streaming/MediaPlayer.js, line 613 Returns: The window of allowable play time behind the live point of a live stream. Type number getFastSwitchEnabled() Enabled by default. Will return the current state of Fast Switch. Source: streaming/MediaPlayer.js, line 1254 See: setFastSwitchEnabled() Returns: Returns true if FastSwitch ABR is enabled. Type boolean getInitialBitrateFor(type) Parameters: Name Type Description type string Source: streaming/MediaPlayer.js, line 983 Returns: A value of the initial bitrate, kbps Type number getInitialMediaSettingsFor(type) This method returns media settings that is used to pick the initial track. Format of the settings is following: {lang: langValue, viewpoint: viewpointValue, audioChannelConfiguration: audioChannelConfigurationValue, accessibility: accessibilityValue, role: roleValue} Parameters: Name Type Description type string Source: streaming/MediaPlayer.js, line 2305 Returns: Type Object getInitialRepresentationRatioFor(type) Parameters: Name Type Description type string Source: streaming/MediaPlayer.js, line 1006 Returns: A value of the initial Representation Ratio Type number getJumpGaps() Gets current status of jump gaps feature. Source: streaming/MediaPlayer.js, line 1832 Returns: The current jump gaps state. Type boolean getLimitBitrateByPortal() Source: streaming/MediaPlayer.js, line 929 getLiveDelay() Source: streaming/MediaPlayer.js, line 1127 See: setLiveDelay() Returns: Current live stream delay in seconds when previously set, or undefined Type number | undefined getLowLatencyEnabled() Returns if low latency mode is enabled. Disabled by default. Source: streaming/MediaPlayer.js, line 1381 See: setLowLatencyEnabled() Returns: true - if enabled Type boolean getManifestUpdateRetryInterval() For live streams, get the interval-frequency in milliseconds at which dash.js will check if the current manifest is still processed before downloading the next manifest once the minimumUpdatePeriod time has expired. Source: streaming/MediaPlayer.js, line 1885 See: setManifestUpdateRetryInterval() Returns: Current retry delay for manifest update Type int getMaxAllowedBitrateFor(type) Parameters: Name Type Description type string 'video' or 'audio' are the type options. Source: streaming/MediaPlayer.js, line 790 See: setMaxAllowedBitrateFor() getMaxAllowedRepresentationRatioFor(type) Parameters: Name Type Description type string 'video' or 'audio' are the type options. Source: streaming/MediaPlayer.js, line 849 See: setMaxAllowedRepresentationRatioFor() Returns: The current representation ratio cap. Type number getMetricsFor(type) Parameters: Name Type Description type string Source: streaming/MediaPlayer.js, line 1916 Returns: Type Object getMinAllowedBitrateFor(type) Parameters: Name Type Description type string 'video' or 'audio' are the type options. Source: streaming/MediaPlayer.js, line 817 See: setMinAllowedBitrateFor() getMovingAverageMethod() Return the current moving average method used for smoothing throughput estimates. Source: streaming/MediaPlayer.js, line 1369 See: setMovingAverageMethod() Returns: Returns &quot;slidingWindow&quot; or &quot;ewma&quot;. Type string getPlaybackRate() Returns the current playback rate. Source: streaming/MediaPlayer.js, line 479 Returns: Type number getQualityFor(type) Gets the current download quality for media type video, audio or images. For video and audio types the ABR rules update this value before every new download unless setAutoSwitchQualityFor(type, false) is called. For 'image' type, thumbnails, there is no ABR algorithm and quality is set manually. Parameters: Name Type Description type string 'video', 'audio' or 'image' (thumbnails) Source: streaming/MediaPlayer.js, line 865 See: setAutoSwitchQualityFor() setQualityFor() Returns: the quality index, 0 corresponding to the lowest bitrate Type number getScheduleWhilePaused() Returns a boolean of the current state of ScheduleWhilePaused. Source: streaming/MediaPlayer.js, line 1216 See: setScheduleWhilePaused() Returns: Type boolean getSelectionModeForInitialTrack() This method returns the track selection mode. Source: streaming/MediaPlayer.js, line 2389 Returns: mode Type string getSmallGapLimit() Time in seconds for a gap to be considered small. Source: streaming/MediaPlayer.js, line 1855 Returns: Current small gap limit Type boolean getSource() Returns the source string or manifest that was attached by calling attachSource() Source: streaming/MediaPlayer.js, line 2520 Returns: Type string | manifest getStableBufferTime() The time that the internal buffer target will be set to post startup/seeks (NOT top quality). When the time is set higher than the default you will have to wait longer to see automatic bitrate switches but will have a larger buffer which will increase stability. Default Value: 12 seconds. Source: streaming/MediaPlayer.js, line 1567 getStreamsFromManifest(manifest) This method returns the list of all available streams from a given manifest Parameters: Name Type Description manifest Object Source: streaming/MediaPlayer.js, line 2210 Returns: list of StreamInfo Type Array getTextDefaultEnabled() Get enabled default state. Source: streaming/MediaPlayer.js, line 1980 Returns: default enable state Type boolean getTextDefaultLanguage() Get default language for text. Source: streaming/MediaPlayer.js, line 1948 Returns: the default language if it has been set using setTextDefaultLanguage Type string getThumbnail(time) Return the thumbnail at time position. Parameters: Name Type Description time number A relative time, in seconds, based on the return value of the duration() method is expected Source: streaming/MediaPlayer.js, line 2457 Returns: Thumbnail for the given time position. It returns null in case there are is not a thumbnails representation or if it doesn't contain a thumbnail for the given time position. Type Thumbnail | null getTopBitrateInfoFor(type) Gets the top quality BitrateInfo checking portal limit and max allowed. It calls getTopQualityIndexFor internally Parameters: Name Type Description type string 'video' or 'audio' are the type options. Source: streaming/MediaPlayer.js, line 804 Returns: Type BitrateInfo | null getTracksFor(type) This method returns the list of all available tracks for a given media type Parameters: Name Type Description type string Source: streaming/MediaPlayer.js, line 2224 Returns: list of MediaInfo Type Array getTracksForTypeFromManifest(type, manifest, streamInfo) This method returns the list of all available tracks for a given media type and streamInfo from a given manifest Parameters: Name Type Description type string manifest Object streamInfo Object Source: streaming/MediaPlayer.js, line 2242 Returns: list of MediaInfo Type Array getTrackSwitchModeFor(type) This method returns the current track switch mode. Parameters: Name Type Description type string Source: streaming/MediaPlayer.js, line 2332 Returns: mode Type string getTTMLRenderingDiv() Returns instance of Div that was attached by calling attachTTMLRenderingDiv() Source: streaming/MediaPlayer.js, line 2164 Returns: Type Object getUseDeadTimeLatencyForAbr() Get the value of useDeadTimeLatency in AbrController. @see setUseDeadTimeLatencyForAbr Source: streaming/MediaPlayer.js, line 1041 Returns: Type boolean getUsePixelRatioInLimitBitrateByPortal() Source: streaming/MediaPlayer.js, line 948 getVersion() Current version of Dash.js Source: streaming/MediaPlayer.js, line 323 Returns: the current dash.js version string. Type string getVideoContainer() Returns instance of Video Container that was attached by calling attachVideoContainer() Source: streaming/MediaPlayer.js, line 2109 Returns: Type Object getVideoElement() Returns instance of Video Element that was attached by calling attachView() Source: streaming/MediaPlayer.js, line 2096 Returns: Type Object getVolume() Returns the current audio volume, from 0.0 (silent) to 1.0 (loudest). Source: streaming/MediaPlayer.js, line 564 Returns: Type number getXHRWithCredentialsForType(type) Gets whether withCredentials on XHR requests for a particular request type is true or false Parameters: Name Type Description type string one of HTTPRequest.*_TYPE Source: streaming/MediaPlayer.js, line 1809 Returns: Type boolean initialize( [view] [, source] [, AutoPlay]) Upon creating the MediaPlayer you must call initialize before you call anything else. There is one exception to this rule. It is crucial to call extend() with all your extensions prior to calling initialize. ALL arguments are optional and there are individual methods to set each argument later on. The args in this method are just for convenience and should only be used for a simple player setup. Parameters: Name Type Argument Description view HTML5MediaElement &lt;optional&gt; Optional arg to set the video element. attachView() source string &lt;optional&gt; Optional arg to set the media source. attachSource() AutoPlay boolean &lt;optional&gt; Optional arg to set auto play. setAutoPlay() Source: streaming/MediaPlayer.js, line 188 See: attachView() attachSource() setAutoPlay() isDynamic() Returns a Boolean that indicates whether the media is in the process of dynamic. Source: streaming/MediaPlayer.js, line 453 Returns: Type boolean isMuted() A Boolean that determines whether audio is muted. Source: streaming/MediaPlayer.js, line 538 Returns: Type boolean isPaused() Returns a Boolean that indicates whether the Video Element is paused. Source: streaming/MediaPlayer.js, line 405 Returns: Type boolean isReady() The ready state of the MediaPlayer based on both the video element and MPD source being defined. Source: streaming/MediaPlayer.js, line 287 See: attachView() attachSource() Returns: The current ready state of the MediaPlayer Type boolean isSeeking() Returns a Boolean that indicates whether the media is in the process of seeking to a new position. Source: streaming/MediaPlayer.js, line 440 Returns: Type boolean isTextEnabled() Return if text is enabled Source: streaming/MediaPlayer.js, line 2030 Returns: return true if text is enabled, false otherwise Type boolean off(type, listener, scope) Use the off method to remove listeners for public events found in MediaPlayer.events. MediaPlayerEvents Parameters: Name Type Description type string MediaPlayerEvents listener function callback method when the event fires. scope Object context of the listener so it can be removed properly. Source: streaming/MediaPlayer.js, line 313 on(type, listener, scope) Use the on method to listen for public events found in MediaPlayer.events. MediaPlayerEvents Parameters: Name Type Description type string MediaPlayerEvents listener function callback method when the event fires. scope Object context of the listener so it can be removed properly. Source: streaming/MediaPlayer.js, line 300 pause() This method will call pause on the native Video Element. Source: streaming/MediaPlayer.js, line 392 play() The play method initiates playback of the media defined by the attachSource() method. This method will call play on the native Video Element. Source: streaming/MediaPlayer.js, line 376 See: attachSource() preload() Causes the player to begin streaming the media as set by the attachSource() method in preparation for playing. It specifically does not require a view to be attached with attachView() to begin preloading. When a view is attached after preloading, the buffered data is transferred to the attached mediaSource buffers. Source: streaming/MediaPlayer.js, line 357 See: attachSource() attachView() removeABRCustomRule(rulename) Remove a custom ABR Rule Parameters: Name Type Description rulename string name of the rule to be removed Source: streaming/MediaPlayer.js, line 1323 removeAllABRCustomRule() Remove all custom rules Source: streaming/MediaPlayer.js, line 1332 removeUTCTimingSource(schemeIdUri, value) Allows you to remove a UTC time source. Both schemeIdUri and value need to match the Dash.vo.UTCTiming properties in order for the entry to be removed from the array Parameters: Name Type Description schemeIdUri string see addUTCTimingSource() value string see addUTCTimingSource() Source: streaming/MediaPlayer.js, line 1442 See: clearDefaultUTCTimingSources() reset() Sets the MPD source and the video element to null. You can also reset the MediaPlayer by calling attachSource with a new source file. Calling this method is all that is necessary to destroy a MediaPlayer instance. Source: streaming/MediaPlayer.js, line 264 restoreDefaultUTCTimingSources() Allows you to restore the default time sources after calling clearDefaultUTCTimingSources() Default Value: schemeIdUri:urn:mpeg:dash:utc:http-xsdate:2014 value:http://time.akamai.com Source: streaming/MediaPlayer.js, line 1479 See: addUTCTimingSource() retrieveManifest(url, callback) Allows application to retrieve a manifest. Manifest loading is asynchro nous and requires the app-provided callback function Parameters: Name Type Description url string url the manifest url callback function A Callback function provided when retrieving manifests Source: streaming/MediaPlayer.js, line 2494 seek(value) Sets the currentTime property of the attached video element. If it is a live stream with a timeShiftBufferLength, then the DVR window offset will be automatically calculated. Parameters: Name Type Description value number A relative time, in seconds, based on the return value of the duration() method is expected Source: streaming/MediaPlayer.js, line 421 See: getDVRSeekOffset() setAbandonLoadTimeout(value) A timeout value in seconds, which during the ABRController will block switch-up events. This will only take effect after an abandoned fragment event occurs. Parameters: Name Type Description value int Default Value: 10 seconds Source: streaming/MediaPlayer.js, line 1732 setABRStrategy(value) Sets the ABR strategy. Valid strategies are &quot;abrDynamic&quot;, &quot;abrBola&quot; and &quot;abrThroughput&quot;. The ABR strategy can also be changed during a streaming session. The call has no effect if an invalid method is passed. The BOLA strategy chooses bitrate based on current buffer level, with higher bitrates for higher buffer levels. The Throughput strategy chooses bitrate based on the recent throughput history. The Dynamic strategy switches smoothly between BOLA and Throughput in real time, playing to the strengths of both. Parameters: Name Type Description value string Default Value: &quot;abrDynamic&quot; Source: streaming/MediaPlayer.js, line 1272 setAutoPlay(value) Set to false to prevent stream from auto-playing when the view is attached. Parameters: Name Type Description value boolean Default Value: true Source: streaming/MediaPlayer.js, line 1077 See: attachView() setAutoSwitchQualityFor(type, value) Set to false to switch off adaptive bitrate switching. Parameters: Name Type Description type string 'audio' | 'video' value boolean Default Value: true Source: streaming/MediaPlayer.js, line 1029 setBandwidthSafetyFactor(value) A percentage between 0.0 and 1 to reduce the measured throughput calculations. The default is 0.9. The lower the value the more conservative and restricted the measured throughput calculations will be. please use carefully. This will directly affect the ABR logic in dash.js Parameters: Name Type Description value number Source: streaming/MediaPlayer.js, line 1694 setBufferAheadToKeep(value) This value influences the buffer pruning logic. Allows you to modify the buffer ahead of current time position that is kept in source buffer in seconds. 0|--------|currentTime|-----bufferAheadToKeep----|----bufferToPrune-----------|end| Parameters: Name Type Description value int Default Value: 80 seconds Source: streaming/MediaPlayer.js, line 1523 setBufferPruningInterval(value) This value influences the buffer pruning logic. Allows you to modify the interval of pruning buffer in seconds. Parameters: Name Type Description value int Default Value: 10 seconds Source: streaming/MediaPlayer.js, line 1536 setBufferTimeAtTopQuality(value, value) The time that the internal buffer target will be set to once playing the top quality. If there are multiple bitrates in your adaptation, and the media is playing at the highest bitrate, then we try to build a larger buffer at the top quality to increase stability and to maintain media quality. Parameters: Name Type Description value int /** The time that the internal buffer target will be set to once playing the top quality. If there are multiple bitrates in your adaptation, and the media is playing at the highest bitrate, then we try to build a larger buffer at the top quality to increase stability and to maintain media quality. value int Default Value: 30 seconds. Source: streaming/MediaPlayer.js, line 1590 setBufferTimeAtTopQualityLongForm(value) The time that the internal buffer target will be set to once playing the top quality for long form content. Parameters: Name Type Description value int Default Value: 60 seconds. Source: streaming/MediaPlayer.js, line 1618 See: setLongFormContentDurationThreshold() setBufferTimeAtTopQuality() setBufferToKeep(value) This value influences the buffer pruning logic. Allows you to modify the buffer that is kept in source buffer in seconds. 0|-----------bufferToPrune-----------|-----bufferToKeep-----|currentTime| Parameters: Name Type Description value int Default Value: 20 seconds Source: streaming/MediaPlayer.js, line 1509 setCacheLoadThresholdForType(type, value) For a given media type, the threshold which defines if the response to a fragment request is coming from browser cache or not. Valid media types are &quot;video&quot;, &quot;audio&quot; Parameters: Name Type Description type string 'video' or 'audio' are the type options. value number Threshold value in milliseconds. Default Value: 50 milliseconds for video fragment requests; 5 milliseconds for audio fragment requests. Source: streaming/MediaPlayer.js, line 1680 setCatchUpPlaybackRate(value) Use this method to set the catch up rate, as a percentage, for low latency live streams. In low latency mode, when measured latency is higher than the target one (setLiveDelay()), dash.js increases playback rate the percentage defined with this method until target is reached. Valid values for catch up rate are in range 0-20%. Set it to 0% to turn off live catch up feature. Note: Catch-up mechanism is only applied when playing low latency live streams. Parameters: Name Type Description value number Percentage in which playback rate is increased when live catch up mechanism is activated. Default Value: {number} 0.05 Source: streaming/MediaPlayer.js, line 501 See: setLiveDelay() setConfig( [config]) Configure media player with customs controllers. Helpful for tests Parameters: Name Type Argument Description config object &lt;optional&gt; controllers configuration Source: streaming/MediaPlayer.js, line 147 setCurrentTrack(track) Parameters: Name Type Description track MediaInfo instance of MediaInfo Source: streaming/MediaPlayer.js, line 2317 setFastSwitchEnabled(value) When enabled, after an ABR up-switch in quality, instead of requesting and appending the next fragment at the end of the current buffer range it is requested and appended closer to the current time When enabled, The maximum time to render a higher quality is current time + (1.5 * fragment duration). Note, When ABR down-switch is detected, we appended the lower quality at the end of the buffer range to preserve the higher quality media for as long as possible. If enabled, it should be noted there are a few cases when the client will not replace inside buffer range but rather just append at the end. 1. When the buffer level is less than one fragment duration 2. The client is in an Abandonment State due to recent fragment abandonment event. Known issues: In IE11 with auto switching off, if a user switches to a quality they can not download in time the fragment may be appended in the same range as the playhead or even in the past, in IE11 it may cause a stutter or stall in playback. Parameters: Name Type Description value boolean Default Value: {boolean} false Source: streaming/MediaPlayer.js, line 1243 setFragmentLoaderRetryAttempts(value) Total number of retry attempts that will occur on a fragment load before it fails. Increase this value to a maximum in order to achieve an automatic playback resume in case of completely lost internet connection. Parameters: Name Type Description value int Default Value: 3 Source: streaming/MediaPlayer.js, line 1746 setFragmentLoaderRetryInterval(value) Time in milliseconds of which to reload a failed fragment load attempt. Parameters: Name Type Description value int Default Value: 1000 milliseconds Source: streaming/MediaPlayer.js, line 1758 setInitialBitrateFor(type, value) Use this method to explicitly set the starting bitrate for audio | video Parameters: Name Type Description type string value number A value of the initial bitrate, kbps Source: streaming/MediaPlayer.js, line 973 setInitialMediaSettingsFor(type, value) This method allows to set media settings that will be used to pick the initial track. Format of the settings is following: {lang: langValue, viewpoint: viewpointValue, audioChannelConfiguration: audioChannelConfigurationValue, accessibility: accessibilityValue, role: roleValue} Parameters: Name Type Description type string value Object Source: streaming/MediaPlayer.js, line 2285 setInitialRepresentationRatioFor(type, value) Parameters: Name Type Description type string value number A value of the initial Representation Ratio Source: streaming/MediaPlayer.js, line 996 setJumpGaps(value) Sets whether player should jump small gaps (discontinuities) in the buffer. Parameters: Name Type Description value boolean Default Value: false Source: streaming/MediaPlayer.js, line 1822 setLimitBitrateByPortal(value) Sets whether to limit the representation used based on the size of the playback area Parameters: Name Type Description value boolean Source: streaming/MediaPlayer.js, line 940 setLiveDelay(value) Equivalent in seconds of setLiveDelayFragmentCount Lowering this value will lower latency but may decrease the player's ability to build a stable buffer. This value should be less than the manifest duration by a couple of segment durations to avoid playback issues If set, this parameter will take precedence over setLiveDelayFragmentCount and manifest info Parameters: Name Type Description value number Represents how many seconds to delay the live stream. Default Value: undefined Source: streaming/MediaPlayer.js, line 1117 See: useSuggestedPresentationDelay() setLiveDelayFragmentCount(value) Changing this value will lower or increase live stream latency. The detected segment duration will be multiplied by this value to define a time in seconds to delay a live stream from the live edge. Lowering this value will lower latency but may decrease the player's ability to build a stable buffer. Parameters: Name Type Description value number Represents how many segment durations to delay the live stream. Default Value: 4 Source: streaming/MediaPlayer.js, line 1101 See: useSuggestedPresentationDelay() setLongFormContentDurationThreshold(value) The threshold which defines if the media is considered long form content. This will directly affect the buffer targets when playing back at the top quality. Parameters: Name Type Description value number Default Value: 600 seconds (10 minutes). Source: streaming/MediaPlayer.js, line 1645 See: setBufferTimeAtTopQualityLongForm() setLowLatencyEnabled(value) Enables low latency mode for dynamic streams. If not specified, liveDelay is set to 3s of buffer. Browser compatibility (Check row 'ReadableStream response body'): https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API Parameters: Name Type Description value boolean Source: streaming/MediaPlayer.js, line 1392 setManifestLoaderRetryAttempts(value) Total number of retry attempts that will occur on a manifest load before it fails. Parameters: Name Type Description value int Default Value: 4 Source: streaming/MediaPlayer.js, line 1770 setManifestLoaderRetryInterval(value) Time in milliseconds of which to reload a failed manifest load attempt. Parameters: Name Type Description value int Default Value: 1000 milliseconds Source: streaming/MediaPlayer.js, line 1782 setManifestUpdateRetryInterval(value) For live streams, set the interval-frequency in milliseconds at which dash.js will check if the current manifest is still processed before downloading the next manifest once the minimumUpdatePeriod time has expired. Parameters: Name Type Description value int Default Value: 100 Source: streaming/MediaPlayer.js, line 1871 See: getManifestUpdateRetryInterval() setMaxAllowedBitrateFor(type, value) When switching multi-bitrate content (auto or manual mode) this property specifies the maximum bitrate allowed. If you set this property to a value lower than that currently playing, the switching engine will switch down to satisfy this requirement. If you set it to a value that is lower than the lowest bitrate, it will still play that lowest bitrate. You can set or remove this bitrate cap at anytime before or during playback. To clear this setting you must use the API and set the value param to NaN. This feature is typically used to reserve higher bitrates for playback only when the player is in large or full-screen format. Parameters: Name Type Description type string 'video' or 'audio' are the type options. value number Value in kbps representing the maximum bitrate allowed. Source: streaming/MediaPlayer.js, line 760 setMaxAllowedRepresentationRatioFor(type, value) When switching multi-bitrate content (auto or manual mode) this property specifies the maximum representation allowed, as a proportion of the size of the representation set. You can set or remove this cap at anytime before or during playback. To clear this setting you must use the API and set the value param to NaN. If both this and maxAllowedBitrate are defined, maxAllowedBitrate is evaluated first, then maxAllowedRepresentation, i.e. the lowest value from executing these rules is used. This feature is typically used to reserve higher representations for playback only when connected over a fast connection. Parameters: Name Type Description type string 'video' or 'audio' are the type options. value number number between 0 and 1, where 1 is allow all representations, and 0 is allow only the lowest. Source: streaming/MediaPlayer.js, line 838 setMinAllowedBitrateFor(type, value) When switching multi-bitrate content (auto or manual mode) this property specifies the minimum bitrate allowed. If you set this property to a value higher than that currently playing, the switching engine will switch up to satisfy this requirement. If you set it to a value that is lower than the lowest bitrate, it will still play that lowest bitrate. You can set or remove this bitrate limit at anytime before or during playback. To clear this setting you must use the API and set the value param to NaN. This feature is used to force higher quality playback. Parameters: Name Type Description type string 'video' or 'audio' are the type options. value number Value in kbps representing the minimum bitrate allowed. Source: streaming/MediaPlayer.js, line 780 setMovingAverageMethod(value) Sets the moving average method used for smoothing throughput estimates. Valid methods are &quot;slidingWindow&quot; and &quot;ewma&quot;. The call has no effect if an invalid method is passed. The sliding window moving average method computes the average throughput using the last four segments downloaded. If the stream is live (as opposed to VOD), then only the last three segments are used. If wide variations in throughput are detected, the number of segments can be dynamically increased to avoid oscillations. The exponentially weighted moving average (EWMA) method computes the average using exponential smoothing. Two separate estimates are maintained, a fast one with a three-second half life and a slow one with an eight-second half life. The throughput estimate at any time is the minimum of the fast and slow estimates. This allows a fast reaction to a bandwidth drop and prevents oscillations on bandwidth spikes. Parameters: Name Type Description value string Default Value: {string} 'slidingWindow' Source: streaming/MediaPlayer.js, line 1354 setMute(value) Use this method to set the native Video Element's muted state. Takes a Boolean that determines whether audio is muted. true if the audio is muted and false otherwise. Parameters: Name Type Description value boolean Source: streaming/MediaPlayer.js, line 525 setPlaybackRate(value) Use this method to set the native Video Element's playback rate. Parameters: Name Type Description value number Source: streaming/MediaPlayer.js, line 466 setProtectionData(value) Sets Protection Data required to setup the Protection Module (DRM). Protection Data must be set before initializing MediaPlayer or, once initialized, before PROTECTION_CREATED event is fired. Parameters: Name Type Description value ProtectionData object containing property names corresponding to key system name strings and associated values being instances of. Source: streaming/MediaPlayer.js, line 2432 See: initialize() dashjs.Protection.events.PROTECTION_CREATED setQualityFor(type, value) Sets the current quality for media type instead of letting the ABR Heuristics automatically selecting it. This value will be overwritten by the ABR rules unless setAutoSwitchQualityFor(type, false) is called. Parameters: Name Type Description type string 'video', 'audio' or 'image' value number the quality index, 0 corresponding to the lowest bitrate Source: streaming/MediaPlayer.js, line 894 See: setAutoSwitchQualityFor() getQualityFor() setScheduleWhilePaused(value) Set to true if you would like dash.js to keep downloading fragments in the background when the video element is paused. Parameters: Name Type Description value boolean Default Value: true Source: streaming/MediaPlayer.js, line 1205 setSegmentOverlapToleranceTime(value) The overlap tolerance time, at both the head and the tail of segments, considered when doing time to segment conversions. This is used when calculating which of the loaded segments of a representation corresponds with a given time position. Its value is never used for calculating the segment index in seeking operations in which it assumes overlap time threshold is zero. |-o-|--- segment X ----|-o-| |-o-|---- segment X+1 -----|-o-| |-o-|---- segment X+2 -----|-o-| Parameters: Name Type Description value number Default Value: 0.05 seconds. Source: streaming/MediaPlayer.js, line 1665 setSelectionModeForInitialTrack(mode) This method sets the selection mode for the initial track. This mode defines how the initial track will be selected if no initial media settings are set. If initial media settings are set this parameter will be ignored. Available options are: MediaController.TRACK_SELECTION_MODE_HIGHEST_BITRATE this mode makes the player select the track with a highest bitrate. This mode is a default mode. MediaController.TRACK_SELECTION_MODE_WIDEST_RANGE this mode makes the player select the track with a widest range of bitrates Parameters: Name Type Description mode string Source: streaming/MediaPlayer.js, line 2375 setSmallGapLimit(value) Time in seconds for a gap to be considered small. Parameters: Name Type Description value boolean Default Value: 0.8 Source: streaming/MediaPlayer.js, line 1845 setStableBufferTime(value) The time that the internal buffer target will be set to post startup/seeks (NOT top quality). When the time is set higher than the default you will have to wait longer to see automatic bitrate switches but will have a larger buffer which will increase stability. Parameters: Name Type Description value int Default Value: 12 seconds. Source: streaming/MediaPlayer.js, line 1552 setTextDefaultEnabled(enable) Set enabled default state. This is used to enable/disable text when a file is loaded. During playback, use enableText to enable text for the file Parameters: Name Type Description enable boolean true to enable text, false otherwise Source: streaming/MediaPlayer.js, line 1965 setTextDefaultLanguage(lang) Set default language for text. If default language is not one of text tracks, dash will choose the first one. Parameters: Name Type Description lang string default language Source: streaming/MediaPlayer.js, line 1933 setTextTrack(idx) Use this method to change the current text track for both external time text files and fragmented text tracks. There is no need to set the track mode on the video object to switch a track when using this method. Parameters: Name Type Description idx number Index of track based on the order of the order the tracks are added Use -1 to disable all tracks. (turn captions off). Use module:MediaPlayer#dashjs.MediaPlayer.events.TEXT_TRACK_ADDED. Source: streaming/MediaPlayer.js, line 2046 See: dashjs.MediaPlayer.events.TEXT_TRACK_ADDED setTrackSwitchModeFor(type, mode) This method sets the current track switch mode. Available options are: MediaController.TRACK_SWITCH_MODE_NEVER_REPLACE (used to forbid clearing the buffered data (prior to current playback position) after track switch. Defers to fastSwitchEnabled for placement of new data. Default for video) MediaController.TRACK_SWITCH_MODE_ALWAYS_REPLACE (used to clear the buffered data (prior to current playback position) after track switch. Default for audio) Parameters: Name Type Description type string mode string Source: streaming/MediaPlayer.js, line 2354 setUseDeadTimeLatencyForAbr( [useDeadTimeLatency]) Set the value of useDeadTimeLatency in AbrController. If true, only the download portion will be considered part of the download bitrate and latency will be regarded as static. If false, the reciprocal of the whole transfer time will be used. Defaults to true. Parameters: Name Type Argument Description useDeadTimeLatency boolean &lt;optional&gt; True or false flag. Source: streaming/MediaPlayer.js, line 1056 setUsePixelRatioInLimitBitrateByPortal(value) Sets whether to take into account the device's pixel ratio when defining the portal dimensions. Useful on, for example, retina displays. Parameters: Name Type Description value boolean Default Value: {boolean} false Source: streaming/MediaPlayer.js, line 961 setVolume(value) A double indicating the audio volume, from 0.0 (silent) to 1.0 (loudest). Parameters: Name Type Description value number Source: streaming/MediaPlayer.js, line 551 setXHRWithCredentialsForType(type, value) Sets whether withCredentials on XHR requests for a particular request type is true or false Parameters: Name Type Description type string one of HTTPRequest.*_TYPE value boolean Default Value: false Source: streaming/MediaPlayer.js, line 1796 time(streamId) Current time of the playhead, in seconds. If called with no arguments then the returned time value is time elapsed since the start point of the first stream, or if it is a live stream, then the time will be based on the return value of the duration() method. However if a stream ID is supplied then time is relative to the start of that stream, or is null if there is no such stream id in the manifest. Parameters: Name Type Description streamId string The ID of a stream that the returned playhead time must be relative to the start of. If undefined, then playhead time is relative to the first stream. Source: streaming/MediaPlayer.js, line 659 Returns: The current playhead time of the media, or null. Type number timeAsUTC() Use this method to get the current playhead time as an absolute value, the time in seconds since midnight UTC, Jan 1 1970. Note - this property only has meaning for live streams. If called before play() has begun, it will return a value of NaN. Source: streaming/MediaPlayer.js, line 712 Returns: The current playhead time as UTC timestamp. Type number updatePortalSize() Update the video element size variables Should be called on window resize (or any other time player is resized). Fullscreen does trigger a window resize event. Once windowResizeEventCalled = true, abrController.checkPortalSize() will use element size variables rather than querying clientWidth every time. Source: streaming/MediaPlayer.js, line 920 useDefaultABRRules(value) Enable/disable builtin dashjs ABR rules Parameters: Name Type Description value boolean Default Value: true Source: streaming/MediaPlayer.js, line 1298 useSuggestedPresentationDelay(value) Set to true if you would like to override the default live delay and honor the SuggestedPresentationDelay attribute in by the manifest. Parameters: Name Type Description value boolean Default Value: false Source: streaming/MediaPlayer.js, line 1156 See: setLiveDelayFragmentCount() × Search results Close "},"module-MssFragmentMoovProcessor.html":{"id":"module-MssFragmentMoovProcessor.html","title":"Module: MssFragmentMoovProcessor","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Module: MssFragmentMoovProcessor Source: mss/MssFragmentMoofProcessor.js, line 32 Module: MssFragmentMoovProcessor Source: mss/MssFragmentMoovProcessor.js, line 32 × Search results Close "},"module-MssParser.html":{"id":"module-MssParser.html","title":"Module: MssParser","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Module: MssParser Source: mss/parser/MssParser.js, line 32 × Search results Close "},"module-ObjectUtils.html":{"id":"module-ObjectUtils.html","title":"Module: ObjectUtils","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Module: ObjectUtils Provides utility functions for objects Source: streaming/utils/ObjectUtils.js, line 35 Methods areEqual(obj1, obj2) Returns true if objects are equal Parameters: Name Type Description obj1 object obj2 object Source: streaming/utils/ObjectUtils.js, line 51 Returns: Type boolean × Search results Close "},"module-ProtectionController.html":{"id":"module-ProtectionController.html","title":"Module: ProtectionController","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Module: ProtectionController Provides access to media protection information and functionality. Each ProtectionController manages a single MediaPlayer.models.ProtectionModel which encapsulates a set of protection information (EME APIs, selected key system, key sessions). The APIs of ProtectionController mostly align with the latest EME APIs. Key system selection is mostly automated when combined with app-overrideable functionality provided in ProtectionKeyController. Source: streaming/protection/controllers/ProtectionController.js, line 36 To Do: ProtectionController does almost all of its tasks automatically after init() is called. Applications might want more control over this process and want to go through each step manually (key system selection, session creation, session maintenance). Methods closeKeySession(sessionToken) Closes the key session and releases all associated decryption keys. These keys will no longer be available for decrypting media Parameters: Name Type Description sessionToken SessionToken the session token Source: streaming/protection/controllers/ProtectionController.js, line 216 Fires: ProtectionController#event:KeySessionClosed createKeySession(initData, cdmData) Create a new key session associated with the given initialization data from the MPD or from the PSSH box in the media Parameters: Name Type Description initData ArrayBuffer the initialization data cdmData Uint8Array the custom data to provide to licenser Source: streaming/protection/controllers/ProtectionController.js, line 151 To Do: In older versions of the EME spec, there was a one-to-one relationship between initialization data and key sessions. That is no longer true in the latest APIs. This API will need to modified (and a new &quot;generateRequest(keySession, initData)&quot; API created) to come up to speed with the latest EME standard Fires: ProtectionController#event:KeySessionCreated initializeForMedia( [mediaInfo]) Initialize this protection system with a given audio or video stream information. Parameters: Name Type Argument Description mediaInfo StreamInfo &lt;optional&gt; Media information Source: streaming/protection/controllers/ProtectionController.js, line 95 To Do: This API will change when we have better support for allowing applications to select different adaptation sets for playback. Right now it is clunky for applications to create StreamInfo with the right information, loadKeySession(sessionID, initData) Loads a key session with the given session ID from persistent storage. This essentially creates a new key session Parameters: Name Type Description sessionID string initData string Source: streaming/protection/controllers/ProtectionController.js, line 186 Fires: ProtectionController#event:KeySessionCreated removeKeySession(sessionToken) Removes the given key session from persistent storage and closes the session as if ProtectionController#closeKeySession was called Parameters: Name Type Description sessionToken SessionToken the session token Source: streaming/protection/controllers/ProtectionController.js, line 202 Fires: ProtectionController#event:KeySessionRemoved ProtectionController#event:KeySessionClosed reset() Destroys all protection data associated with this protection set. This includes deleting all key sessions. In the case of persistent key sessions, the sessions will simply be unloaded and not deleted. Additionally, if this protection set is associated with a HTMLMediaElement, it will be detached from that element. Source: streaming/protection/controllers/ProtectionController.js, line 302 setMediaElement(element) Associate this protection system with the given HTMLMediaElement. This causes the system to register for needkey/encrypted events from the given element and provides a destination for setting of MediaKeys Parameters: Name Type Description element HTMLMediaElement the media element to which the protection system should be associated Source: streaming/protection/controllers/ProtectionController.js, line 245 setProtectionData(data) Attach KeySystem-specific data to use for license acquisition with EME Parameters: Name Type Description data Object an object containing property names corresponding to key system name strings (e.g. &quot;org.w3.clearkey&quot;) and associated values being instances of ProtectionData Source: streaming/protection/controllers/ProtectionController.js, line 288 setRobustnessLevel(level) Sets the robustness level for video and audio capabilities. Optional to remove Chrome warnings. Possible values are SW_SECURE_CRYPTO, SW_SECURE_DECODE, HW_SECURE_CRYPTO, HW_SECURE_CRYPTO, HW_SECURE_DECODE, HW_SECURE_ALL. Parameters: Name Type Description level string the robustness level Source: streaming/protection/controllers/ProtectionController.js, line 275 setServerCertificate(serverCertificate) Sets a server certificate for use by the CDM when signing key messages intended for a particular license server. This will fire an error event if a key system has not yet been selected. Parameters: Name Type Description serverCertificate ArrayBuffer a CDM-specific license server certificate Source: streaming/protection/controllers/ProtectionController.js, line 231 Fires: ProtectionController#event:ServerCertificateUpdated setSessionType(value) Sets the session type to use when creating key sessions. Either &quot;temporary&quot; or &quot;persistent-license&quot;. Default is &quot;temporary&quot;. Parameters: Name Type Description value string the session type Source: streaming/protection/controllers/ProtectionController.js, line 263 × Search results Close "},"module-ProtectionKeyController.html":{"id":"module-ProtectionKeyController.html","title":"Module: ProtectionKeyController","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Module: ProtectionKeyController Media protection key system functionality that can be modified/overridden by applications Source: streaming/protection/controllers/ProtectionKeyController.js, line 42 Methods getKeySystemBySystemString(systemString) Returns the key system associated with the given key system string name (i.e. 'org.w3.clearkey') Parameters: Name Type Description systemString string the system string Source: streaming/protection/controllers/ProtectionKeyController.js, line 120 Returns: the key system or null if no supported key system is associated with the given key system string Type KeySystem | null getKeySystems() Returns a prioritized list of key systems supported by this player (not necessarily those supported by the user agent) Source: streaming/protection/controllers/ProtectionKeyController.js, line 105 Returns: a prioritized list of key systems Type Array.&lt;KeySystem&gt; getLicenseServer(keySystem, protData [, messageType]) Returns the license server implementation data that should be used for this request. Parameters: Name Type Argument Default Description keySystem KeySystem the key system associated with this license request protData ProtectionData protection data to use for the request messageType string &lt;optional&gt; &quot;license-request&quot; the message type associated with this request. Supported message types can be found here. Source: streaming/protection/controllers/ProtectionKeyController.js, line 265 Returns: the license server implementation that should be used for this request or null if the player should not pass messages of the given type to a license server Type LicenseServer | null getSupportedKeySystems(initData, protDataSet) Returns key systems supported by this player for the given PSSH initializationData. Only key systems supported by this player that have protection data present will be returned. Key systems are returned in priority order (highest priority first) Parameters: Name Type Description initData ArrayBuffer Concatenated PSSH data for all DRMs supported by the content protDataSet ProtectionData user specified protection data - license server url etc supported by the content Source: streaming/protection/controllers/ProtectionKeyController.js, line 226 Returns: array of objects indicating which supported key systems were found. Empty array is returned if no supported key systems were found Type Array.&lt;Object&gt; getSupportedKeySystemsFromContentProtection(cps) Returns a set of supported key systems and CENC initialization data from the given array of ContentProtection elements. Only key systems that are supported by this player will be returned. Key systems are returned in priority order (highest first). Parameters: Name Type Description cps Array.&lt;Object&gt; array of content protection elements parsed from the manifest Source: streaming/protection/controllers/ProtectionController.js, line 133 Returns: array of objects indicating which supported key systems were found. Empty array is returned if no supported key systems were found Type Array.&lt;Object&gt; getSupportedKeySystemsFromContentProtection(cps) Returns a set of supported key systems and CENC initialization data from the given array of ContentProtection elements. Only key systems that are supported by this player will be returned. Key systems are returned in priority order (highest first). Parameters: Name Type Description cps Array.&lt;Object&gt; array of content protection elements parsed from the manifest Source: streaming/protection/controllers/ProtectionKeyController.js, line 186 Returns: array of objects indicating which supported key systems were found. Empty array is returned if no supported key systems were found Type Array.&lt;Object&gt; initDataEquals(initData1, initData2) Check equality of initData array buffers. Parameters: Name Type Description initData1 ArrayBuffer first initData initData2 ArrayBuffer second initData Source: streaming/protection/controllers/ProtectionKeyController.js, line 157 Returns: true if the initData arrays are equal in size and contents, false otherwise Type boolean isClearKey(keySystem) Determines whether the given key system is ClearKey. This is necessary because the EME spec defines ClearKey and its method for providing keys to the key session; and this method has changed between the various API versions. Our EME-specific ProtectionModels must know if the system is ClearKey so that it can format the keys according to the particular spec version. Parameters: Name Type Description keySystem Object the key Source: streaming/protection/controllers/ProtectionKeyController.js, line 143 Returns: true if this is the ClearKey key system, false otherwise Type boolean processClearKeyLicenseRequest(clearkeyKeySystem, protData, message) Allows application-specific retrieval of ClearKey keys. Parameters: Name Type Description clearkeyKeySystem KeySystem They exact ClearKey System to be used protData ProtectionData protection data to use for the request message ArrayBuffer the key message from the CDM Source: streaming/protection/controllers/ProtectionKeyController.js, line 299 Returns: the clear keys associated with the request or null if no keys can be returned by this function Type ClearKeyKeySet | null × Search results Close "},"module-URLUtils.html":{"id":"module-URLUtils.html","title":"Module: URLUtils","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Module: URLUtils Provides utility functions for operating on URLs. Initially this is simply a method to determine the Base URL of a URL, but should probably include other things provided all over the place such as determining whether a URL is relative/absolute, resolving two paths etc. Source: streaming/utils/URLUtils.js, line 34 Methods &lt;private&gt; dumbURLResolver(url [, baseUrl]) Resolves a url given an optional base url Does not resolve ./, ../ etc but will do enough to construct something which will satisfy XHR etc when window.URL is not available ie IE11/node etc. Parameters: Name Type Argument Description url string baseUrl string &lt;optional&gt; Source: streaming/utils/URLUtils.js, line 83 Returns: Type string isHTTPS(url) Determines whether the supplied url has https scheme Parameters: Name Type Description url string Source: streaming/utils/URLUtils.js, line 236 Returns: Type bool isHTTPURL(url) Determines whether the url is an HTTP-URL as defined in ISO/IEC 23009-1:2014 3.1.15. ie URL with a fixed scheme of http or https Parameters: Name Type Description url string Source: streaming/utils/URLUtils.js, line 225 Returns: Type bool isPathAbsolute(url) Determines whether the url is path-absolute. Parameters: Name Type Description url string Source: streaming/utils/URLUtils.js, line 202 Returns: Type bool isRelative(url) Determines whether the url is relative. Parameters: Name Type Description url string Source: streaming/utils/URLUtils.js, line 191 Returns: Type bool isSchemeRelative(url) Determines whether the url is scheme-relative. Parameters: Name Type Description url string Source: streaming/utils/URLUtils.js, line 213 Returns: Type bool &lt;private&gt; nativeURLResolver(url [, baseUrl]) Resolves a url given an optional base url Uses window.URL to do the resolution. Parameters: Name Type Argument Description url string baseUrl string &lt;optional&gt; Source: streaming/utils/URLUtils.js, line 61 Returns: Type string parseBaseUrl(url) Returns a string that contains the Base URL of a URL, if determinable. Parameters: Name Type Description url string full url Source: streaming/utils/URLUtils.js, line 129 Returns: Type string parseOrigin(url) Returns a string that contains the scheme and origin of a URL, if determinable. Parameters: Name Type Description url string full url Source: streaming/utils/URLUtils.js, line 157 Returns: Type string parseScheme(url) Returns a string that contains the scheme of a URL, if determinable. Parameters: Name Type Description url string full url Source: streaming/utils/URLUtils.js, line 174 Returns: Type string resolve(url [, baseUrl]) Resolves a url given an optional base url Parameters: Name Type Argument Description url string baseUrl string &lt;optional&gt; Source: streaming/utils/URLUtils.js, line 248 Returns: Type string × Search results Close "},"module-XHRLoader.html":{"id":"module-XHRLoader.html","title":"Module: XHRLoader","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Module: XHRLoader Manages download of resources via HTTP. Source: streaming/net/XHRLoader.js, line 33 × Search results Close "},"PlayList.html":{"id":"PlayList.html","title":"Class: PlayList","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Class: PlayList PlayList a PlayList from ISO23009-1 Annex D, this Object holds reference to the playback session information new PlayList() Source: streaming/vo/metrics/PlayList.js, line 34 Members mstart Presentation time at which playout was requested by the user... Source: streaming/vo/metrics/PlayList.js, line 49 start Timestamp of the user action that starts the playback stream... Source: streaming/vo/metrics/PlayList.js, line 44 starttype Type of user action which triggered playout New playout request (e.g. initial playout or seeking) Resume from pause Other user request (e.g. user-requested quality change) Start of a metrics collection stream (hence earlier entries in the play list not collected) Source: streaming/vo/metrics/PlayList.js, line 58 trace List of streams of continuous rendering of decoded samples. Source: streaming/vo/metrics/PlayList.js, line 64 × Search results Close "},"PlayListTrace.html":{"id":"PlayListTrace.html","title":"Class: PlayListTrace","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Class: PlayListTrace PlayListTrace a PlayList.Trace from ISO23009-1 Annex D new PlayListTrace() Source: streaming/vo/metrics/PlayList.js, line 77 Members duration :number The duration of the continuously presented samples (which is the same in real time and media time). &quot;Continuously presented&quot; means that the media clock continued to advance at the playout speed throughout the interval. NOTE: the spec does not call out the units, but all other durations etc are in ms, and we use ms too. Type: number Source: streaming/vo/metrics/PlayList.js, line 113 mstart :number The presentation time of the first sample rendered. Type: number Source: streaming/vo/metrics/PlayList.js, line 107 playbackspeed :number The playback speed relative to normal playback speed (i.e.normal forward playback speed is 1.0). Type: number Source: streaming/vo/metrics/PlayList.js, line 119 representationid :string The value of the Representation@id of the Representation from which the samples were taken. Type: string Source: streaming/vo/metrics/PlayList.js, line 87 start :number The time at which the first sample was rendered Type: number Source: streaming/vo/metrics/PlayList.js, line 101 stopreason :string The reason why continuous presentation of this Representation was stopped. representation switch rebuffering user request end of Period end of Stream end of content end of a metrics collection period Type: string Source: streaming/vo/metrics/PlayList.js, line 133 subreplevel :number If not present, this metrics concerns the Representation as a whole. If present, subreplevel indicates the greatest value of any Subrepresentation@level being rendered. Type: number Source: streaming/vo/metrics/PlayList.js, line 95 × Search results Close "},"PlayReady.html":{"id":"PlayReady.html","title":"Class: PlayReady","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Class: PlayReady PlayReady new PlayReady() Microsoft PlayReady Test License Server For testing content that uses the PlayReady test server at Implements: LicenseServer Source: streaming/protection/servers/PlayReady.js, line 43 × Search results Close "},"PreBufferSink.html":{"id":"PreBufferSink.html","title":"Class: PreBufferSink","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Class: PreBufferSink PreBufferSink new PreBufferSink() This is a sink that is used to temporarily hold onto media chunks before a video element is added. The discharge() function is used to get the chunks out of the PreBuffer for adding to a real SourceBuffer. Implements: FragmentSink Source: streaming/PreBufferSink.js, line 34 Methods discharge(start, end) Return the all chunks in the buffer the lie between times start and end. Because a chunk cannot be split, this returns the full chunk if any part of its time lies in the requested range. Chunks are removed from the buffer when they are discharged. Parameters: Name Type Argument Description start Number &lt;nullable&gt; The start time from which to discharge from the buffer. If NaN, it is regarded as unbounded. end Number &lt;nullable&gt; The end time from which to discharge from the buffer. If NaN, it is regarded as unbounded. Source: streaming/PreBufferSink.js, line 120 Returns: The set of chunks from the buffer within the time ranges. Type Array × Search results Close "},"ProtectionEvents.html":{"id":"ProtectionEvents.html","title":"Class: ProtectionEvents","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Class: ProtectionEvents ProtectionEvents new ProtectionEvents() Public facing external events to be used when including protection package. All public events will be aggregated into the MediaPlayerEvents Class and can be accessed via MediaPlayer.events. public_ is the prefix that we use to move event names to MediaPlayerEvents. Source: streaming/protection/ProtectionEvents.js, line 36 Events KEY_ADDED Event ID for events delivered when a new key has been added Deprecated: The latest versions of the EME specification no longer use this event. {@MediaPlayer.models.protectionModel.eventList.KEY_STATUSES_CHANGED} is preferred. Source: streaming/protection/ProtectionEvents.js, line 66 KEY_ERROR Event ID for events delivered when an error is encountered by the CDM while processing a license server response message Source: streaming/protection/ProtectionEvents.js, line 76 KEY_MESSAGE Event ID for events delivered when the protection set receives a key message from the CDM Source: streaming/protection/ProtectionEvents.js, line 83 KEY_SESSION_CLOSED Event ID for events delivered when a key session close process has completed Source: streaming/protection/ProtectionEvents.js, line 90 KEY_SESSION_CREATED Event ID for events delivered when a new key sessions creation process has completed Source: streaming/protection/ProtectionEvents.js, line 97 KEY_SESSION_REMOVED Event ID for events delivered when a key session removal process has completed Source: streaming/protection/ProtectionEvents.js, line 104 KEY_STATUSES_CHANGED Event ID for events delivered when the status of one or more decryption keys has changed Source: streaming/protection/ProtectionEvents.js, line 111 KEY_SYSTEM_SELECTED Event ID for events delivered when a key system selection procedure completes Source: streaming/protection/ProtectionEvents.js, line 125 LICENSE_REQUEST_COMPLETE Event ID for events delivered when a license request procedure has completed Source: streaming/protection/ProtectionEvents.js, line 132 PROTECTION_CREATED Event ID for events delivered when the Protection system is detected and created. Source: streaming/protection/ProtectionEvents.js, line 145 PROTECTION_DESTROYED Event ID for events delivered when the Protection system is destroyed. Source: streaming/protection/ProtectionEvents.js, line 151 × Search results Close "},"ProtectionModel.html":{"id":"ProtectionModel.html","title":"Interface: ProtectionModel","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Interface: ProtectionModel ProtectionModel Defines the public interface for all ProtectionModel implementations. ProtectionModel implementations provide access to particular versions of the Encrypted Media Extensions (EME) APIs that have been implemented in a user agent. Developers wishing to add support for a new EME version found in a target user-agent should add a new instance of this interface to the Applications should not need direct access to this object. All interactions with the protection system should be performed with module:ProtectionController Source: streaming/protection/models/ProtectionModel.js, line 33 Members &lt;readonly&gt; keySystem :MediaPlayer.dependencies.protection.KeySystem Currently selected key system. Will be null or undefined if no key system has yet been selected Type: MediaPlayer.dependencies.protection.KeySystem Source: streaming/protection/models/ProtectionModel.js, line 186 Methods closeKeySession(sessionToken) Close the given session and release all associated keys. Following this call, the sessionToken becomes invalid. Sends KEY_SESSION_CLOSED with sessionID as data Parameters: Name Type Description sessionToken the session token Source: streaming/protection/models/ProtectionModel.js, line 164 createKeySession(initData, protData, sessionType) Creates a new key session using the given initData and type. Sends KEY_SESSION_CREATED event with MediaPlayer.vo.protection.SessionToken as data. Parameters: Name Type Description initData ArrayBuffer PSSH box for the currently selected key system. protData ProtectionData Protection data for the currently selected key system. sessionType string the desired session type. One of &quot;temporary&quot;, &quot;persistent-license&quot;, &quot;persistent-release-message&quot;. CDM implementations are not required to support anything except &quot;temporary&quot; Source: streaming/protection/models/ProtectionModel.js, line 104 getAllInitData() Returns an array of all initialization data currently used by active sessions. Source: streaming/protection/models/ProtectionModel.js, line 51 Returns: an array of initialization data buffers Type Array.&lt;ArrayBuffer&gt; loadKeySession(sessionID, the) Loads the persisted key session data associated with the given sessionID into a new session. Sends KEY_SESSION_CREATED event with {@MediaPlayer.vo.protection.SessionToken} as data. Parameters: Name Type Description sessionID string the session ID corresponding to the persisted session data to be loaded the ArrayBuffer corresponding initData PSSH box for the currently selected key system. Source: streaming/protection/models/ProtectionModel.js, line 136 removeKeySession(sessionToken) Removes any persisted key session data associated with the given session. Also closes the session. Sends KEY_SESSION_REMOVED and ENAME_KEY_SESSION_CLOSED with sessionID as data Parameters: Name Type Description sessionToken SessionToken the session token Source: streaming/protection/models/ProtectionModel.js, line 151 requestKeySystemAccess(ksConfigurations) Determine if the user-agent supports one of the given key systems and content type configurations. Sends ENAME_KEY_SYSTEM_ACCESS_COMPLETE event with a KeySystemAccess object as event data Parameters: Name Type Description ksConfigurations Array.&lt;Object&gt; array of desired key system configurations in priority order (highest priority first) Properties Name Type Description ks MediaPlayer.dependencies.protection.KeySystem the key system configs Array.&lt;MediaPlayer.vo.protection.KeySystemConfiguration&gt; array of acceptable key system configurations for this key system in priority order (highest priority first) Source: streaming/protection/models/ProtectionModel.js, line 61 selectKeySystem(keySystemAccess) Selects the key system to use for all future operations on this ProtectionModel. Sends ENAME_KEY_SYSTEM_SELECTED with no data Parameters: Name Type Description keySystemAccess MediaPlayer.vo.protection.KeySystemAccess the key system access token representing a supported key system Source: streaming/protection/models/ProtectionModel.js, line 80 setMediaElement(mediaElement) Associate this protection model with a HTMLMediaElement Parameters: Name Type Description mediaElement HTMLMediaElement the media element to which we should associate this protection model and all current key sessions Source: streaming/protection/models/ProtectionModel.js, line 92 setServerCertificate(serverCertificate) Sets the certificate to be used by the CDM for encrypting messages Parameters: Name Type Description serverCertificate ArrayBuffer Source: streaming/protection/models/ProtectionModel.js, line 176 updateKeySession(sessionToken, message) Update the given key session with a key (or any other message intended for the CDM) Parameters: Name Type Description sessionToken MediaPlayer.vo.protection.SessionToken the session token message ArrayBuffer the message that should be delivered to the CDM for this session Source: streaming/protection/models/ProtectionModel.js, line 122 × Search results Close "},"RepresentationSwitch.html":{"id":"RepresentationSwitch.html","title":"Class: RepresentationSwitch","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Class: RepresentationSwitch RepresentationSwitch new RepresentationSwitch() This Object holds reference to the info at quality switch between two representations. Source: streaming/vo/metrics/RepresentationSwitch.js, line 34 Members lto If not present, this metrics concerns the Representation as a whole. If present, lto indicates the value of SubRepresentation@level within Representation identifying the switch-to level of the Representation. Source: streaming/vo/metrics/RepresentationSwitch.js, line 65 mt The media presentation time of the earliest access unit (out of all media content components) played out from the Representation. Source: streaming/vo/metrics/RepresentationSwitch.js, line 52 t Time of the switch event. Source: streaming/vo/metrics/RepresentationSwitch.js, line 44 to Value of Representation@id identifying the switch-to Representation. Source: streaming/vo/metrics/RepresentationSwitch.js, line 57 × Search results Close "},"RequestsQueue.html":{"id":"RequestsQueue.html","title":"Class: RequestsQueue","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Class: RequestsQueue RequestsQueue new RequestsQueue() This Object holds reference to Fragment Model's request queues Source: streaming/vo/metrics/RequestsQueue.js, line 34 Members executedRequests Array of the The requests that have completed Source: streaming/vo/metrics/RequestsQueue.js, line 50 loadingRequests Array of all of the requests that have begun to load This request may not make it into the executed queue if it is abandon due to ABR rules for example. Source: streaming/vo/metrics/RequestsQueue.js, line 45 × Search results Close "},"Round10.html":{"id":"Round10.html","title":"Class: Round10","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Class: Round10 Round10 new Round10() Static methods for rounding decimals Modified version of the CC0-licenced example at: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/round Source: dash/utils/Round10.js, line 32 × Search results Close "},"SchedulingInfo.html":{"id":"SchedulingInfo.html","title":"Class: SchedulingInfo","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Class: SchedulingInfo SchedulingInfo new SchedulingInfo() This Object holds reference to the index handling of the current fragment being loaded or executed. Source: streaming/vo/metrics/SchedulingInfo.js, line 34 Members availabilityStartTime Availability start time of fragment Source: streaming/vo/metrics/SchedulingInfo.js, line 65 duration Duration of fragment Source: streaming/vo/metrics/SchedulingInfo.js, line 70 mediaType Type of stream Audio | Video | FragmentedText Source: streaming/vo/metrics/SchedulingInfo.js, line 44 quality Bit Rate Quality of fragment Source: streaming/vo/metrics/SchedulingInfo.js, line 75 range Range of fragment Source: streaming/vo/metrics/SchedulingInfo.js, line 80 startTime Presentation start time of fragment Source: streaming/vo/metrics/SchedulingInfo.js, line 60 state Current state of fragment Source: streaming/vo/metrics/SchedulingInfo.js, line 86 t Time of the scheduling event. Source: streaming/vo/metrics/SchedulingInfo.js, line 49 type Type of fragment (initialization | media) Source: streaming/vo/metrics/SchedulingInfo.js, line 55 × Search results Close "},"SessionToken.html":{"id":"SessionToken.html","title":"Interface: SessionToken","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Interface: SessionToken SessionToken All session identifiers (tokens) returned by ProtectionController as well as ProtectionModel implementations are guaranteed to contain certain properties regardless of the proprietary data each ProtectionModel will need to attach. This interface defines the common APIs for session tokens available for applications to access. Source: streaming/protection/vo/SessionToken.js, line 31 Members &lt;readonly&gt; initData :ArrayBuffer The initialization data used to create this session Type: ArrayBuffer Source: streaming/protection/vo/SessionToken.js, line 43 Methods getExpirationTime() The time, in milliseconds since 01 January, 1970 UTC, after which the key(s) in the session will no longer be usable to decrypt media data, or NaN if no such time exists Source: streaming/protection/vo/SessionToken.js, line 62 Returns: the expiration time or NaN if no expiration time exists for this session Type number getKeyStatuses() Returns a read-only map of key IDs known to the session to the current status of the associated key. Source: streaming/protection/vo/SessionToken.js, line 73 Returns: the map of keys in this session and their associated status Type maplike.&lt;BufferSource, MediaKeyStatus&gt; getSessionID() Returns the unique session ID designated to this session Source: streaming/protection/vo/SessionToken.js, line 53 Returns: the session ID or the empty string if the implementation does not support session IDs or the sessionID has not yet been established Type string getSessionType() Returns the session type. Session types are defined here Source: streaming/protection/vo/SessionToken.js, line 83 Returns: The session type Type string × Search results Close "},"SourceBufferSink.html":{"id":"SourceBufferSink.html","title":"Class: SourceBufferSink","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Class: SourceBufferSink SourceBufferSink new SourceBufferSink() Implements: FragmentSink Source: streaming/SourceBufferSink.js, line 37 × Search results Close "},"TCPConnection.html":{"id":"TCPConnection.html","title":"Class: TCPConnection","body":" Dash JS Modules DashMetricsDebugFactoryMakerFetchLoaderHTTPLoaderMediaPlayerMssFragmentMoovProcessorMssParserObjectUtilsProtectionControllerProtectionKeyControllerURLUtilsXHRLoader Classes BaseMatcherBufferLevelBufferStateCommonEncryptionCommonPropertyDroppedFramesDVRInfoHTTPRequestHTTPRequestTraceLiveEdgeFinderManifestUpdateManifestUpdateRepresentationInfoManifestUpdateStreamInfoMediaPlayerEventsPlayListPlayListTracePlayReadyPreBufferSinkProtectionEventsRepresentationSwitchRequestsQueueRound10SchedulingInfoSourceBufferSinkTCPConnection Events MediaPlayerEvents#event:BUFFER_EMPTYMediaPlayerEvents#event:BUFFER_LEVEL_STATE_CHANGEDMediaPlayerEvents#event:BUFFER_LOADEDMediaPlayerEvents#event:CAN_PLAYMediaPlayerEvents#event:ERRORMediaPlayerEvents#event:FRAGMENT_LOADING_ABANDONEDMediaPlayerEvents#event:FRAGMENT_LOADING_COMPLETEDMediaPlayerEvents#event:FRAGMENT_LOADING_PROGRESSMediaPlayerEvents#event:FRAGMENT_LOADING_STARTEDMediaPlayerEvents#event:LOGMediaPlayerEvents#event:MANIFEST_LOADEDMediaPlayerEvents#event:MANIFEST_VALIDITY_CHANGEDMediaPlayerEvents#event:METRIC_ADDEDMediaPlayerEvents#event:METRIC_CHANGEDMediaPlayerEvents#event:METRIC_UPDATEDMediaPlayerEvents#event:METRICS_CHANGEDMediaPlayerEvents#event:PERIOD_SWITCH_COMPLETEDMediaPlayerEvents#event:PERIOD_SWITCH_STARTEDMediaPlayerEvents#event:PLAYBACK_CATCHUP_ENDMediaPlayerEvents#event:PLAYBACK_CATCHUP_STARTMediaPlayerEvents#event:PLAYBACK_ENDEDMediaPlayerEvents#event:PLAYBACK_ERRORMediaPlayerEvents#event:PLAYBACK_METADATA_LOADEDMediaPlayerEvents#event:PLAYBACK_NOT_ALLOWEDMediaPlayerEvents#event:PLAYBACK_PAUSEDMediaPlayerEvents#event:PLAYBACK_PLAYINGMediaPlayerEvents#event:PLAYBACK_PROGRESSMediaPlayerEvents#event:PLAYBACK_RATE_CHANGEDMediaPlayerEvents#event:PLAYBACK_SEEK_ASKEDMediaPlayerEvents#event:PLAYBACK_SEEKEDMediaPlayerEvents#event:PLAYBACK_SEEKINGMediaPlayerEvents#event:PLAYBACK_STARTEDMediaPlayerEvents#event:PLAYBACK_TIME_UPDATEDMediaPlayerEvents#event:PLAYBACK_WAITINGMediaPlayerEvents#event:QUALITY_CHANGE_RENDEREDMediaPlayerEvents#event:QUALITY_CHANGE_REQUESTEDMediaPlayerEvents#event:SOURCE_INITIALIZEDMediaPlayerEvents#event:STREAM_INITIALIZEDMediaPlayerEvents#event:STREAM_TEARDOWN_COMPLETEMediaPlayerEvents#event:TEXT_TRACK_ADDEDMediaPlayerEvents#event:TEXT_TRACKS_ADDEDMediaPlayerEvents#event:TRACK_CHANGE_RENDEREDMediaPlayerEvents#event:TTML_PARSEDProtectionEvents#event:KEY_ADDEDProtectionEvents#event:KEY_ERRORProtectionEvents#event:KEY_MESSAGEProtectionEvents#event:KEY_SESSION_CLOSEDProtectionEvents#event:KEY_SESSION_CREATEDProtectionEvents#event:KEY_SESSION_REMOVEDProtectionEvents#event:KEY_STATUSES_CHANGEDProtectionEvents#event:KEY_SYSTEM_SELECTEDProtectionEvents#event:LICENSE_REQUEST_COMPLETEProtectionEvents#event:PROTECTION_CREATEDProtectionEvents#event:PROTECTION_DESTROYED Interfaces FragmentSinkKeySystemLoggerProtectionModelSessionToken Global _decimalAdjustEBMLParserGenericMetricHandlerHandlerHelpersMetricSerialiserRNGround10URIFragmentModelWidevine Class: TCPConnection TCPConnection new TCPConnection() This Object holds reference to the current tcp connection Source: streaming/vo/metrics/TCPConnection.js, line 34 Members dest IP Address of the interface over which the client is receiving the TCP data. Source: streaming/vo/metrics/TCPConnection.js, line 49 tclose Real-Time | The time at which the connection was closed (sending or reception time of FIN or RST or close socket operation). Source: streaming/vo/metrics/TCPConnection.js, line 59 tconnect Connect time in ms (time from sending the initial SYN to receiving the ACK or completion of the connect socket operation). Source: streaming/vo/metrics/TCPConnection.js, line 64 tcpid Identifier of the TCP connection on which the HTTP request was sent. Source: streaming/vo/metrics/TCPConnection.js, line 44 topen Real-Time | The time at which the connection was opened (sending time of the initial SYN or connect socket operation). Source: streaming/vo/metrics/TCPConnection.js, line 54 × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
